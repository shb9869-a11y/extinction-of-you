<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Camera – Motion Pan/Vol + Mic Focus + Pixel Maze (12 stages)</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root{
    --frame: 40px; --ui-gap: 8px;
    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --pad-line: clamp(4px, 0.9vmin, 8px);
    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #view{width:100%;height:100%;display:block;position:fixed;left:0;top:0;z-index:0}
  .frameBox{position:fixed;left:var(--frame);top:var(--frame);right:var(--frame);bottom:var(--frame);border:1px solid #000;pointer-events:none;z-index:50}

  .uiBtn{background:#000;color:#fff;border:1px solid #000;font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}

  .controls{position:fixed;right:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small)}
  .btn-capture{position:fixed;left:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:150}

  #overlay{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;padding:20px;font-family:"Courier New",monospace;color:#fff;pointer-events:none}
  #overlayContent{pointer-events:auto;line-height:1.7;font-size:var(--fs-body);max-width:min(72ch, calc(100vw - (var(--frame)*2)));max-height:calc(100vh - (var(--frame)*2));overflow:hidden;text-align:left}
  .line{display:inline;background:#000;color:#fff;padding:calc(var(--pad-line)*0.8) var(--pad-line);box-decoration-break:clone;-webkit-box-decoration-break:clone}
  .lineWrap{margin:6px 0}
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}
  #goodnight{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:250;display:none;text-align:center;font-family:"Courier New",monospace;font-size:var(--fs-strong);color:#fff;background:#000;padding:var(--pad-btn-y) var(--pad-btn-x);white-space:nowrap;transition:opacity .6s ease}
  #goodnight.show{display:block;opacity:1}
  #goodnight.fadeout{opacity:0}
  @media (orientation:landscape){ :root{ --frame: 32px; } }
  .tip{opacity:.7;font-size:var(--fs-small);margin-top:8px}

  /* 컷인(침묵) */
  #cutin{
    position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center;
    background:#000; color:#fff; font-family:"Courier New",monospace; text-align:center;
  }
  #cutin.show{display:flex; opacity:1; transition:opacity .45s ease}
  #cutin.fadeout{opacity:0}
  #cutinText{font-size:clamp(24px, 8vmin, 64px); letter-spacing:.02em; line-height:1.2; padding:0 .2em}
  .introTitle{font-weight:400; letter-spacing:.02em}

  /* ====== PIXEL MAZE GAME OVERLAY ====== */
  #gameOverlay{
    position:fixed; inset:0; z-index:300; display:none; background:rgba(0,0,0,.8);
    font-family:"Courier New",monospace; color:#fff;
  }
  #gameUI{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    display:flex; flex-direction:column; align-items:center; gap:10px;
    width:min(96vw, 860px);
  }
  #gameHeader{
    width:100%; display:flex; justify-content:space-between; align-items:center; gap:8px;
  }
  #gameCanvas{ width:100%; height:60vh; background:#000; image-rendering: pixelated; border:1px solid #444 }
  #gameBtns{ display:flex; gap:6px; align-items:center }
  #mapGrid{
    display:grid; grid-template-columns:repeat(6,minmax(0,1fr)); gap:6px; width:100%;
  }
  .stageBtn{
    border:1px solid #444; background:#000; color:#fff; padding:8px 0; text-align:center; cursor:pointer; font-size:var(--fs-small)
  }
  .stageBtn.done{ border-color:#0f0; color:#0f0 }
  .stageBtn.active{ border-color:#fff }
  #hud{ display:flex; gap:12px; align-items:center; opacity:.85; font-size:var(--fs-small) }

  /* 모바일 가상 방향키 */
  #dpad{
    position:absolute; left:var(--frame); bottom:calc(var(--frame) + 64px); z-index:320;
    display:grid; grid-template-columns:repeat(3,48px); grid-template-rows:repeat(3,48px); gap:6px;
  }
  .dkey{ width:48px; height:48px; border:1px solid #444; display:flex; align-items:center; justify-content:center; color:#fff; background:#000; opacity:.7; user-select:none; }
  .dkey:active{ opacity:1 }

  /* 항상 표시되는 MAP 버튼(오른쪽 상단) */
  #mapLauncher{
    position:fixed; right:calc(var(--frame) + var(--ui-gap)); top:calc(var(--frame) + var(--ui-gap));
    z-index:280;
  }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <!-- 기본 컨트롤 -->
  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.2×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <!-- 항상 보이는 MAP 런처 -->
  <button id="mapLauncher" class="uiBtn small">MAP</button>

  <!-- 내러티브/컷인 -->
  <div id="overlay" class="fade">
    <div id="overlayContent" class="fade">
      <button id="welcomeBtn" class="uiBtn">Welcome to ‘Dialogue into Silence’</button>
      <div class="tip" id="sensorTip" style="display:none">센서 권한 필요: 시작을 누르면 허용 팝업이 뜹니다.</div>
    </div>
  </div>
  <div id="goodnight">GOOD NIGHT, HAVE A NICE DREAM</div>
  <div id="cutin"><div id="cutinText">FIRST SILENCE</div></div>

  <!-- ====== GAME OVERLAY ====== -->
  <div id="gameOverlay">
    <div id="gameUI">
      <div id="gameHeader">
        <div id="hud">
          <span>STAGE: <span id="hudStage">1</span>/12</span>
          <span>DEATHS: <span id="hudDeaths">0</span></span>
          <span>TIME: <span id="hudTime">0.0</span>s</span>
        </div>
        <div id="gameBtns">
          <button id="btnMap" class="uiBtn small">MAP</button>
          <button id="btnExit" class="uiBtn small">EXIT</button>
        </div>
      </div>
      <canvas id="gameCanvas" width="480" height="320"></canvas>
      <div id="mapGrid"></div>
    </div>

    <!-- 모바일 DPAD -->
    <div id="dpad">
      <div></div><div class="dkey" data-dy="-1">↑</div><div></div>
      <div class="dkey" data-dx="-1">←</div><div class="dkey" data-dy="1">↓</div><div class="dkey" data-dx="1">→</div>
      <div></div><div></div><div></div>
    </div>
  </div>

<script>
(async ()=>{
  /* ========= 카메라(흑백+잔상) ========= */
  const view=document.getElementById('view');
  const vctx=view.getContext('2d',{alpha:false});
  const PROC_SCALE=0.60, TRAIL_ALPHA=0.12, GLOBAL_ALPHA=0.7;
  let ZOOM=1.2, ZOOM_MIN=0.5, ZOOM_MAX=3.0, ZOOM_STEP=0.1;

  const zoomVal=document.getElementById('zoomVal');
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const updateZoom=()=>zoomVal.textContent=ZOOM.toFixed(1)+'×';
  document.getElementById('zoomIn').onclick=()=>{ZOOM=clamp(ZOOM+ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  document.getElementById('zoomOut').onclick=()=>{ZOOM=clamp(ZOOM-ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  updateZoom();

  const camVideo=document.createElement('video'); camVideo.autoplay=true; camVideo.playsInline=true; camVideo.muted=true;
  const proc=document.createElement('canvas'); const pctx=proc.getContext('2d',{willReadFrequently:true});

  async function attachCamera(){
    try{
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
      camVideo.srcObject=s; await camVideo.play().catch(()=>{});
    }catch(e){console.warn("카메라 실패:", e);}
  }
  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth,h=window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale=(window.matchMedia('(orientation: landscape)').matches)? PROC_SCALE*0.9 : PROC_SCALE;
    proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale);
  }
  resizeAll(); addEventListener('resize',()=>setTimeout(resizeAll,50));

  function loop(){
    requestAnimationFrame(loop);
    const W=view.width/(window.devicePixelRatio||1);
    const H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;
    pctx.globalCompositeOperation="source-over";
    pctx.fillStyle=`rgba(0,0,0,${TRAIL_ALPHA})`; pctx.fillRect(0,0,PW,PH);
    if(camVideo.readyState>=2){
      const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
      if(vw && vh){
        const base=Math.max(PW/vw,PH/vh), sc=base*ZOOM;
        const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
        pctx.globalAlpha=GLOBAL_ALPHA; pctx.drawImage(camVideo,dx,dy,dw,dh);
        pctx.globalAlpha=1.0;
        const frame=pctx.getImageData(0,0,PW,PH); const d=frame.data;
        for(let i=0;i<d.length;i+=4){
          const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;
        }
        pctx.putImageData(frame,0,0);
      }
    }
    vctx.drawImage(proc,0,0,W,H);
  }
  await attachCamera(); loop();

  /* ========= 오디오/센서/내러티브 (네가 준 버전 유지) ========= */
  let audioCtx=null, masterGain=null, limiter=null;
  let motionGain=null;
  let bgOsc=null, bgGain=null;
  let micStream=null;
  let micPreGain=null, micMakeup=null;
  let dronePermanentlyStopped=false;
  const DRONE_FREQ=80, DRONE_BASE=0.08, DRONE_MAX_ADD=0.10;
  const VOL_BASE=0.20, VOL_MAX_ADD=0.55;
  const SMOOTH_TC=0.08, CTRL_SMOOTH_ALPHA=0.12;
  const DEADZONE_VOL_DEG=5, DEADZONE_PAN_DEG=3, VOL_TILT_LIMIT=60, PAN_LIMIT_DEG=45;
  const MIC_HP=180; const MIC_LOWSHELF_FREQ=180, MIC_LOWSHELF_GAIN=-6; const NOTCH_FREQ=300, NOTCH_Q=3.5;
  const COMP_THRESHOLD=-28, COMP_RATIO=4.2, COMP_ATTACK=0.004, COMP_RELEASE=0.14;
  const MIC_WET=0.60, MIC_DRY=0.12;
  const MIC_BOOST_X = 6.0; const MIC_MAKEUP_BASE = 5.0;

  function initAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    try{
      const dest = audioCtx.destination;
      if (dest.maxChannelCount && dest.maxChannelCount >= 2) dest.channelCount = 2;
      if (dest.channelCountMode) dest.channelCountMode = 'explicit';
      if (dest.channelInterpretation) dest.channelInterpretation = 'discrete';
    }catch{}
    const mixBus = audioCtx.createGain(); window.__mixBus__ = mixBus;

    let panSetter=null, panOutNode=null;
    if (audioCtx.createStereoPanner) {
      const sp = audioCtx.createStereoPanner();
      panSetter = (val)=>{ try{ sp.pan.setTargetAtTime(val, audioCtx.currentTime, 0.08); }catch{ sp.pan.value=val; } };
      mixBus.connect(sp); panOutNode = sp;
    } else {
      const lGain=audioCtx.createGain(), rGain=audioCtx.createGain(), merger=audioCtx.createChannelMerger(2);
      mixBus.connect(lGain); mixBus.connect(rGain);
      lGain.connect(merger,0,0); rGain.connect(merger,0,1);
      panSetter = (pan)=>{
        const p=Math.max(-1,Math.min(1,pan||0));
        const th=(p+1)*0.25*Math.PI; const gL=Math.cos(th), gR=Math.sin(th);
        try{ lGain.gain.setTargetAtTime(gL,audioCtx.currentTime,0.08); rGain.gain.setTargetAtTime(gR,audioCtx.currentTime,0.08); }
        catch{ lGain.gain.value=gL; rGain.gain.value=gR; }
      };
      panOutNode=merger;
    }
    window.__setPan__ = panSetter;

    motionGain = audioCtx.createGain(); motionGain.gain.value = VOL_BASE;
    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value=-3; limiter.knee.value=0; limiter.ratio.value=20;
    limiter.attack.value=0.002; limiter.release.value=0.10;
    const outMakeup = audioCtx.createGain(); outMakeup.gain.value = 1.6;
    masterGain = audioCtx.createGain(); masterGain.gain.value=1.0;

    panOutNode.connect(motionGain);
    motionGain.connect(limiter);
    limiter.connect(outMakeup);
    outMakeup.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    const sfxBus = audioCtx.createGain(); sfxBus.gain.value = 0.6;
    sfxBus.connect(window.__mixBus__);
    window.__sfxBus__ = sfxBus;
  }
  function playClick(){
    try{
      initAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type='square'; osc.frequency.setValueAtTime(880, t);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.5, t+0.005);
      gain.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      osc.connect(gain).connect(window.__sfxBus__); osc.start(t); osc.stop(t+0.14);
    }catch{}
  }
  function playFlip(){
    try{
      initAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filt = audioCtx.createBiquadFilter();
      osc.type='triangle';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(900, t+0.25);
      filt.type='bandpass'; filt.frequency.setValueAtTime(800, t); filt.Q.value=1.2;
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.6, t+0.04);
      gain.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
      osc.connect(filt).connect(gain).connect(window.__sfxBus__); osc.start(t); osc.stop(t+0.38);
    }catch{}
  }
  function startDrone(){
    if(!audioCtx || bgOsc || dronePermanentlyStopped) return;
    bgOsc=audioCtx.createOscillator(); bgGain=audioCtx.createGain();
    bgOsc.type='sine'; bgOsc.frequency.value=DRONE_FREQ;
    bgGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    bgGain.gain.setTargetAtTime(DRONE_BASE, audioCtx.currentTime, 0.25);
    bgOsc.connect(bgGain).connect(window.__mixBus__);
    bgOsc.start();
  }
  function fadeOutDronePermanently(){
    if(!audioCtx || !bgGain || !bgOsc) { dronePermanentlyStopped=true; return; }
    const now=audioCtx.currentTime;
    try{ bgGain.gain.setTargetAtTime(0.0001, now, 0.5); }
    catch{ bgGain.gain.cancelScheduledValues(now); bgGain.gain.linearRampToValueAtTime(0.0001, now+3.0); }
    setTimeout(()=>{ try{ bgOsc.stop(); }catch{} bgOsc=null; bgGain=null; dronePermanentlyStopped=true; }, 3200);
  }
  async function startMic(){
    if(micStream) return;
    if(!navigator.mediaDevices?.getUserMedia) return;
    const ctrl=new AbortController(); const to=setTimeout(()=>{try{ctrl.abort();}catch{}},3000);
    try{
      micStream=await navigator.mediaDevices.getUserMedia({
        audio:{ echoCancellation:false, noiseSuppression:true, autoGainControl:false },
        video:false, signal:ctrl.signal
      });
    }catch(e){ clearTimeout(to); console.warn('Mic denied/timeout', e); return; }
    clearTimeout(to);

    const src=audioCtx.createMediaStreamSource(micStream);
    micPreGain = audioCtx.createGain(); micPreGain.gain.value = MIC_BOOST_X;

    const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=MIC_HP; hpf.Q.value=0.707;
    const lowshelf=audioCtx.createBiquadFilter(); lowshelf.type='lowshelf'; lowshelf.frequency.value=MIC_LOWSHELF_FREQ; lowshelf.gain.value=MIC_LOWSHELF_GAIN;
    const notch=audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=NOTCH_FREQ; notch.Q.value=NOTCH_Q;
    const comp=audioCtx.createDynamicsCompressor();
    comp.threshold.value=COMP_THRESHOLD; comp.ratio.value=COMP_RATIO; comp.attack.value=COMP_ATTACK; comp.release.value=COMP_RELEASE;

    const convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(2.6,2.4);
    const tapA=audioCtx.createDelay(); tapA.delayTime.value=0.11;
    const tapB=audioCtx.createDelay(); tapB.delayTime.value=0.19;
    const tapC=audioCtx.createDelay(); tapC.delayTime.value=0.27;
    const fbA=audioCtx.createGain(); fbA.gain.value=0.28; tapA.connect(fbA).connect(tapA);
    const fbB=audioCtx.createGain(); fbB.gain.value=0.22; tapB.connect(fbB).connect(tapB);
    const fbC=audioCtx.createGain(); fbC.gain.value=0.18; tapC.connect(fbC).connect(tapC);

    const dry=audioCtx.createGain(); dry.gain.value=MIC_DRY;
    const wet=audioCtx.createGain(); wet.gain.value=MIC_WET;

    const micSum=audioCtx.createGain();
    micMakeup=audioCtx.createGain(); micMakeup.gain.value=MIC_MAKEUP_BASE;

    const analyser=audioCtx.createAnalyser(); analyser.fftSize=512;
    const gateGain=audioCtx.createGain(); gateGain.gain.value=1;
    gateLoop(analyser, gateGain);

    src.connect(micPreGain).connect(hpf).connect(lowshelf).connect(notch).connect(comp);
    comp.connect(analyser);

    comp.connect(dry);
    const wetSplit=audioCtx.createGain();
    comp.connect(wetSplit);
    wetSplit.connect(convolver); wetSplit.connect(tapA); wetSplit.connect(tapB); wetSplit.connect(tapC);
    const wetSum=audioCtx.createGain();
    convolver.connect(wetSum); tapA.connect(wetSum); tapB.connect(wetSum); tapC.connect(wetSum);
    wetSum.connect(wet);

    dry.connect(micSum); wet.connect(micSum);
    micSum.connect(gateGain).connect(micMakeup).connect(window.__mixBus__);
  }
  function gateLoop(analyser, gate){
    const buf=new Uint8Array(analyser.fftSize);
    let open=true;
    const GATE_OPEN_DB=-62, GATE_CLOSE_DB=-68;
    const ATT=0.04, REL=0.20;
    function step(){
      requestAnimationFrame(step);
      analyser.getByteTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
      const rms=Math.sqrt(sum/buf.length);
      const db=20*Math.log10(Math.max(1e-6,rms));
      const now=audioCtx?.currentTime ?? 0;
      const shouldOpen = db>GATE_OPEN_DB || (open && db>GATE_CLOSE_DB);
      if(shouldOpen!==open){
        open=shouldOpen;
        try{ gate.gain.setTargetAtTime(open?1:0, now, open?ATT:REL); }
        catch{ gate.gain.cancelScheduledValues(now); gate.gain.linearRampToValueAtTime(open?1:0, now + (open?ATT:REL)); }
      }
    }
    step();
  }
  function makeIR(seconds=2.6, decay=2.4){
    const rate=audioCtx.sampleRate, len=Math.floor(rate*seconds);
    const ir=audioCtx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const v=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len, env=Math.pow(1-t, decay);
        v[i]=(Math.random()*2-1)*env*0.55;
      }
    }
    return ir;
  }

  let sensorsReady=false;
  const sensorTip=document.getElementById('sensorTip');
  async function requestMotionPermissions(){
    try{
      if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
        const r=await DeviceOrientationEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }else{
        sensorsReady=true;
      }
    }catch(e){ console.warn('Orientation permission error:', e); }
    try{
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        const r=await DeviceMotionEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }
    }catch(e){}
    sensorTip.style.display = sensorsReady? 'none':'block';
    return sensorsReady;
  }
  let latestOri={beta:0,gamma:0}, smVol=VOL_BASE, smPan=0;
  function getScreenAngle(){
    const o=(screen.orientation&&screen.orientation.angle)??window.orientation??0;
    return (typeof o==='number')?o:0;
  }
  function mapOrientation(beta,gamma){
    const ang=((getScreenAngle()%360)+360)%360;
    let volTilt=0, panTilt=0;
    if(ang===0){volTilt=beta; panTilt=gamma;}
    else if(ang===90){volTilt=-gamma; panTilt=beta;}
    else if(ang===180){volTilt=-beta; panTilt=-gamma;}
    else if(ang===270){volTilt=gamma; panTilt=-beta;}
    return {volTilt, panTilt};
  }
  function tiltToPan(panTilt){
    const t=Math.min(PAN_LIMIT_DEG, Math.max(-PAN_LIMIT_DEG, panTilt||0));
    if(Math.abs(t)<DEADZONE_PAN_DEG) return 0;
    return t/PAN_LIMIT_DEG;
  }
  function tiltToVol(volTilt){
    const t=Math.min(VOL_TILT_LIMIT, Math.max(-VOL_TILT_LIMIT, volTilt||0));
    const a=Math.max(0, Math.abs(t)-DEADZONE_VOL_DEG)/(VOL_TILT_LIMIT-DEADZONE_VOL_DEG);
    return VOL_BASE + VOL_MAX_ADD*a;
  }
  function smoothStep(t,c,a=CTRL_SMOOTH_ALPHA){ return c+(t-c)*a; }
  function applyPanVol(pan, vol){
    if(!audioCtx) return;
    const now=audioCtx.currentTime;
    if(window.__setPan__) window.__setPan__(pan);
    if(motionGain){
      try{ motionGain.gain.setTargetAtTime(vol, now, SMOOTH_TC); }
      catch{ motionGain.gain.cancelScheduledValues(now); motionGain.gain.linearRampToValueAtTime(vol, now+0.08); }
    }
    if(bgGain && !dronePermanentlyStopped){
      const droneVol = DRONE_BASE + DRONE_MAX_ADD * ((vol - VOL_BASE) / (VOL_MAX_ADD||1));
      try{ bgGain.gain.setTargetAtTime(droneVol, now, SMOOTH_TC); }
      catch{ bgGain.gain.cancelScheduledValues(now); bgGain.gain.linearRampToValueAtTime(droneVol, now+0.08); }
    }
  }
  function initOrientationListener(){
    if(typeof DeviceOrientationEvent==='undefined') return;
    window.addEventListener('deviceorientation',(e)=>{
      latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0;
    },{passive:true});
  }
  function controlLoop(){
    requestAnimationFrame(controlLoop);
    let pan=0, vol=VOL_BASE;
    if(sensorsReady){
      const {volTilt, panTilt}=mapOrientation(latestOri.beta, latestOri.gamma);
      vol=smoothStep(tiltToVol(volTilt), smVol);
      pan=smoothStep(tiltToPan(panTilt), smPan);
      smVol=vol; smPan=pan;
    }else{
      vol=smoothStep(VOL_BASE, smVol); pan=smoothStep(0, smPan);
      smVol=vol; smPan=pan;
    }
    applyPanVol(pan, vol);
  }
  function autoStart(){
    try{
      initAudio();
      if(audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
      if(!dronePermanentlyStopped) startDrone();
    }catch(e){ console.warn('autoStart err', e); }
  }
  autoStart();
  document.addEventListener('visibilitychange', autoStart);
  window.addEventListener('focus', autoStart);

  const overlay=document.getElementById('overlay');
  const overlayContent=document.getElementById('overlayContent');
  const goodnight=document.getElementById('goodnight');
  const captureBtn=document.getElementById('captureBtn');
  const cutin=document.getElementById('cutin');
  const cutinText=document.getElementById('cutinText');

  function crossfadeUpdate(html,nextAction){
    overlayContent.classList.add('hidden');
    setTimeout(()=>{ overlayContent.innerHTML=html; overlayContent.classList.remove('hidden'); nextAction&&nextAction(); },450);
    playFlip();
  }
  function showGoodNight(next){
    goodnight.textContent='GOOD NIGHT, HAVE A NICE DREAM';
    goodnight.classList.add('show');
    fadeOutDronePermanently();
    setTimeout(()=>{
      goodnight.classList.add('fadeout');
      setTimeout(()=>{
        goodnight.classList.remove('show','fadeout');
        goodnight.style.display='none';
        next && next();
      },600);
    },15000);
  }
  function showCutIn(text, holdMs=3000, after, transparent=false){
    cutinText.textContent=text;
    cutin.style.background = transparent ? 'transparent' : '#000';
    cutinText.style.textShadow = transparent ? '0 0 8px rgba(0,0,0,.6)' : 'none';
    cutin.classList.remove('fadeout');
    cutin.classList.add('show');
    playFlip();
    setTimeout(()=>{
      cutin.classList.add('fadeout');
      setTimeout(()=>{
        cutin.classList.remove('show','fadeout');
        cutin.style.display='none';
        after && after();
      }, 3000);
    }, holdMs);
  }
  const narrative = [
    '자욱한 안개가 너를 맞이했다. 거대한 비석을 너는 마주했다. 거대한 비석들의 웅얼거림을 너는 들을 수 있었다.',
    '어디선가 잔잔한 종소리가 들려온다. 어디선가 께름칙한 울음소리가 들려온다. 어디선가 아이들의 웃음소리가 들려온다.',
    '너는 비석 사이를 거닐고 있다. 너를 스쳐 지나가며 웅얼거리는 소리에 귀를 기울인다.',
    '비석마다 다른 목소리가 담겨 있다. 어떤 것은 꿈을 이야기하고, 어떤 것은 기억을 읊고, 또 어떤 것은 아직 말하지 못한 언어로 중얼거린다.',
    '너는 발걸음을 늦춘다. 너는 생각한다. 이곳엔 분명 누군가가 존재하고 있었다.',
    '그리고, 지금도 여전히 그들의 호흡은 돌 틈에 스며 있고, 그들의 그림자는 안개 속에 머물며, 그들의 말하지 못한 시간은 너의 귀끝을 잡아당긴다.',
    '너는 발걸음을 멈춘다. 왜인지 이곳에 머물러야 한다는 느낌을 받는다.',
    '너는 그곳으로 발을 옮긴다. 그곳엔, 이곳에 존재했던 누군가의 ‘목소리’가 있다.',
    '너는 비석에 등을 기대고 앉는다. 그리고 서서히, 그것의 진동을 느낀다.'
  ];
  function showNarrativeSequence(done){
    overlay.style.display='flex';
    overlay.classList.remove('hidden');
    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    let idx = 0;
    function next(){
      if(idx >= narrative.length){
        overlay.classList.add('hidden');
        setTimeout(()=>{ overlay.style.display='none'; done && done(); }, 600);
        return;
      }
      overlayContent.classList.add('hidden');
      setTimeout(()=>{
        overlayContent.innerHTML = line(narrative[idx++]);
        overlayContent.classList.remove('hidden');
        playFlip();
        setTimeout(next, 5000);
      }, 450);
    }
    next();
  }
  function firstSilenceFlow(){
    showCutIn('FIRST SILENCE', 3000, ()=>{
      showNarrativeSequence(()=>{
        setTimeout(()=>{
          showCutIn('SECOND SILENCE', 3000, ()=>{}, false);
        }, 1000);
      });
    }, true);
  }
  function mountPressToSleep(){
    const html = `<button id="startBtn" class="uiBtn">PRESS HERE TO SLEEP</button>
                  <div class="tip" id="sensorTip2" style="display:none">센서 권한 필요: 시작을 누르면 허용 팝업이 뜹니다.</div>`;
    crossfadeUpdate(html, ()=>{
      const startBtn=document.getElementById('startBtn');
      startBtn.addEventListener('click', ()=>{ playClick(); onStartPressed(); });
    });
  }
  async function onStartPressed(){
    autoStart();
    try{ startMic().catch(()=>{}); }catch{}
    initOrientationListener();
    const ok=await requestMotionPermissions();
    const tipEl=document.getElementById('sensorTip2')||document.getElementById('sensorTip');
    if(tipEl) tipEl.style.display = ok? 'none':'block';

    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    const introHTML = `
      ${line('<span class="introTitle">INTRODUCTION</span>')}
      ${line('이곳은 이미 ‘너’가 죽어버린, ‘그것’들의 세계다.')}
      ${line('곧 당신은 30분간의 잠에 들며, 무의식 속 여정을 시작한다.')}
      ${line('그 여정 속에서 당신은 사라져간 ‘너’를 마주하게 된다.')}
      ${line('이제 당신에게는 네 단계의 미션이 주어진다.')}
      ${line('당신은 미션에 따라 헤드폰으로 들려오는 ‘너’들의 목소리에 귀 기울이며, 휴대폰을 통해 잃어버린 ‘너’를 포착할 수 있다.')}
      <div id="countdown" class="lineWrap">
        <span class="line">THE DOOR WILL CLOSE IN <span id="countNum">60</span> SECONDS.</span>
      </div>
      <div class="tip" ${ok?'style="display:none"':''}>패닝이 안 들리면, 센서 권한을 허용해 주세요.</div>
    `;
    crossfadeUpdate(introHTML, ()=>{
      let count=60; const numEl=document.getElementById('countNum');
      const timer=setInterval(()=>{
        count--;
        if(count>=0){ numEl.textContent=count; }
        if(count<=0){
          clearInterval(timer);
          overlay.classList.add('hidden');
          setTimeout(()=>{
            overlay.style.display='none';
            showGoodNight(firstSilenceFlow);
          },450);
        }
      },1000);
    });
    controlLoop();
  }
  document.getElementById('welcomeBtn').addEventListener('click', ()=>{ playClick(); mountPressToSleep(); });
  document.getElementById('captureBtn').addEventListener('click',()=>{
    playClick();
    try{ const a=document.createElement('a'); a.download=`capture_${Date.now()}.png`; a.href=view.toDataURL('image/png'); a.click(); }
    catch(e){ console.warn('CAPTURE 실패', e); }
  });

  /* ==========================
     PIXEL MAZE GAME (12 stages)
     ========================== */
  const gameOverlay = document.getElementById('gameOverlay');
  const gameCanvas = document.getElementById('gameCanvas');
  const g = gameCanvas.getContext('2d');
  const mapLauncher = document.getElementById('mapLauncher');
  const btnExit = document.getElementById('btnExit');
  const btnMap = document.getElementById('btnMap');
  const mapGrid = document.getElementById('mapGrid');
  const hudStage = document.getElementById('hudStage');
  const hudDeaths = document.getElementById('hudDeaths');
  const hudTime = document.getElementById('hudTime');

  const TILE=16; // 타일 크기(픽셀톤)
  const VIEW_W = gameCanvas.width;
  const VIEW_H = gameCanvas.height;

  // 12개 스테이지(간단한 패턴 + 난이도 상승). 0:벽 1:길 S:시작 E:출구
  // 각 행은 문자열로 정의해서 시각적으로 편집하기 쉽게 함.
  const STAGES = [
`00000000000000000000
0S111000000111111110
01000101111000000110
01110101100011110110
01000101101010000110
01110101101011110110
01000100001010000110
01110111111011110110
01000000000010000110
01111111111111110E10
00000000000000000000`,
`00000000000000000000
0S111111111111111110
01000000000000000010
01111111111111111010
01000000000000001010
01111111111111001010
01000000000001001010
01111111111101001010
01000000000101001010
01111111110101111010
010000000001000000E0
00000000000000000000`,
`00000000000000000000
0S100000000000000010
01111111111111111010
01000000000000001010
01111111111111101010
01000000000000101010
01111111111110101010
01000000000010101010
01111111111010101010
010000000010101010E0
00000000000000000000`,
`00000000000000000000
0S111111111111111110
01000000000000000010
01111111101111111010
01000000101000001010
01111110101011101010
01000010101000101010
01111010101110101010
01001000100000101010
011011111111101011E0
00000000000000000000`,
`00000000000000000000
0S111111101111111110
01000000101000000010
01111110101011111110
01000010101010000010
01111010101010111010
01001010101010101010
01101010101010101010
01001010100010101010
011010101111101010E0
00000000000000000000`,
`00000000000000000000
0S111111111000111110
01000000001001000010
01111111101001011110
01000000101001010010
01111110101001010110
01000010101001010100
01111010101001010110
01001010101001010100
011010101011110101E0
00000000000000000000`,
`00000000000000000000
0S100000000000000010
01110111111111111010
01010100000000001010
01010101111111101010
01010101000000101010
01010101111110101010
01010100000110101010
01011111110110101010
010000000001101010E0
00000000000000000000`,
`00000000000000000000
0S111111111111111110
01000000000000000010
01111111111111111010
01000000000000001010
01111111111111101010
01000000000000101010
01111111111110101010
01000000000010101010
011111111110101010E0
00000000000000000000`,
`00000000000000000000
0S111111111111111110
01000000000000000010
01111110111111111010
01000010100000001010
01111010101111101010
01001010101000101010
01101010101110101010
01001000100000101010
011011111111101011E0
00000000000000000000`,
`00000000000000000000
0S111111101111111110
01000000101000000010
01111110101011111110
01000010101010000010
01111010101010111010
01001010101010101010
01101010101010101010
01001010100010101010
011010101111101010E0
00000000000000000000`,
`00000000000000000000
0S111111111000111110
01000000001001000010
01111111101001011110
01000000101001010010
01111110101001010110
01000010101001010100
01111010101001010110
01001010101001010100
011010101011110101E0
00000000000000000000`,
`00000000000000000000
0S100000000000000010
01111111111111111010
01000000000000001010
01111111111111101010
01000000000000101010
01111111111110101010
01000000000010101010
01111111111010101010
010000000010101010E0
00000000000000000000`
  ].map(str=>str.trim().split('\n'));

  // 진행 상태
  let currentStage=1; // 1~12
  let deaths=0;
  let startTime=0;
  let running=false;
  const doneSet = new Set(); // 클리어 스테이지 모음

  // 맵 빌드: 문자열→타일 배열
  function parseStage(stageIdx){
    const rows = STAGES[stageIdx-1];
    const H=rows.length, W=rows[0].length;
    const grid = [];
    let start = {x:1,y:1}, exit={x:W-2,y:H-2};
    for(let y=0;y<H;y++){
      const row = [];
      for(let x=0;x<W;x++){
        const ch = rows[y][x];
        if(ch==='S'){ start={x,y}; row.push(1); }
        else if(ch==='E'){ exit={x,y}; row.push(1); }
        else row.push(ch==='1'?1:0);
      }
      grid.push(row);
    }
    return {grid,W,H,start,exit};
  }

  // 플레이어
  const player = { x:0, y:0, px:0, py:0, speed:4, color:'#0ff' };

  // 입력
  const input = { up:false, down:false, left:false, right:false };
  function setKey(code, val){
    if(code==='ArrowUp' || code==='KeyW') input.up=val;
    if(code==='ArrowDown' || code==='KeyS') input.down=val;
    if(code==='ArrowLeft' || code==='KeyA') input.left=val;
    if(code==='ArrowRight' || code==='KeyD') input.right=val;
  }
  addEventListener('keydown',e=>{ setKey(e.code,true); });
  addEventListener('keyup',e=>{ setKey(e.code,false); });

  // 모바일 D-Pad
  document.querySelectorAll('.dkey').forEach(btn=>{
    const dx=parseInt(btn.dataset.dx||'0',10);
    const dy=parseInt(btn.dataset.dy||'0',10);
    const press=(on)=>{
      if(dx===-1) input.left=on;
      if(dx===1) input.right=on;
      if(dy===-1) input.up=on;
      if(dy===1) input.down=on;
    };
    btn.addEventListener('touchstart',e=>{ e.preventDefault(); press(true); },{passive:false});
    btn.addEventListener('touchend',e=>{ e.preventDefault(); press(false); },{passive:false});
    btn.addEventListener('mousedown',()=>press(true));
    btn.addEventListener('mouseup',()=>press(false));
    btn.addEventListener('mouseleave',()=>press(false));
  });

  // 그리기
  function drawStage(grid,W,H,exitPos){
    g.clearRect(0,0,VIEW_W,VIEW_H);
    // 스케일 맞추기 (캔버스 크기에 타일 맞춤)
    const sx = Math.floor(VIEW_W / W);
    const sy = Math.floor(VIEW_H / H);
    const t = Math.max(6, Math.min(sx, sy));
    const offX = Math.floor((VIEW_W - W*t)/2);
    const offY = Math.floor((VIEW_H - H*t)/2);

    // 배경/벽/바닥
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const v=grid[y][x];
        if(v===0){ g.fillStyle='#111'; } else { g.fillStyle='#000'; }
        g.fillRect(offX+x*t, offY+y*t, t, t);
      }
    }
    // 출구
    g.fillStyle='#f33';
    g.fillRect(offX+exitPos.x*t, offY+exitPos.y*t, t, t);

    // 플레이어
    g.fillStyle=player.color;
    g.fillRect(offX+player.x*t, offY+player.y*t, t, t);

    return {t,offX,offY};
  }

  // 충돌 및 이동
  function canMove(grid,x,y){
    if(y<0||y>=grid.length||x<0||x>=grid[0].length) return false;
    return grid[y][x]===1;
  }

  function stepGame(state){
    const {grid,W,H,exit} = state;
    let nx = player.x;
    let ny = player.y;
    if(input.up) ny -= 1;
    else if(input.down) ny += 1;
    if(input.left) nx -= 1;
    else if(input.right) nx += 1;

    if(nx!==player.x || ny!==player.y){
      if(canMove(grid,nx,ny)){
        player.x = nx; player.y = ny; playClick();
      }else{
        // 벽 충돌 (사운드만)
        playFlip();
      }
    }

    const drawInfo = drawStage(grid,W,H,exit);
    // 클리어 체크
    if(player.x===exit.x && player.y===exit.y){
      doneSet.add(currentStage);
      playFlip();
      nextStage();
    }
    return drawInfo;
  }

  // 스테이지 로드
  function loadStage(idx){
    const s = parseStage(idx);
    player.x = s.start.x; player.y = s.start.y;
    hudStage.textContent = idx;
    startTime = performance.now();
    running = true;
    return s;
  }

  // 다음 스테이지
  function nextStage(){
    currentStage = Math.min(12, currentStage+1);
    if(currentStage>12){
      // 올클리어
      running=false;
      btnMap.click();
      return;
    }
    stageState = loadStage(currentStage);
    updateMapGrid();
  }

  // 사망 처리 (여기선 낭떠러지 없으니 옵션으로 남김)
  function kill(){
    deaths++; hudDeaths.textContent = deaths;
    stageState = loadStage(currentStage);
  }

  // 메인 루프
  let stageState = parseStage(currentStage);
  function gameLoop(){
    requestAnimationFrame(gameLoop);
    if(!gameOverlay.style.display || gameOverlay.style.display==='none') return;
    if(!running) return;
    stepGame(stageState);
    const t = Math.max(0, performance.now()-startTime);
    hudTime.textContent = (t/1000).toFixed(1);
  }
  gameLoop();

  // MAP/EXIT UI
  function updateMapGrid(){
    mapGrid.innerHTML='';
    for(let i=1;i<=12;i++){
      const b=document.createElement('button');
      b.className='stageBtn'+(doneSet.has(i)?' done':'')+(i===currentStage?' active':'');
      b.textContent = String(i).padStart(2,'0')+(doneSet.has(i)?' ●':'');
      b.onclick=()=>{
        playClick();
        currentStage=i;
        stageState=loadStage(currentStage);
        updateMapGrid();
      };
      mapGrid.appendChild(b);
    }
  }

  function openGame(startAtCurrent=true){
    playFlip();
    gameOverlay.style.display='block';
    if(startAtCurrent){
      stageState = loadStage(currentStage);
    }
    updateMapGrid();
  }
  function closeGame(){
    playFlip();
    gameOverlay.style.display='none';
  }

  mapLauncher.addEventListener('click', ()=> openGame(false));
  btnMap.addEventListener('click', ()=> { playClick(); updateMapGrid(); });
  btnExit.addEventListener('click', ()=> { playClick(); closeGame(); });

})();
</script>
</body>
</html>