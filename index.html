<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Dialogue into Silence — Camera+Audio+Pixel Maze+Docs</title>

<!-- iOS A2HS 타이틀 (홈 화면 제목) -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Dialogue into Silence">

<!-- (안드로이드/데스크톱 PWA) 매니페스트 - short_name/name는 아래 예시 참고 -->
<link rel="manifest" href="/manifest.webmanifest">

<style>
  :root{
    --frame: 40px; --ui-gap: 8px;
    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --pad-line: clamp(4px, 0.9vmin, 8px);
    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:manipulation}
  #view{width:100%;height:100%;display:block;position:fixed;left:0;top:0;z-index:0}

  .frameBox{position:fixed;left:var(--frame);top:var(--frame);right:var(--frame);bottom:var(--frame);border:1px solid #000;pointer-events:none;z-index:50}

  .uiBtn{background:#000;color:#fff;border:1px solid #000;font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}

  .controls{position:fixed;right:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small)}
  .btn-capture{position:fixed;left:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:150}

  /* 상단 런처들 */
  #mapLauncher{
    position:fixed; right:calc(var(--frame) + var(--ui-gap)); top:calc(var(--frame) + var(--ui-gap));
    z-index:280;
  }
  #docLauncher{
    position:fixed; left:calc(var(--frame) + var(--ui-gap)); top:calc(var(--frame) + var(--ui-gap));
    z-index:280;
  }

  /* 메인 오버레이 (퍼미션/인트로/내러티브 재사용) */
  #overlay{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;padding:20px;
    font-family:"Courier New",monospace;color:#fff;background:rgba(0,0,0,.72)}
  #overlayContent{pointer-events:auto;line-height:1.7;font-size:var(--fs-body);
    max-width:min(72ch, calc(100vw - (var(--frame)*2)));
    max-height:calc(100vh - (var(--frame)*2));
    overflow:hidden; text-align:left}
  .line{display:inline;background:#000;color:#fff;padding:calc(var(--pad-line)*0.8) var(--pad-line);box-decoration-break:clone;-webkit-box-decoration-break:clone}
  .lineWrap{margin:6px 0}
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}
  #goodnight{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:250;display:none;text-align:center;font-family:"Courier New",monospace;font-size:var(--fs-strong);color:#fff;background:#000;padding:var(--pad-btn-y) var(--pad-btn-x);white-space:nowrap;transition:opacity .6s ease}
  #goodnight.show{display:block;opacity:1}
  #goodnight.fadeout{opacity:0}
  @media (orientation:landscape){ :root{ --frame: 32px; } }
  .tip{opacity:.7;font-size:var(--fs-small);margin-top:8px;text-align:center}

  /* 컷인(침묵) */
  #cutin{
    position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center;
    background:#000; color:#fff; font-family:"Courier New",monospace; text-align:center;
  }
  #cutin.show{display:flex; opacity:1; transition:opacity .45s ease}
  #cutin.fadeout{opacity:0}
  #cutinText{font-size:clamp(24px, 8vmin, 64px); letter-spacing:.02em; line-height:1.2; padding:0 .2em}
  .introTitle{font-weight:400; letter-spacing:.02em}

  /* ====== PIXEL MAZE GAME OVERLAY ====== */
  #gameOverlay{
    position:fixed; inset:0; z-index:300; display:none; background:rgba(0,0,0,.8);
    font-family:"Courier New",monospace; color:#fff;
  }
  #gameUI{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    display:flex; flex-direction:column; align-items:center; gap:10px;
    width:min(96vw, 860px);
  }
  #gameHeader{ width:100%; display:flex; justify-content:space-between; align-items:center; gap:8px; }
  #gameCanvas{ width:100%; height:60vh; background:#000; image-rendering: pixelated; border:1px solid #444 }
  #gameBtns{ display:flex; gap:6px; align-items:center }
  #mapGrid{ display:grid; grid-template-columns:repeat(6,minmax(0,1fr)); gap:6px; width:100%; }
  .stageBtn{ border:1px solid #444; background:#000; color:#fff; padding:8px 0; text-align:center; cursor:pointer; font-size:var(--fs-small) }
  .stageBtn.done{ border-color:#0f0; color:#0f0 }
  .stageBtn.active{ border-color:#fff }
  #hud{ display:flex; gap:12px; align-items:center; opacity:.85; font-size:var(--fs-small) }

  /* 모바일 가상 방향키 */
  #dpad{ position:absolute; left:var(--frame); bottom:calc(var(--frame) + 64px); z-index:320;
    display:grid; grid-template-columns:repeat(3,48px); grid-template-rows:repeat(3,48px); gap:6px; }
  .dkey{ width:48px; height:48px; border:1px solid #444; display:flex; align-items:center; justify-content:center; color:#fff; background:#000; opacity:.7; user-select:none; }
  .dkey:active{ opacity:1 }

  /* ====== DOCUMENT OVERLAY ====== */
  #docOverlay{
    position:fixed; inset:0; z-index:310; display:none; background:rgba(0,0,0,.8);
    font-family:"Courier New",monospace; color:#fff;
  }
  #docUI{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(96vw,860px); display:flex; flex-direction:column; gap:10px; }
  #docHeader{ display:flex; justify-content:space-between; align-items:center; }
  #docGrid{ display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; }
  .docBtn{ border:1px solid #444; background:#000; color:#fff; padding:12px; text-align:center; cursor:pointer; font-size:var(--fs-small) }
  .docPane{ border:1px solid #444; padding:12px; max-height:50vh; overflow:auto; background:#000; }
  .docTitle{ font-size:var(--fs-strong); margin-bottom:8px; }

  /* ★ Document 가독성: 줄잘림 최소화 */
  #docPane, #docBody, .docBtn{
    white-space:pre-wrap;
    word-break:keep-all;        /* 한글 단어 중간 분리 방지 */
    overflow-wrap:anywhere;     /* 너무 길면 자연 분리 */
    hyphens:none;
  }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <!-- 기본 컨트롤 -->
  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.2×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <!-- 상단 런처 -->
  <button id="docLauncher" class="uiBtn small">DOCUMENT</button>
  <button id="mapLauncher" class="uiBtn small">MAP</button>

  <!-- 메인 오버레이 (퍼미션/인트로/내러티브 공용) -->
  <div id="overlay" class="fade">
    <div id="overlayContent" class="fade" style="text-align:left">
      <!-- 최초: 퍼미션 게이트 -->
      <button id="permGateBtn" class="uiBtn" style="width:min(80vw,420px)">화면을 탭하여 카메라·동작(센서)·오디오를 허용해주세요</button>
      <div class="tip" style="text-align:center">권한 허용 후 WELCOME 화면이 나타납니다.</div>
    </div>
  </div>

  <div id="goodnight">GOOD NIGHT, HAVE A NICE DREAM</div>
  <div id="cutin"><div id="cutinText">FIRST SILENCE</div></div>

  <!-- ====== GAME OVERLAY ====== -->
  <div id="gameOverlay">
    <div id="gameUI">
      <div id="gameHeader">
        <div id="hud">
          <span>STAGE: <span id="hudStage">1</span>/12</span>
          <span>DEATHS: <span id="hudDeaths">0</span></span>
          <span>TIME: <span id="hudTime">0.0</span>s</span>
        </div>
        <div id="gameBtns">
          <button id="btnMap" class="uiBtn small">MAP</button>
          <button id="btnExitGame" class="uiBtn small">EXIT</button>
        </div>
      </div>
      <canvas id="gameCanvas" width="480" height="320"></canvas>
      <div id="mapGrid"></div>
    </div>
    <!-- 모바일 DPAD -->
    <div id="dpad">
      <div></div><div class="dkey" data-dy="-1">↑</div><div></div>
      <div class="dkey" data-dx="-1">←</div><div class="dkey" data-dy="1">↓</div><div class="dkey" data-dx="1">→</div>
      <div></div><div></div><div></div>
    </div>
  </div>

  <!-- ====== DOCUMENT OVERLAY ====== -->
  <div id="docOverlay">
    <div id="docUI">
      <div id="docHeader">
        <div class="readout">DOCUMENTS</div>
        <div>
          <button id="btnExitDoc" class="uiBtn small">EXIT</button>
        </div>
      </div>
      <div id="docGrid"></div>
      <div id="docPane" class="docPane" style="display:none">
        <div class="docTitle" id="docTitle">Document</div>
        <div id="docBody">준비중입니다.</div>
      </div>
    </div>
  </div>

<script>
(async ()=>{
  /* ========= 공통 유틸 & 사운드 ========= */
  const qs = (s)=>document.querySelector(s);
  const qsa = (s)=>Array.from(document.querySelectorAll(s));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const WANT_MIC = /[?&]mic=1\b/.test(location.search); // 기본: 마이크 꺼둠(블루투스 A2DP 유지)

  let audioCtx=null;
  function initAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const mixBus = audioCtx.createGain(); window.__mixBus__ = mixBus;
    const sfxBus = audioCtx.createGain(); sfxBus.gain.value = 0.6; sfxBus.connect(mixBus); window.__sfxBus__=sfxBus;
    const dest = audioCtx.destination;
    try{
      if (dest.maxChannelCount && dest.maxChannelCount >= 2) dest.channelCount = 2;
      if (dest.channelCountMode) dest.channelCountMode = 'explicit';
      if (dest.channelInterpretation) dest.channelInterpretation = 'discrete';
    }catch{}
    const master = audioCtx.createGain(); master.gain.value=1.0;
    mixBus.connect(master).connect(dest);
  }
  function resumeAudio(){ try{ initAudio(); if(audioCtx.state==='suspended') audioCtx.resume(); }catch{} }
  function playClick(){
    try{
      resumeAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type='square'; osc.frequency.setValueAtTime(880, t);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.45, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      osc.connect(g).connect(window.__sfxBus__); osc.start(t); osc.stop(t+0.14);
    }catch{}
  }
  function playFlip(){
    try{
      resumeAudio();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type='triangle'; o.frequency.setValueAtTime(220, t);
      o.frequency.exponentialRampToValueAtTime(900, t+0.25);
      f.type='bandpass'; f.frequency.setValueAtTime(800, t); f.Q.value=1.2;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.6, t+0.04);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
      o.connect(f).connect(g).connect(window.__sfxBus__); o.start(t); o.stop(t+0.38);
    }catch{}
  }

  /* ========= 카메라(흑백+잔상) ========= */
  const view=qs('#view'); const vctx=view.getContext('2d',{alpha:false});
  const PROC_SCALE=0.60, TRAIL_ALPHA=0.12, GLOBAL_ALPHA=0.7;
  let ZOOM=1.2, ZOOM_MIN=0.5, ZOOM_MAX=3.0, ZOOM_STEP=0.1;

  const zoomVal=qs('#zoomVal');
  function updateZoom(){ zoomVal.textContent=ZOOM.toFixed(1)+'×'; }
  qs('#zoomIn').onclick=()=>{ZOOM=clamp(ZOOM+ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  qs('#zoomOut').onclick=()=>{ZOOM=clamp(ZOOM-ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  updateZoom();

  const camVideo=document.createElement('video'); camVideo.autoplay=true; camVideo.playsInline=true; camVideo.muted=true;
  const proc=document.createElement('canvas'); const pctx=proc.getContext('2d',{willReadFrequently:true});
  let camStream=null;

  async function attachCamera(){
    try{
      if(camStream) return;
      camStream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
      camVideo.srcObject=camStream; await camVideo.play().catch(()=>{});
    }catch(e){ console.warn("카메라 실패:", e); }
  }
  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth,h=window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale=(window.matchMedia('(orientation: landscape)').matches)? PROC_SCALE*0.9 : PROC_SCALE;
    proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale);
  }
  resizeAll(); addEventListener('resize',()=>setTimeout(resizeAll,50),{passive:true});

  function loop(){
    requestAnimationFrame(loop);
    const W=view.width/(window.devicePixelRatio||1);
    const H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;
    pctx.globalCompositeOperation="source-over";
    pctx.fillStyle=`rgba(0,0,0,${TRAIL_ALPHA})`; pctx.fillRect(0,0,PW,PH);
    if(camVideo.readyState>=2){
      const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
      if(vw && vh){
        const base=Math.max(PW/vw,PH/vh), sc=base*ZOOM;
        const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
        pctx.globalAlpha=GLOBAL_ALPHA; pctx.drawImage(camVideo,dx,dy,dw,dh);
        pctx.globalAlpha=1.0;
        const frame=pctx.getImageData(0,0,PW,PH); const d=frame.data;
        for(let i=0;i<d.length;i+=4){
          const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;
        }
        pctx.putImageData(frame,0,0);
      }
    }
    vctx.drawImage(proc,0,0,W,H);
  }
  loop();

  /* ========= 마이크/센서 ========= */
  let micStream=null, sensorsReady=false;
  const WANT_MIC = /[?&]mic=1\b/.test(location.search);

  // 기본값: 마이크 요청 안 함(블루투스 스테레오 유지). 필요 시 ?mic=1 로 켜기.
  async function startMic(){
    if(!WANT_MIC) return; // 쿼리 없으면 스킵
    try{
      if(micStream) return;
      micStream=await navigator.mediaDevices.getUserMedia({
        audio:{ echoCancellation:false, noiseSuppression:true, autoGainControl:false },
        video:false
      });
      // 스트림은 변조 파이프라인에 연결하려면 여기서 WebAudio로 라우팅 가능
    }catch(e){ console.warn('Mic denied', e); }
  }

  // iOS 등: 센서 퍼미션을 맨 먼저 요청
  async function requestMotionPermissions(){
    try{
      if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
        const r=await DeviceOrientationEvent.requestPermission(); if(r==='granted') sensorsReady=true;
      }else sensorsReady=true;
    }catch(e){}
    try{
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        const r=await DeviceMotionEvent.requestPermission(); if(r==='granted') sensorsReady=true;
      }
    }catch(e){}
  }

  /* ========= 퍼미션 게이트 → WELCOME → 시퀀스 ========= */
  const overlay=qs('#overlay'); const overlayContent=qs('#overlayContent');
  const goodnight=qs('#goodnight'); const cutin=qs('#cutin'); const cutinText=qs('#cutinText');
  const permGateBtn=qs('#permGateBtn');

  let gateBusy=false;
  function show(html, next){
    overlay.style.display='flex';
    overlay.classList.remove('hidden');
    overlayContent.classList.add('hidden');
    setTimeout(()=>{ overlayContent.innerHTML=html; overlayContent.classList.remove('hidden'); next&&next(); }, 150);
  }
  function hide(next){
    overlay.classList.add('hidden');
    setTimeout(()=>{ overlay.style.display='none'; next&&next(); }, 450);
  }

  async function runPermissionGate(){
    if(gateBusy) return; gateBusy=true;
    playClick();
    try{
      resumeAudio();
      // 순서: 센서 → 카메라 → (옵션)마이크
      await requestMotionPermissions(); // 먼저
      await attachCamera();             // 다음
      await startMic();                 // 마지막(기본적으로 스킵됨)
    }catch(e){}
    // 게이트 성공 후 WELCOME 단계로
    show(`
      <div style="text-align:center">
        <button id="welcomeBtn" class="uiBtn" style="min-width:260px">WELCOME TO ‘DIALOGUE INTO SILENCE’</button>
        <div class="tip">이제 WELCOME을 눌러 시작하세요.</div>
      </div>
    `, ()=>{
      const welcomeBtn=qs('#welcomeBtn');
      welcomeBtn.addEventListener('click',()=>{ playClick(); mountPressToSleep(); }, {passive:true});
      gateBusy=false;
    });
  }
  permGateBtn.addEventListener('click', runPermissionGate, {passive:true});
  overlay.addEventListener('click', (e)=>{ if(e.target===overlay) runPermissionGate(); }, {passive:true});

  function showGoodNight(next){
    goodnight.textContent='GOOD NIGHT, HAVE A NICE DREAM';
    goodnight.classList.add('show');
    setTimeout(()=>{
      goodnight.classList.add('fadeout');
      setTimeout(()=>{
        goodnight.classList.remove('show','fadeout');
        goodnight.style.display='none';
        next && next();
      },600);
    },15000);
  }
  function showCutIn(text, holdMs=3000, after, transparent=false){
    cutinText.textContent=text;
    cutin.style.background = transparent ? 'transparent' : '#000';
    cutinText.style.textShadow = transparent ? '0 0 8px rgba(0,0,0,.6)' : 'none';
    cutin.classList.remove('fadeout'); cutin.classList.add('show'); playFlip();
    setTimeout(()=>{
      cutin.classList.add('fadeout');
      setTimeout(()=>{ cutin.classList.remove('show','fadeout'); cutin.style.display='none'; after&&after(); }, 3000);
    }, holdMs);
  }
  const narrative = [
    '자욱한 안개가 너를 맞이했다. 거대한 비석을 너는 마주했다. 거대한 비석들의 웅얼거림을 너는 들을 수 있었다.',
    '어디선가 잔잔한 종소리가 들려온다. 어디선가 께름칙한 울음소리가 들려온다. 어디선가 아이들의 웃음소리가 들려온다.',
    '너는 비석 사이를 거닐고 있다. 너를 스쳐 지나가며 웅얼거리는 소리에 귀를 기울인다.',
    '비석마다 다른 목소리가 담겨 있다. 어떤 것은 꿈을 이야기하고, 어떤 것은 기억을 읊고, 또 어떤 것은 아직 말하지 못한 언어로 중얼거린다.',
    '너는 발걸음을 늦춘다. 너는 생각한다. 이곳엔 분명 누군가가 존재하고 있었다.',
    '그리고, 지금도 여전히 그들의 호흡은 돌 틈에 스며 있고, 그들의 그림자는 안개 속에 머물며, 그들의 말하지 못한 시간은 너의 귀끝을 잡아당긴다.',
    '너는 발걸음을 멈춘다. 왜인지 이곳에 머물러야 한다는 느낌을 받는다.',
    '너는 그곳으로 발을 옮긴다. 그곳엔, 이곳에 존재했던 누군가의 ‘목소리’가 있다.',
    '너는 비석에 등을 기대고 앉는다. 그리고 서서히, 그것의 진동을 느낀다.'
  ];
  function showNarrativeSequence(done){
    overlay.style.display='flex'; overlay.classList.remove('hidden');
    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    let idx = 0;
    (function next(){
      if(idx >= narrative.length){ hide(done); return; }
      overlayContent.classList.add('hidden');
      setTimeout(()=>{
        overlayContent.innerHTML = line(narrative[idx++]);
        overlayContent.classList.remove('hidden');
        playFlip();
        setTimeout(next, 5000);
      }, 150);
    })();
  }

  // INTRODUCTION: 블랙 박스 유지 + 좌측정렬 문단
  function mountPressToSleep(){
    show(`
      <div style="text-align:center">
        <button id="startBtn" class="uiBtn" style="min-width:240px">PRESS HERE TO SLEEP</button>
      </div>
    `, ()=>{
      const startBtn=qs('#startBtn');
      startBtn.addEventListener('click', ()=>{
        playClick();
        const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
        const introHTML = `
          ${line('<span class="introTitle">INTRODUCTION</span>')}
          ${line('이곳은 이미 ‘너’가 죽어버린, ‘그것’들의 세계다.')}
          ${line('곧 당신은 30분간의 잠에 들며, 무의식 속 여정을 시작한다.')}
          ${line('그 여정 속에서 당신은 사라져간 ‘너’를 마주하게 된다.')}
          ${line('이제 당신에게는 네 단계의 미션이 주어진다.')}
          ${line('당신은 미션에 따라 헤드폰으로 들려오는 ‘너’들의 목소리에 귀 기울이며, 휴대폰을 통해 잃어버린 ‘너’를 포착할 수 있다.')}
          <div id="countdown" class="lineWrap">
            <span class="line">THE DOOR WILL CLOSE IN <span id="countNum">60</span> SECONDS.</span>
          </div>
        `;
        show(introHTML, ()=>{
          let count=60; const numEl=qs('#countNum');
          const timer=setInterval(()=>{
            count--; if(count>=0 && numEl) numEl.textContent=count;
            if(count<=0){ clearInterval(timer); hide(()=>{ showGoodNight(()=>{ showNarrativeSequence(()=>{ setTimeout(()=>{ showCutIn('SECOND SILENCE', 3000, ()=>{}, false); }, 1000); }); }); }); }
          },1000);
        });
      }, {passive:true});
    });
  }

  // 캡처
  qs('#captureBtn').addEventListener('click',()=>{
    playClick();
    try{ const a=document.createElement('a'); a.download=`capture_${Date.now()}.png`; a.href=view.toDataURL('image/png'); a.click(); }
    catch(e){ console.warn('CAPTURE 실패', e); }
  }, {passive:true});

  /* ====== 이하: 게임/문서 로직 (생략 없이 유지) ====== */
  const gameOverlay = qs('#gameOverlay');
  const gameCanvas = qs('#gameCanvas');
  const g = gameCanvas.getContext('2d');
  const mapLauncher = qs('#mapLauncher');
  const btnExitGame = qs('#btnExitGame');
  const btnMap = qs('#btnMap');
  const mapGrid = qs('#mapGrid');
  const hudStage = qs('#hudStage');
  const hudDeaths = qs('#hudDeaths');
  const hudTime = qs('#hudTime');

  const VIEW_W = gameCanvas.width;
  const VIEW_H = gameCanvas.height;

  const RAW_STAGES = [/* ... (원본 스테이지 배열 그대로) ... */].map(str=>str.trim().split('\n'));

  function parseStage(rows){
    const H=rows.length, W=rows[0].length;
    const grid = [];
    let start = {x:1,y:1}, exit={x:W-2,y:H-2};
    for(let y=0;y<H;y++){
      const row = [];
      for(let x=0;x<W;x++){
        const ch = rows[y][x];
        if(ch==='S'){ start={x,y}; row.push(1); }
        else if(ch==='E'){ exit={x,y}; row.push(1); }
        else row.push(ch==='1'?1:0);
      }
      grid.push(row);
    }
    return {grid,W,H,start,exit};
  }
  function bfsReachable(grid, start, exit){
    const H=grid.length, W=grid[0].length;
    const q=[[start.x,start.y]]; const vis=new Set([start.x+','+start.y]);
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const [x,y]=q.shift();
      if(x===exit.x && y===exit.y) return true;
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||ny<0||nx>=W||ny>=H) continue;
        if(grid[ny][nx]!==1) continue;
        const k=nx+','+ny; if(vis.has(k)) continue;
        vis.add(k); q.push([nx,ny]);
      }
    }
    return false;
  }
  function ensureSolvable(stage){
    const {grid,W,H,start,exit}=stage;
    if(bfsReachable(grid,start,exit)) return stage;
    let x=start.x, y=start.y;
    grid[y][x]=1;
    while(x!==exit.x || y!==exit.y){
      if(x<exit.x) x++; else if(x>exit.x) x--;
      grid[y][x]=1;
      if(y<exit.y) y++; else if(y>exit.y) y--;
      grid[y][x]=1;
    }
    return {grid,W,H,start,exit};
  }

  let currentStage=1;
  let deaths=0;
  let startTime=0;
  let running=false;
  const doneSet = new Set();

  const player = { x:0, y:0, color:'#0ff' };
  const input = { up:false, down:false, left:false, right:false };
  addEventListener('keydown',e=>{ if(e.code==='ArrowUp'||e.code==='KeyW') input.up=true;
                                  if(e.code==='ArrowDown'||e.code==='KeyS') input.down=true;
                                  if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=true;
                                  if(e.code==='ArrowRight'||e.code==='KeyD') input.right=true; });
  addEventListener('keyup',e=>{ if(e.code==='ArrowUp'||e.code==='KeyW') input.up=false;
                                if(e.code==='ArrowDown'||e.code==='KeyS') input.down=false;
                                if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=false;
                                if(e.code==='ArrowRight'||e.code==='KeyD') input.right=false; });

  qsa('.dkey').forEach(btn=>{
    const dx=parseInt(btn.dataset.dx||'0',10);
    const dy=parseInt(btn.dataset.dy||'0',10);
    const press=(on)=>{
      if(dx===-1) input.left=on;
      if(dx===1) input.right=on;
      if(dy===-1) input.up=on;
      if(dy===1) input.down=on;
    };
    btn.addEventListener('touchstart',e=>{ e.preventDefault(); press(true); },{passive:false});
    btn.addEventListener('touchend',e=>{ e.preventDefault(); press(false); },{passive:false});
    btn.addEventListener('mousedown',()=>press(true));
    btn.addEventListener('mouseup',()=>press(false));
    btn.addEventListener('mouseleave',()=>press(false));
  });

  function canMove(grid,x,y){ return !(y<0||y>=grid.length||x<0||x>=grid[0].length) && grid[y][x]===1; }
  const gameCanvasCtx = gameCanvas.getContext('2d');
  function drawStage(grid,W,H,exitPos){
    const VIEW_W = gameCanvas.width, VIEW_H = gameCanvas.height, g=gameCanvasCtx;
    g.clearRect(0,0,VIEW_W,VIEW_H);
    const sx = Math.floor(VIEW_W / W);
    const sy = Math.floor(VIEW_H / H);
    const t = Math.max(6, Math.min(sx, sy));
    const offX = Math.floor((VIEW_W - W*t)/2);
    const offY = Math.floor((VIEW_H - H*t)/2);
    for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const v=grid[y][x]; g.fillStyle = v===0 ? '#111' : '#000'; g.fillRect(offX+x*t, offY+y*t, t, t); } }
    g.fillStyle='#f33'; g.fillRect(offX+exitPos.x*t, offY+exitPos.y*t, t, t);
    g.fillStyle=player.color; g.fillRect(offX+player.x*t, offY+player.y*t, t, t);
  }

  let stageState;
  function loadStage(idx){
    const parsed = parseStage(RAW_STAGES[idx-1]);
    stageState = ensureSolvable(parsed);
    player.x = stageState.start.x; player.y = stageState.start.y;
    hudStage.textContent = idx; startTime = performance.now(); running = true;
  }
  function nextStage(){
    currentStage++;
    if(currentStage>12){ running=false; btnMap.click(); return; }
    loadStage(currentStage); updateMapGrid();
  }
  function stepGame(){
    const {grid,W,H,exit} = stageState;
    let nx = player.x, ny = player.y;
    if(input.up) ny -= 1; else if(input.down) ny += 1;
    if(input.left) nx -= 1; else if(input.right) nx += 1;
    if(nx!==player.x || ny!==player.y){
      if(canMove(grid,nx,ny)){ player.x=nx; player.y=ny; }
    }
    drawStage(grid,W,H,exit);
    if(player.x===exit.x && player.y===exit.y){ doneSet.add(currentStage); nextStage(); }
    const t=(performance.now()-startTime)/1000; qs('#hudTime').textContent=t.toFixed(1);
  }

  function gameLoop(){ requestAnimationFrame(gameLoop); if(gameOverlay.style.display!=='none' && running) stepGame(); }
  loadStage(currentStage); gameLoop();

  function updateMapGrid(){
    mapGrid.innerHTML='';
    for(let i=1;i<=12;i++){
      const b=document.createElement('button');
      b.className='stageBtn'+(doneSet.has(i)?' done':'')+(i===currentStage?' active':'');
      b.textContent = String(i).padStart(2,'0')+(doneSet.has(i)?' ●':'');
      b.onclick=()=>{ currentStage=i; loadStage(currentStage); updateMapGrid(); };
      mapGrid.appendChild(b);
    }
  }
  function openGame(startAtCurrent=true){ gameOverlay.style.display='block'; if(startAtCurrent) loadStage(currentStage); updateMapGrid(); }
  function closeGame(){ gameOverlay.style.display='none'; }
  mapLauncher.addEventListener('click', ()=> openGame(false), {passive:true});
  qs('#btnMap').addEventListener('click', ()=> updateMapGrid(), {passive:true});
  qs('#btnExitGame').addEventListener('click', ()=> closeGame(), {passive:true});

  /* ====== DOCUMENT ====== */
  const docOverlay=qs('#docOverlay');
  const docGrid=qs('#docGrid');
  const docPane=qs('#docPane');
  const docTitle=qs('#docTitle');
  const docBody=qs('#docBody');
  const docLauncher=qs('#docLauncher');
  const btnExitDoc=qs('#btnExitDoc');

  function openDoc(){ docOverlay.style.display='block'; }
  function closeDoc(){ docOverlay.style.display='none'; }
  docLauncher.addEventListener('click', openDoc, {passive:true});
  btnExitDoc.addEventListener('click', closeDoc, {passive:true});

  function buildDocGrid(){
    docGrid.innerHTML='';
    for(let i=1;i<=8;i++){
      const b=document.createElement('button');
      b.className='docBtn';
      b.textContent = `Document ${i}`;
      b.onclick=()=>{
        docTitle.textContent = `Document ${i}`;
        docBody.innerHTML = '준비중입니다.';  // Document 2 포함, 전부 기본값
        docPane.style.display='block';
      };
      docGrid.appendChild(b);
    }
  }
  buildDocGrid();

  /* ========= 초기가이드(퍼미션 게이트 보이기) ========= */
  overlay.style.display='flex'; // 처음엔 게이트 화면
})();
</script>
</body>
</html>