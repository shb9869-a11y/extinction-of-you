<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Your Apocalypse – Unified Permissions + Continuous Haptics</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root{
    --frame: 40px; --ui-gap: 8px;
    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --pad-line: clamp(4px, 0.9vmin, 8px);
    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #view{width:100%;height:100%;display:block;position:fixed;left:0;top:0;z-index:0}
  .frameBox{position:fixed;left:var(--frame);top:var(--frame);right:var(--frame);bottom:var(--frame);border:1px solid #000;pointer-events:none;z-index:50}
  .uiBtn{background:#000;color:#fff;border:1px solid #000;font-size:var(--fs-strong);padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;border-radius:0;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
  .controls{position:fixed;right:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small)}
  .btn-capture{position:fixed;left:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:150}
  #overlay{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;padding:20px;font-family:"Courier New",monospace;color:#fff;pointer-events:none}
  #overlayContent{pointer-events:auto;line-height:1.7;font-size:var(--fs-body);max-width:min(72ch, calc(100vw - (var(--frame)*2)));max-height:calc(100vh - (var(--frame)*2));overflow:hidden;text-align:left}
  .line{display:inline;background:#000;color:#fff;padding:calc(var(--pad-line)*0.8) var(--pad-line);box-decoration-break:clone;-webkit-box-decoration-break:clone}
  .lineWrap{margin:6px 0}
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}
  #goodnight{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:250;display:none;text-align:center;font-family:"Courier New",monospace;font-size:var(--fs-strong);color:#fff;background:#000;padding:var(--pad-btn-y) var(--pad-btn-x);white-space:nowrap;transition:opacity .6s ease}
  #goodnight.show{display:block;opacity:1}
  #goodnight.fadeout{opacity:0}
  @media (orientation:landscape){ :root{ --frame: 32px; } }
  .tip{opacity:.7;font-size:var(--fs-small);margin-top:8px}
  .pill{display:inline-block;border:1px solid #555;padding:4px 8px;border-radius:999px;font-size:var(--fs-small);opacity:.8}
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.2×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <div id="overlay" class="fade">
    <div id="overlayContent" class="fade">
      <div class="lineWrap" style="text-align:center;margin-bottom:14px;">
        <span class="pill" id="permStatus">TAP ANYWHERE TO ALLOW: Camera • Mic • Motion</span>
      </div>
      <button id="startBtn" class="uiBtn">PRESS HERE TO SLEEP</button>
      <div class="tip" id="sensorTip" style="display:none">센서 권한 필요: 탭하면 허용 팝업이 뜹니다.</div>
    </div>
  </div>

  <div id="goodnight">GOOD NIGHT</div>

<script>
(async ()=>{
  /* ========= Unified Permission Priming ========= */
  let preGrantedStream=null;   // video+audio를 한 번에 받아 저장
  let sensorsReady=false;      // 방향/동작 센서 허용 여부
  let audioCtx=null;

  const permPill=document.getElementById('permStatus');

  async function requestOrientationPermissions(){
    try{
      if(typeof DeviceOrientationEvent!=='undefined' &&
         typeof DeviceOrientationEvent.requestPermission==='function'){
        const r=await DeviceOrientationEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }else{
        sensorsReady=true;
      }
    }catch(e){}

    try{
      if(typeof DeviceMotionEvent!=='undefined' &&
         typeof DeviceMotionEvent.requestPermission==='function'){
        const r=await DeviceMotionEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }
    }catch(e){}
  }

  async function primeAll(){
    try{
      if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      if(audioCtx.state==='suspended'){ await audioCtx.resume().catch(()=>{}); }
    }catch(e){}

    await requestOrientationPermissions();

    try{
      preGrantedStream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:'environment' },
        audio:{ echoCancellation:false, noiseSuppression:true, autoGainControl:false }
      });
      permPill.textContent='Permissions OK: Camera • Mic • Motion';
      permPill.style.opacity='0.7';
    }catch(e){
      permPill.textContent='Permissions Partial/Denied – You can continue';
      permPill.style.opacity='0.7';
      console.warn('Unified permission error:', e);
    }
  }

  const onFirstGesture = async ()=>{
    document.removeEventListener('pointerdown', onFirstGesture);
    document.removeEventListener('keydown', onFirstGesture);
    await primeAll();
  };
  document.addEventListener('pointerdown', onFirstGesture, {once:true, passive:true});
  document.addEventListener('keydown', onFirstGesture, {once:true});

  /* ========= 카메라(흑백+잔상) ========= */
  const view=document.getElementById('view');
  const vctx=view.getContext('2d',{alpha:false});
  const PROC_SCALE=0.60, TRAIL_ALPHA=0.12, GLOBAL_ALPHA=0.7;
  let ZOOM=1.2, ZOOM_MIN=0.5, ZOOM_MAX=3.0, ZOOM_STEP=0.1;

  const zoomVal=document.getElementById('zoomVal');
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const updateZoom=()=>zoomVal.textContent=ZOOM.toFixed(1)+'×';
  document.getElementById('zoomIn').onclick=()=>{ZOOM=clamp(ZOOM+ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom();};
  document.getElementById('zoomOut').onclick=()=>{ZOOM=clamp(ZOOM-ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom();};
  updateZoom();

  const camVideo=document.createElement('video');
  camVideo.autoplay=true; camVideo.playsInline=true; camVideo.muted=true;
  const proc=document.createElement('canvas');
  const pctx=proc.getContext('2d',{willReadFrequently:true});

  async function attachCamera(){
    try{
      if(preGrantedStream){
        const vTracks = preGrantedStream.getVideoTracks();
        if(vTracks.length){
          const camOnly = new MediaStream([vTracks[0]]);
          camVideo.srcObject = camOnly;
          await camVideo.play().catch(()=>{});
          return;
        }
      }
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
      camVideo.srcObject=s; await camVideo.play().catch(()=>{});
    }catch(e){console.warn("카메라 실패:", e);}
  }
  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth,h=window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale=(window.matchMedia('(orientation: landscape)').matches)? PROC_SCALE*0.9 : PROC_SCALE;
    proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale);
  }
  resizeAll(); addEventListener('resize',()=>setTimeout(resizeAll,50));

  function loop(){
    requestAnimationFrame(loop);
    const W=view.width/(window.devicePixelRatio||1);
    const H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;
    pctx.globalCompositeOperation="source-over";
    pctx.fillStyle=`rgba(0,0,0,${TRAIL_ALPHA})`; pctx.fillRect(0,0,PW,PH);
    if(camVideo.readyState>=2){
      const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
      if(vw && vh){
        const base=Math.max(PW/vw,PH/vh), sc=base*ZOOM;
        const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
        pctx.globalAlpha=GLOBAL_ALPHA; pctx.drawImage(camVideo,dx,dy,dw,dh);
        pctx.globalAlpha=1.0;
        const frame=pctx.getImageData(0,0,PW,PH); const d=frame.data;
        for(let i=0;i<d.length;i+=4){
          const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;
        }
        pctx.putImageData(frame,0,0);
      }
    }
    vctx.drawImage(proc,0,0,W,H);
  }
  await attachCamera(); loop();

  /* ========= 오디오: 스테레오/드론/마이크/모션 ========= */
  let masterGain=null, limiter=null;
  let motionGain=null;         // 전체 볼륨 제어
  let bgOsc=null, bgGain=null; // 80Hz 드론
  let micStream=null;
  let dronePermanentlyStopped=false; // (남겨두되 사용 안 함)

  // 파라미터
  const DRONE_FREQ=80, DRONE_BASE=0.08, DRONE_MAX_ADD=0.10;
  const VOL_BASE=0.20, VOL_MAX_ADD=0.55;
  const SMOOTH_TC=0.08, CTRL_SMOOTH_ALPHA=0.12;
  const DEADZONE_VOL_DEG=5, DEADZONE_PAN_DEG=3, VOL_TILT_LIMIT=60, PAN_LIMIT_DEG=45;

  // 마이크(Filter/Comp/Reverb)
  const MIC_HP=220, MIC_LOWSHELF_FREQ=200, MIC_LOWSHELF_GAIN=-12;
  const NOTCH_FREQ=300, NOTCH_Q=3.5;
  const COMP_THRESHOLD=-20, COMP_RATIO=3.5, COMP_ATTACK=0.006, COMP_RELEASE=0.12;
  const MAKEUP_GAIN=3.2;
  const MIC_WET=0.55, MIC_DRY=0.08;

  function initAudioRouting(){
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();

    try{
      const dest = audioCtx.destination;
      if (dest.maxChannelCount && dest.maxChannelCount >= 2) dest.channelCount = 2;
      if (dest.channelCountMode) dest.channelCountMode = 'explicit';
      if (dest.channelInterpretation) dest.channelInterpretation = 'discrete';
    }catch{}

    const mixBus = audioCtx.createGain(); window.__mixBus__ = mixBus;

    let panSetter=null, panOutNode=null;
    if (audioCtx.createStereoPanner) {
      const sp = audioCtx.createStereoPanner();
      panSetter = (val)=>{ try{ sp.pan.setTargetAtTime(val, audioCtx.currentTime, 0.08); }catch{ sp.pan.value = val; } };
      mixBus.connect(sp);
      panOutNode = sp;
    } else {
      const lGain = audioCtx.createGain(), rGain = audioCtx.createGain();
      const merger = audioCtx.createChannelMerger(2);
      mixBus.connect(lGain); mixBus.connect(rGain);
      lGain.connect(merger, 0, 0); rGain.connect(merger, 0, 1);
      panSetter = (pan)=>{
        const p = Math.max(-1, Math.min(1, pan||0));
        const th = (p + 1) * 0.25 * Math.PI;
        const gL = Math.cos(th), gR = Math.sin(th);
        try{
          lGain.gain.setTargetAtTime(gL, audioCtx.currentTime, 0.08);
          rGain.gain.setTargetAtTime(gR, audioCtx.currentTime, 0.08);
        }catch{ lGain.gain.value=gL; rGain.gain.value=gR; }
      };
      panOutNode = merger;
    }
    window.__setPan__ = panSetter;

    motionGain = audioCtx.createGain(); motionGain.gain.value = VOL_BASE;
    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value=-3; limiter.knee.value=0; limiter.ratio.value=20;
    limiter.attack.value=0.002; limiter.release.value=0.10;
    const outMakeup = audioCtx.createGain(); outMakeup.gain.value = 1.6;
    masterGain = audioCtx.createGain(); masterGain.gain.value=1.0;

    panOutNode.connect(motionGain);
    motionGain.connect(limiter);
    limiter.connect(outMakeup);
    outMakeup.connect(masterGain);
    masterGain.connect(audioCtx.destination);
  }

  function startDrone(){
    if(!audioCtx || bgOsc) return;
    bgOsc=audioCtx.createOscillator(); bgGain=audioCtx.createGain();
    bgOsc.type='sine'; bgOsc.frequency.value=DRONE_FREQ;
    bgGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    bgGain.gain.setTargetAtTime(DRONE_BASE, audioCtx.currentTime, 0.25);
    bgOsc.connect(bgGain).connect(window.__mixBus__);
    bgOsc.start();
  }
  // ⛔ 이전과 달리 GOOD NIGHT/화면 이탈 시 드론/진동을 멈추지 않음
  // (fadeOutDronePermanently 삭제)

  async function startMic(){
    try{
      if(!audioCtx) return;
      if(micStream) return;

      if(preGrantedStream){
        const aTracks=preGrantedStream.getAudioTracks();
        if(aTracks.length){ micStream = new MediaStream([aTracks[0]]); }
      }
      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({
          audio:{ echoCancellation:false, noiseSuppression:true, autoGainControl:false },
          video:false
        });
      }

      const src=audioCtx.createMediaStreamSource(micStream);
      const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=MIC_HP; hpf.Q.value=0.707;
      const lowshelf=audioCtx.createBiquadFilter(); lowshelf.type='lowshelf'; lowshelf.frequency.value=MIC_LOWSHELF_FREQ; lowshelf.gain.value=MIC_LOWSHELF_GAIN;
      const notch=audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=NOTCH_FREQ; notch.Q.value=NOTCH_Q;

      const comp=audioCtx.createDynamicsCompressor();
      comp.threshold.value=COMP_THRESHOLD; comp.ratio.value=COMP_RATIO;
      comp.attack.value=COMP_ATTACK; comp.release.value=COMP_RELEASE;

      const convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(2.6,2.4);
      const tapA=audioCtx.createDelay(); tapA.delayTime.value=0.11;
      const tapB=audioCtx.createDelay(); tapB.delayTime.value=0.19;
      const tapC=audioCtx.createDelay(); tapC.delayTime.value=0.27;
      const fbA=audioCtx.createGain(); fbA.gain.value=0.28; tapA.connect(fbA).connect(tapA);
      const fbB=audioCtx.createGain(); fbB.gain.value=0.22; tapB.connect(fbB).connect(tapB);
      const fbC=audioCtx.createGain(); fbC.gain.value=0.18; tapC.connect(fbC).connect(tapC);

      const dry=audioCtx.createGain(); dry.gain.value=MIC_DRY;
      const wet=audioCtx.createGain(); wet.gain.value=MIC_WET;

      const micSum=audioCtx.createGain();
      const makeup=audioCtx.createGain(); makeup.gain.value=MAKEUP_GAIN;

      const analyser=audioCtx.createAnalyser(); analyser.fftSize=512;
      const gateGain=audioCtx.createGain(); gateGain.gain.value=0; gateLoop(analyser, gateGain);

      src.connect(hpf).connect(lowshelf).connect(notch).connect(comp);
      comp.connect(analyser);
      comp.connect(dry);

      const wetSplit=audioCtx.createGain();
      comp.connect(wetSplit);
      wetSplit.connect(convolver); wetSplit.connect(tapA); wetSplit.connect(tapB); wetSplit.connect(tapC);
      const wetSum=audioCtx.createGain();
      convolver.connect(wetSum); tapA.connect(wetSum); tapB.connect(wetSum); tapC.connect(wetSum);
      wetSum.connect(wet);

      dry.connect(micSum); wet.connect(micSum);
      micSum.connect(gateGain).connect(makeup).connect(window.__mixBus__);

    }catch(e){ console.warn('Mic init failed', e); }
  }

  function gateLoop(analyser, gate){
    const buf=new Uint8Array(analyser.fftSize);
    let open=false;
    const GATE_OPEN_DB=-50, GATE_CLOSE_DB=-58, ATT=0.06, REL=0.25;
    function step(){
      requestAnimationFrame(step);
      analyser.getByteTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
      const rms=Math.sqrt(sum/buf.length);
      const db=20*Math.log10(Math.max(1e-6,rms));
      const now=audioCtx?.currentTime ?? 0;
      const shouldOpen = db>GATE_OPEN_DB || (open && db>GATE_CLOSE_DB);
      if(shouldOpen!==open){
        open=shouldOpen;
        try{ gate.gain.setTargetAtTime(open?1:0, now, open?ATT:REL); }
        catch{
          gate.gain.cancelScheduledValues(now);
          gate.gain.linearRampToValueAtTime(open?1:0, now + (open?ATT:REL));
        }
      }
    }
    step();
  }

  function makeIR(seconds=2.6, decay=2.4){
    const rate=audioCtx.sampleRate, len=Math.floor(rate*seconds);
    const ir=audioCtx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const v=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len, env=Math.pow(1-t, decay);
        v[i]=(Math.random()*2-1)*env*0.55;
      }
    }
    return ir;
  }

  /* ========= 센서/모션 매핑 ========= */
  let latestOri={beta:0,gamma:0}, smVol=VOL_BASE, smPan=0;
  function getScreenAngle(){
    const o=(screen.orientation&&screen.orientation.angle)??window.orientation??0;
    return (typeof o==='number')?o:0;
  }
  function mapOrientation(beta,gamma){
    const ang=((getScreenAngle()%360)+360)%360;
    let volTilt=0, panTilt=0;
    if(ang===0){volTilt=beta; panTilt=gamma;}
    else if(ang===90){volTilt=-gamma; panTilt=beta;}
    else if(ang===180){volTilt=-beta; panTilt=-gamma;}
    else if(ang===270){volTilt=gamma; panTilt=-beta;}
    return {volTilt, panTilt};
  }
  function tiltToPan(panTilt){
    const t=Math.min(PAN_LIMIT_DEG, Math.max(-PAN_LIMIT_DEG, panTilt||0));
    if(Math.abs(t)<DEADZONE_PAN_DEG) return 0;
    return t/PAN_LIMIT_DEG; // -1..+1
  }
  function tiltToVol(volTilt){
    const t=Math.min(VOL_TILT_LIMIT, Math.max(-VOL_TILT_LIMIT, volTilt||0));
    const a=Math.max(0, Math.abs(t)-DEADZONE_VOL_DEG)/(VOL_TILT_LIMIT-DEADZONE_VOL_DEG);
    return VOL_BASE + VOL_MAX_ADD*a;
  }
  function smoothStep(t,c,a=CTRL_SMOOTH_ALPHA){ return c+(t-c)*a; }
  function applyPanVol(pan, vol){
    if(!audioCtx) return;
    const now=audioCtx.currentTime;
    if(window.__setPan__) window.__setPan__(pan);
    if(motionGain){
      try{ motionGain.gain.setTargetAtTime(vol, now, SMOOTH_TC); }
      catch{ motionGain.gain.cancelScheduledValues(now); motionGain.gain.linearRampToValueAtTime(vol, now+0.08); }
    }
    if(bgGain){
      const droneVol = DRONE_BASE + DRONE_MAX_ADD * ((vol - VOL_BASE) / (VOL_MAX_ADD||1));
      try{ bgGain.gain.setTargetAtTime(droneVol, now, SMOOTH_TC); }
      catch{ bgGain.gain.cancelScheduledValues(now); bgGain.gain.linearRampToValueAtTime(droneVol, now+0.08); }
    }
  }

  function initOrientationListener(){
    if(typeof DeviceOrientationEvent==='undefined') return;
    window.addEventListener('deviceorientation',(e)=>{
      latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0;
    },{passive:true});
  }

  function controlLoop(){
    requestAnimationFrame(controlLoop);
    let pan=0, vol=VOL_BASE;
    const {beta, gamma}=latestOri;
    if(sensorsReady){
      const {volTilt, panTilt}=mapOrientation(beta, gamma);
      vol=smoothStep(tiltToVol(volTilt), smVol);
      pan=smoothStep(tiltToPan(panTilt), smPan);
      smVol=vol; smPan=pan;
      // 최신 기울기로 하프틱 업데이트
      updateHapticsFromTilt(volTilt, panTilt);
    }else{
      vol=smoothStep(VOL_BASE, smVol); pan=smoothStep(0, smPan);
      smVol=vol; smPan=pan;
    }
    applyPanVol(pan, vol);
  }

  /* ========= Haptics (진동) – GOOD NIGHT/화면 이탈 후에도 계속 ========= */
  let hapticsEnabled=true;           // 수동 끄기용 스위치(기본 on)
  let lastHapticAt=0;                // 마지막 진동 예약 시각(ms)
  let hapticTimer=null;              // 다음 진동 예약 타이머
  let currentPattern=[30];           // 기본 패턴
  let currentInterval=400;           // 패턴 반복 간격(ms)

  function vibrateOnce(pattern){
    if(!('vibrate' in navigator)) return;
    try{ navigator.vibrate(pattern); }catch(e){}
  }

  function choosePattern(volTilt, panTilt){
    // 좌우에 따라 패턴, 상하 기울기에 따라 길이/강도(간접적으로 빈도) 조정
    const absPan=Math.abs(panTilt||0);
    const absVol=Math.abs(volTilt||0);

    // 방향별 기본 패턴
    let pattern;
    if(panTilt > 3){         // 오른쪽 기울임 → 짧게 두 번
      pattern=[25,60,25];
    }else if(panTilt < -3){  // 왼쪽 기울임 → 짧게 한 번
      pattern=[35];
    }else if(volTilt < -6){  // 위로(머리 위쪽) 기울임 → 길게 한 번
      pattern=[90];
    }else if(volTilt > 6){   // 아래로(바닥) 기울임 → 더블-스태터
      pattern=[20,40,20,40,20];
    }else{                   // 정면/미세 기울기
      pattern=[20];
    }

    // 기울기 크기에 따라 반복 간격 줄이기(더 자주)
    const mag = Math.min(1, Math.max(absPan, Math.abs(volTilt||0)) / 45); // 0..1
    const baseInterval = 480; // 기본 간격
    const minInterval  = 120; // 최저 간격
    const interval = Math.round(baseInterval - (baseInterval-minInterval)*mag);

    return {pattern, interval};
  }

  function scheduleNextHaptic(){
    if(!hapticsEnabled) return;
    const now = performance.now();
    // 다음 트리거까지 남은 시간 계산
    const dt = Math.max(0, (lastHapticAt + currentInterval) - now);
    hapticTimer = setTimeout(()=>{
      vibrateOnce(currentPattern);
      lastHapticAt = performance.now();
      scheduleNextHaptic(); // 계속 루프
    }, dt);
  }

  function updateHapticsFromTilt(volTilt, panTilt){
    const {pattern, interval} = choosePattern(volTilt, panTilt);

    // 패턴/간격이 크게 바뀌지 않으면 그대로
    const sig = JSON.stringify(pattern);
    const samePattern = JSON.stringify(currentPattern)===sig;
    const sameInterval = Math.abs(currentInterval - interval) < 10;

    currentPattern = pattern;
    currentInterval = interval;

    // 주기가 바뀌었으면 즉시 재스케줄
    if(!samePattern || !sameInterval){
      if(hapticTimer){ clearTimeout(hapticTimer); hapticTimer=null; }
      scheduleNextHaptic();
    }
  }

  // 화면 이탈/복귀 시에도 멈추지 않게—단지 오디오 재개만 시도
  document.addEventListener('visibilitychange', ()=>{
    if(audioCtx && audioCtx.state==='suspended') audioCtx.resume().catch(()=>{});
    // hapticsEnabled 그대로, 타이머도 그대로 둠
  });
  window.addEventListener('focus', ()=>{
    if(audioCtx && audioCtx.state==='suspended') audioCtx.resume().catch(()=>{});
  });

  /* ========= 자동 시작/버튼/GOOD NIGHT ========= */
  function autoStart(){
    try{
      if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      if(audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
      initAudioRouting();
      startDrone();
      // 하프틱 루프가 아직 시작 안됐으면 시작
      if(!hapticTimer){ lastHapticAt=performance.now(); scheduleNextHaptic(); }
    }catch(e){ console.warn('autoStart err', e); }
  }
  document.addEventListener('visibilitychange', autoStart);
  window.addEventListener('focus', autoStart);

  const overlay=document.getElementById('overlay');
  const overlayContent=document.getElementById('overlayContent');
  const startBtn=document.getElementById('startBtn');
  const goodnight=document.getElementById('goodnight');

  function crossfadeUpdate(html,nextAction){
    overlayContent.classList.add('hidden');
    setTimeout(()=>{ overlayContent.innerHTML=html; overlayContent.classList.remove('hidden'); nextAction&&nextAction(); },450);
  }
  function showGoodNight(){
    goodnight.classList.add('show');
    // ⛔ 여기서 더 이상 진동/드론을 끄지 않음 (요청 반영)
    setTimeout(()=>{
      goodnight.classList.add('fadeout');
      setTimeout(()=>{ goodnight.classList.remove('show','fadeout'); goodnight.style.display='none'; },600);
    },15000);
  }

  startBtn.addEventListener('click', async ()=>{
    autoStart();
    initOrientationListener();
    await startMic().catch(()=>{});

    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    const introHTML = `
      ${line('<b>INTRODUCTION</b>')}
      ${line('1. 이곳은 이미 ‘너’가 죽어버린, ‘그것’들의 세계다.')}
      ${line('2. 곧 당신은 30분간의 잠에 들며, 무의식 속 여정을 시작한다.')}
      ${line('3. 그 여정 속에서 당신은 사라져간 ‘너’를 마주하게 된다.')}
      ${line('4. 이제 당신에게는 네 단계의 미션이 주어진다.')}
      ${line('5. 미션에 따라 ‘너’들의 목소리에 귀 기울이며, 휴대폰을 통해 잃어버린 ‘너’를 포착해야 한다.')}
      <div id="countdown" class="lineWrap">
        <span class="line">THE DOOR WILL OPEN IN <span id="countNum">60</span> SECONDS.</span>
      </div>
      <div class="tip">${sensorsReady ? '' : '패닝이 안 들리면, 설정에서 센서 권한을 허용해 주세요.'}</div>
    `;
    crossfadeUpdate(introHTML, ()=>{
      let count=60; const numEl=document.getElementById('countNum');
      const timer=setInterval(()=>{
        count--;
        if(count>=0){ numEl.textContent=count; }
        if(count<=0){
          clearInterval(timer);
          overlay.classList.add('hidden');
          setTimeout(()=>{ overlay.style.display='none'; showGoodNight(); },450);
        }
      },1000);
    });

    // 하프틱 루프 보장
    if(!hapticTimer){ lastHapticAt=performance.now(); scheduleNextHaptic(); }

    controlLoop();
  });

  // 캡처 저장
  document.getElementById('captureBtn').addEventListener('click',()=>{
    try{
      const a=document.createElement('a');
      a.download=`capture_${Date.now()}.png`;
      a.href=view.toDataURL('image/png'); a.click();
    }catch(e){ console.warn('CAPTURE 실패', e); }
  });

})();
</script>
</body>
</html>
