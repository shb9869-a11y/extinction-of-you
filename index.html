<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Dialogue into Silence</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Dialogue into Silence">
<meta name="theme-color" content="#000000">

<style>
  :root{
    --appH: 100svh; /* JS에서 window.innerHeight로 갱신 */
    --frame: clamp(16px, 4vmin, 40px);
    --ui-gap: 8px;

    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);

    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);

    --safe-t: env(safe-area-inset-top, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);
  }

  html,body{margin:0;height:var(--appH);background:#000;overflow:hidden;touch-action:manipulation}
  #view{position:fixed;left:0;top:0;width:100%;height:var(--appH);display:block;z-index:0}

  .frameBox{
    position:fixed;
    left:calc(var(--frame) + var(--safe-l));
    top:calc(var(--frame) + var(--safe-t));
    right:calc(var(--frame) + var(--safe-r));
    bottom:calc(var(--frame) + var(--safe-b));
    border:1px solid #000;pointer-events:none;z-index:50
  }

  .uiBtn{background:#000;color:#fff;border:1px solid #444;font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
  .uiBtn[disabled]{opacity:.35;pointer-events:none;filter:grayscale(1)}

  .controls{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small);color:#ddd}
  .btn-capture{
    position:fixed;
    left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:150}

  #mapLauncher{
    position:fixed; right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t)); z-index:280;}
  #docLauncher{
    position:fixed; left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t)); z-index:280;}

  /* 오버레이 */
  #overlay{
    position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;
    padding:calc(20px + var(--safe-t)) calc(20px + var(--safe-r)) calc(20px + var(--safe-b)) calc(20px + var(--safe-l));
    font-family:"Courier New",monospace;color:#fff;background:rgba(0,0,0,.72)
  }
  #overlayContent{
    pointer-events:auto;line-height:1.7;font-size:var(--fs-body);
    max-width:min(92vw, 72ch);
    max-height:calc(var(--appH) - (var(--frame)*2) - var(--safe-t) - var(--safe-b));
    overflow:auto; -webkit-overflow-scrolling:touch; text-align:left
  }
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}

  /* 컷인(침묵) — 배경 투명 유지 */
  #cutin{ position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center; background:transparent; color:#fff; font-family:"Courier New",monospace; text-align:center; padding-bottom:var(--safe-b); padding-top:var(--safe-t);}
  #cutin.show{display:flex; opacity:1; transition:opacity .45s ease}
  #cutin.fadeout{opacity:0}
  #cutinText{font-size:clamp(24px, 8vmin, 64px); letter-spacing:.12em; line-height:1.2; padding:0 .2em}

  /* INTRO UI */
  .introHeader{ text-align:center; font-size:clamp(14px,2.4vmin,18px); letter-spacing:.12em; margin-bottom:10px; color:#fff; opacity:.9; }
  .introCard{ margin:0 auto; max-width:min(86vw, 980px); background:transparent; border:none; padding:6px 8px; }
  .introLine{ margin:8px 0; }
  .introChar{ display:inline-block; background:#000; color:#fff; padding:2px 5px; margin:2px 1px; box-shadow:0 0 0 1px #333 inset; }

  /* ====== GAME OVERLAY ====== */
  #gameOverlay{ position:fixed; inset:0; z-index:300; display:none; background:rgba(0,0,0,.8);
    font-family:"Courier New",monospace; color:#fff; padding-bottom:var(--safe-b); padding-top:var(--safe-t);}
  #gameUI{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    display:flex; flex-direction:column; align-items:center; gap:10px; width:min(96vw, 1100px); }
  #gameHeader{ width:100%; display:flex; justify-content:space-between; align-items:center; gap:8px; }
  #gameCanvas{ width:100%; height:min(60vh, calc(var(--appH)*0.6)); background:#000; image-rendering: pixelated; border:1px solid #444 }
  #gameBtns{ display:flex; gap:6px; align-items:center }
  #mapGrid{ display:none } /* 미로 버튼 숨김 */

  /* 모바일 DPAD */
  #dpad{ position:absolute; left:calc(var(--frame) + var(--safe-l)); bottom:calc(var(--frame) + 64px + var(--safe-b)); z-index:320;
    display:grid; grid-template-columns:repeat(3,48px); grid-template-rows:repeat(3,48px); gap:6px; }
  .dkey{ width:48px; height:48px; border:1px solid #444; display:flex; align-items:center; justify-content:center; color:#fff; background:#000; opacity:.75; user-select:none; }
  .dkey:active{ opacity:1 }

  /* 인터랙트 힌트 버튼 (하단 중앙) */
  #interactHint{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:calc(var(--frame) + var(--safe-b) + 8px); z-index:330; display:none;
    border:1px solid #444; background:#000; color:#fff; padding:8px 12px; font-size:var(--fs-small);
  }

  /* ====== GAME DIALOG ====== */
  #gameDialog{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:340; background:rgba(0,0,0,.55); }
  #gameDialog .box{ min-width:260px; max-width:86vw; background:#111; color:#eee; border:1px solid #444; border-radius:10px; padding:12px; box-shadow:0 10px 24px rgba(0,0,0,.6); font:12px/1.6 "Courier New",monospace; }
  #gameDialog .box h3{ margin:0 0 8px; font:700 12px "Courier New",monospace; color:#f0f0f0; }
  #gameDialog .choices{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  #gameDialog .choices button{ padding:6px 10px; border-radius:8px; border:1px solid #555; background:#222; color:#fff; font:600 12px "Courier New",monospace; }

  /* ====== DOCUMENT ====== */
  #docOverlay{ position:fixed; inset:0; z-index:310; display:none; background:rgba(0,0,0,.8);
    font-family:"Courier New",monospace; color:#fff; padding-bottom:var(--safe-b); padding-top:var(--safe-t);}
  #docUI{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(96vw,1100px); display:flex; flex-direction:column; gap:10px; }
  #docHeader{ display:flex; justify-content:space-between; align-items:center; }
  #docGrid{ display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; }
  .docBtn{ border:1px solid #444; background:#000; color:#fff; padding:12px; text-align:center; cursor:pointer; font-size:var(--fs-small) }
  .docPane{ border:1px solid #444; padding:12px; max-height:50vh; overflow:auto; background:#000; }
  .docTitle{ font-size:var(--fs-strong); margin-bottom:8px; }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <!-- 기본 컨트롤 -->
  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <!-- 상단 런처 -->
  <button id="docLauncher" class="uiBtn small">DOCUMENT</button>
  <button id="mapLauncher" class="uiBtn small">MAP</button>

  <!-- 메인 오버레이 -->
  <div id="overlay" class="fade" style="display:flex">
    <div id="overlayContent" class="fade" style="text-align:center">
      <button id="permGateBtn" class="uiBtn" style="width:min(80vw,420px)">
        화면을 탭하여 카메라·동작(센서)·오디오를 허용해주세요
      </button>
      <div class="tip" style="color:#ddd">권한 허용 후 WELCOME 화면이 나타납니다.</div>
    </div>
  </div>

  <!-- 컷인/굿나잇 -->
  <div id="goodnight" style="display:none">GOOD NIGHT, HAVE A NICE DREAM</div>
  <div id="cutin"><div id="cutinText"></div></div>

  <!-- ====== GAME OVERLAY ====== -->
  <div id="gameOverlay">
    <div id="gameUI">
      <div id="gameHeader">
        <div id="hud">
          <span id="hudRoom">ROOM: 비석의 방 · 하단 출구 → 전화기의 방</span>
        </div>
        <div id="gameBtns">
          <button id="btnExitGame" class="uiBtn small">EXIT</button>
        </div>
      </div>
      <canvas id="gameCanvas" width="640" height="400"></canvas>
    </div>

    <!-- 모바일 DPAD -->
    <div id="dpad">
      <div></div><div class="dkey" data-dy="-1">↑</div><div></div>
      <div class="dkey" data-dx="-1">←</div><div class="dkey" data-dy="1">↓</div><div class="dkey" data-dx="1">→</div>
      <div></div><div></div><div></div>
    </div>

    <!-- 상호작용 힌트 -->
    <button id="interactHint" class="uiBtn small">E: 상호작용</button>

    <!-- 대화/기록 -->
    <div id="gameDialog">
      <div class="box">
        <h3 id="dgTitle">기록</h3>
        <div id="dgBody">...</div>
        <div id="dgChoices" class="choices"></div>
      </div>
    </div>
  </div>

  <!-- ====== DOCUMENT OVERLAY ====== -->
  <div id="docOverlay">
    <div id="docUI">
      <div id="docHeader">
        <div class="readout">DOCUMENTS</div>
        <div><button id="btnExitDoc" class="uiBtn small">EXIT</button></div>
      </div>
      <div id="docGrid"></div>
      <div id="docPane" class="docPane" style="display:none">
        <div class="docTitle" id="docTitle">Document</div>
        <div id="docBody">준비중입니다.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /* ──────────────────────────────
   * Manifest (동적 삽입)
   * ────────────────────────────── */
  (function injectManifest() {
    const manifest = {
      name: 'Dialogue into Silence',
      short_name: 'Dialogue into Silence',
      display: 'standalone',
      start_url: './',
      background_color: '#000',
      theme_color: '#000',
      icons: []
    };
    const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: 'application/manifest+json' }));
    const link = document.createElement('link');
    link.rel = 'manifest';
    link.href = url;
    document.head.appendChild(link);
  })();

  /* ──────────────────────────────
   * Util & Layout
   * ────────────────────────────── */
  const qs = (s) => document.querySelector(s);
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const WANT_MIC = true;
  const IS_ANDROID = /Android|Linux/i.test(navigator.userAgent) && !/like Android/i.test(navigator.userAgent);

  function setAppHeight() {
    document.documentElement.style.setProperty('--appH', window.innerHeight + 'px');
  }
  setAppHeight();
  addEventListener('resize', setAppHeight, { passive: true });
  addEventListener('orientationchange', () => setTimeout(setAppHeight, 120), { passive: true });
  if (window.visualViewport) {
    visualViewport.addEventListener('resize', () => setTimeout(setAppHeight, 50));
  }

  /* ──────────────────────────────
   * Audio
   * ────────────────────────────── */
  let audioCtx = null, mixBus, sfxBus, reverbNode, wetBus, dryBus, master, panNode, micGain;

  function makeImpulse(ctx, seconds = 2, decay = 3) {
    const rate = ctx.sampleRate;
    const len = (rate * seconds) | 0;
    const buf = ctx.createBuffer(2, len, rate);
    for (let ch = 0; ch < 2; ch++) {
      const d = buf.getChannelData(ch);
      for (let i = 0; i < len; i++) {
        const t = i / len;
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
      }
    }
    return buf;
  }

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    mixBus = audioCtx.createGain();
    sfxBus = audioCtx.createGain();
    wetBus = audioCtx.createGain();
    dryBus = audioCtx.createGain();
    master = audioCtx.createGain();

    sfxBus.gain.value = 0.8;
    dryBus.gain.value = 0.55;
    wetBus.gain.value = 0.55;

    reverbNode = audioCtx.createConvolver();
    reverbNode.buffer = makeImpulse(audioCtx);
    panNode = audioCtx.createStereoPanner();
    micGain = audioCtx.createGain();
    micGain.gain.value = 1.0;

    mixBus.connect(dryBus);
    mixBus.connect(reverbNode);
    reverbNode.connect(wetBus);
    dryBus.connect(master);
    wetBus.connect(master);
    master.connect(audioCtx.destination);
    sfxBus.connect(mixBus);
  }

  function resumeAudio() {
    try {
      initAudio();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    } catch {}
  }

  function playSfx(freq = 180, dur = 0.16) {
    try {
      resumeAudio();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.001, t);
      g.gain.exponentialRampToValueAtTime(0.6, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.connect(g).connect(sfxBus);
      o.start(t);
      o.stop(t + dur + 0.02);
    } catch {}
  }

  const SFX = {
    ui: () => playSfx(170, 0.14),
    step: (i = 0) => playSfx(i % 2 ? 520 : 460, 0.08),
    interact: () => { playSfx(900, 0.08); setTimeout(() => playSfx(1300, 0.08), 90); },
    select: () => playSfx(660, 0.07),
    ring: () => { playSfx(660, 0.12); setTimeout(() => playSfx(660, 0.12), 140); }
  };

  // 마이크
  let micStream = null;
  async function startMic() {
    if (micStream) return;
    try {
      micStream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 1, sampleRate: 48000 },
        video: false
      });
      resumeAudio();
      const source = audioCtx.createMediaStreamSource(micStream);
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 80;
      source.connect(hp).connect(micGain).connect(panNode).connect(mixBus);
    } catch (e) { console.warn('Mic denied/failed', e); }
  }

  /* 센서 → 패닝 */
  let lastMotion = { x: 0, y: 0 };
  function updateAudioFromSensors(ori, mot) {
    const gamma = (ori && typeof ori.gamma === 'number') ? ori.gamma : (mot ? (mot.x * 9) : 0);
    const beta  = (ori && typeof ori.beta  === 'number') ? ori.beta  : (mot ? (mot.y * 9) : 0);
    const pan = clamp(gamma / 45, -1, 1);
    const vol = clamp(0.35 + Math.abs(beta) / 90 * 1.25, 0.35, 1.6);
    try {
      panNode?.pan?.setTargetAtTime(pan, audioCtx.currentTime, 0.03);
      micGain?.gain?.setTargetAtTime(vol, audioCtx.currentTime, 0.03);
    } catch {}
  }

  async function requestMotionPermissions() {
    const needsIOS = typeof DeviceOrientationEvent !== 'undefined' &&
                     typeof DeviceOrientationEvent.requestPermission === 'function';
    try {
      if (needsIOS) {
        const r1 = await DeviceOrientationEvent.requestPermission();
        let r2 = 'granted';
        if (typeof DeviceMotionEvent !== 'undefined' &&
            typeof DeviceMotionEvent.requestPermission === 'function') {
          r2 = await DeviceMotionEvent.requestPermission();
        }
        if (r1 !== 'granted' || r2 !== 'granted') return false;
      }
    } catch {}
    addEventListener('deviceorientation', (e) => { updateAudioFromSensors(e, lastMotion); }, { passive: true });
    addEventListener('devicemotion', (e) => {
      const g = e.accelerationIncludingGravity || {};
      lastMotion.x = +g.x || 0;
      lastMotion.y = +g.y || 0;
      updateAudioFromSensors(null, lastMotion);
    }, { passive: true });
    return true;
  }

  /* ──────────────────────────────
   * Camera & Background
   * ────────────────────────────── */
  const view = qs('#view');
  const vctx = view.getContext('2d', { alpha: false });
  const PROC_SCALE = 0.9, TRAIL_ALPHA = 0.12, GLOBAL_ALPHA = 0.7;
  let ZOOM = 1.0, ZOOM_MIN = 0.35, ZOOM_MAX = 3.0, ZOOM_STEP = 0.05;
  const zoomVal = qs('#zoomVal');
  const updateZoom = () => { zoomVal.textContent = ZOOM.toFixed(1) + '×'; };
  qs('#zoomIn').addEventListener('click', () => { ZOOM = clamp(ZOOM + ZOOM_STEP, ZOOM_MIN, ZOOM_MAX); updateZoom(); SFX.ui(); });
  qs('#zoomOut').addEventListener('click', () => { ZOOM = clamp(ZOOM - ZOOM_STEP, ZOOM_MIN, ZOOM_MAX); updateZoom(); SFX.ui(); });
  updateZoom();

  const camVideo = document.createElement('video');
  camVideo.autoplay = true; camVideo.playsInline = true; camVideo.muted = true;
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', { willReadFrequently: true });
  let camStream = null;

  async function attachCamera() {
    try {
      if (camStream) return;
      camStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
        audio: false
      });
      camVideo.srcObject = camStream;
      await camVideo.play().catch(() => {});
    } catch (e) { console.warn('camera failed', e); }
  }

  function resizeAll() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth, h = window.innerHeight;
    view.width = w * dpr; view.height = h * dpr;
    vctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    const scale = (matchMedia('(orientation: landscape)').matches) ? PROC_SCALE * 0.9 : PROC_SCALE;
    proc.width = Math.floor(w * scale);
    proc.height = Math.floor(h * scale);
  }
  resizeAll();
  addEventListener('resize', () => setTimeout(resizeAll, 50), { passive: true });
  addEventListener('orientationchange', () => setTimeout(resizeAll, 120), { passive: true });
  if (window.visualViewport) {
    visualViewport.addEventListener('resize', () => setTimeout(resizeAll, 50));
  }

  function loopBG() {
    requestAnimationFrame(loopBG);
    const dpr = window.devicePixelRatio || 1;
    const W = view.width / dpr, H = view.height / dpr, PW = proc.width, PH = proc.height;

    pctx.globalCompositeOperation = 'source-over';
    pctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
    pctx.fillRect(0, 0, PW, PH);

    if (camVideo.readyState >= 2) {
      const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
      if (vw && vh) {
        const cover = Math.max(PW / vw, PH / vh);
        const sc = cover * ZOOM;
        const dw = vw * sc, dh = vh * sc, dx = (PW - dw) / 2, dy = (PH - dh) / 2;
        pctx.globalAlpha = GLOBAL_ALPHA;
        pctx.drawImage(camVideo, dx, dy, dw, dh);
        pctx.globalAlpha = 1.0;
        const frame = pctx.getImageData(0, 0, PW, PH), d = frame.data;
        for (let i = 0; i < d.length; i += 4) {
          const g = (0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2]) | 0;
          d[i] = d[i + 1] = d[i + 2] = g;
        }
        pctx.putImageData(frame, 0, 0);
      }
    }
    vctx.drawImage(proc, 0, 0, W, H);
  }
  loopBG();

  // 캡처 버튼: 현재 화면을 PNG로 저장
  qs('#captureBtn').addEventListener('click', () => {
    try {
      const link = document.createElement('a');
      link.download = `capture-${Date.now()}.png`;
      link.href = view.toDataURL('image/png');
      link.click();
      SFX.ui();
    } catch {}
  }, { passive: true });

  /* ──────────────────────────────
   * Overlay / Onboarding
   * ────────────────────────────── */
  const overlayEl = qs('#overlay'), overlayContentEl = qs('#overlayContent');
  const goodnight = qs('#goodnight'), cutin = qs('#cutin'), cutinText = qs('#cutinText');

  const lockTargets = [qs('#mapLauncher'), qs('#docLauncher'), qs('#captureBtn'), qs('#zoomIn'), qs('#zoomOut')];
  const setGlobalUIEnabled = (on) => lockTargets.forEach(b => b && (b.disabled = !on));
  const setOverlayDim = (on) => overlayEl.style.background = on ? 'rgba(0,0,0,.72)' : 'transparent';
  const setOverlayClickable = (on) => overlayEl.style.pointerEvents = on ? 'auto' : 'none';

  const spanChars = (t) => [...t].map(ch => `<span class="introChar">${ch === ' ' ? '&nbsp;' : ch.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>`).join('');
  const introParagraphHTML = (lines) => lines.map(s => `<div class="introLine">${spanChars(s)}</div>`).join('');

  function show(html, next) {
    overlayEl.style.display = 'flex';
    overlayEl.classList.remove('hidden');
    overlayContentEl.classList.add('hidden');
    setOverlayDim(true); setOverlayClickable(true);
    setTimeout(() => { overlayContentEl.innerHTML = html; overlayContentEl.classList.remove('hidden'); next && next(); }, 120);
  }
  function hide(next) {
    overlayEl.classList.add('hidden');
    setTimeout(() => { overlayEl.style.display = 'none'; next && next(); }, 420);
  }

  function showWelcome() {
    show(`
      <div class="introCard">
        <div class="introHeader">SHB,KCW,KJS,JMJ,KHJ,JYS</div>
        <div class="introLine">${spanChars('Welcome to Dialogue into Silence')}</div>
        <div style="text-align:center;margin-top:12px">
          <button id="welcomeGo" class="uiBtn">PRESS HERE TO SLEEP</button>
        </div>
      </div>
    `, () => {
      setGlobalUIEnabled(false);
      qs('#welcomeGo').addEventListener('click', () => { SFX.ui(); mountPressToSleep(); }, { passive: true });
    });
  }

  function showGoodNight(next) {
    goodnight.textContent = 'GOOD NIGHT, HAVE A NICE DREAM';
    goodnight.style.display = 'block';
    SFX.ui();
    setTimeout(() => { goodnight.style.display = 'none'; next && next(); }, 1600);
  }
  function showCutInLabel(label, holdMs = 1600, after) {
    cutinText.textContent = label;
    cutin.classList.remove('fadeout');
    cutin.classList.add('show');
    SFX.ui();
    setTimeout(() => {
      cutin.classList.add('fadeout');
      setTimeout(() => {
        cutin.classList.remove('show', 'fadeout');
        cutin.style.display = 'none';
        after && after();
      }, 300);
    }, holdMs);
  }

  function showNarrativeSequence(done) {
    const narrative = [
      '자욱한 안개가 너를 맞이했다. 거대한 비석을 너는 마주했다. 거대한 비석들의 웅얼거림을 너는 들을 수 있었다.',
      '어디선가 잔잔한 종소리가 들려온다. 어디선가 께름칙한 울음소리가 들려온다. 어디선가 아이들의 웃음소리가 들려온다.',
      '너는 비석 사이를 거닐고 있다. 너를 스쳐 지나가며 웅얼거리는 소리에 귀를 기울인다.',
      '비석마다 다른 목소리가 담겨 있다. 어떤 것은 꿈을 이야기하고, 어떤 것은 기억을 읊고, 또 어떤 것은 아직 말하지 못한 언어로 중얼거린다.',
      '너는 발걸음을 늦춘다. 너는 생각한다. 이곳엔 분명 누군가가 존재하고 있었다.',
      '그리고, 지금도 여전히 그들의 호흡은 돌 틈에 스며 있고, 그들의 그림자는 안개 속에 머물며, 그들의 말하지 못한 시간은 너의 귀끝을 잡아당긴다.',
      '너는 발걸음을 멈춘다. 왜인지 이곳에 머물러야 한다는 느낌을 받는다.',
      '너는 그곳으로 발을 옮긴다. 그곳엔, 이곳에 존재했던 누군가의 ‘목소리’가 있다.',
      '너는 비석에 등을 기대고 앉는다. 그리고 서서히, 그것의 진동을 느낀다.'
    ];
    setOverlayDim(false); setOverlayClickable(false);
    overlayEl.style.display = 'flex';
    overlayEl.classList.remove('hidden');
    let idx = 0;
    (function next() {
      if (idx >= narrative.length) { hide(done); return; }
      overlayContentEl.classList.add('hidden');
      setTimeout(() => {
        overlayContentEl.innerHTML = `<div class="introCard"><div class="introLine">${spanChars(narrative[idx++])}</div></div>`;
        overlayContentEl.classList.remove('hidden');
        SFX.ui();
        setTimeout(next, 5000);
      }, 120);
    })();
  }

  function firstSilenceFlow() {
    showCutInLabel('THE FIRST SILENCE', 1600, () => {
      setGlobalUIEnabled(true);
      setTimeout(() => { showNarrativeSequence(() => {}); }, 5000);
    });
  }

  function mountPressToSleep() {
    const introLines = [
      '이곳은 이미 ‘너’가 죽어버린, ‘그것’들의 세계다.',
      '곧 당신은 30분간의 잠에 들며, 무의식 속 여정을 시작한다.',
      '그 여정 속에서 당신은 사라져간 ‘너’를 마주하게 된다.',
      '이제 당신에게는 네 단계의 미션이 주어진다.',
      '당신은 미션에 따라 헤드폰으로 들려오는 ‘너’들의 목소리에 귀 기울이며, 휴대폰을 통해 잃어버린 ‘너’를 포착할 수 있다.'
    ];
    show(
      `<div class="introCard">
         <div class="introHeader">INTRODUCTION</div>
         ${introParagraphHTML(introLines)}
         <div class="introLine" id="countdown">
           ${spanChars('The door will close in ')}<span id="countNum" class="introChar">55</span>${spanChars(' seconds.')}
         </div>
       </div>`,
      () => {
        setGlobalUIEnabled(false);
        let count = 55;
        const numEl = qs('#countNum');
        const timer = setInterval(() => {
          count--;
          if (count >= 0 && numEl) numEl.textContent = count;
          if (count <= 0) {
            clearInterval(timer);
            hide(() => { setGlobalUIEnabled(true); showGoodNight(firstSilenceFlow); });
          }
        }, 1000);
        SFX.ui();
      }
    );
  }

  // 퍼미션 게이트 + 전체화면 락(안드로이드)
  async function enterFullscreenIfPossible(desired = 'portrait') {
    try {
      const el = document.documentElement;
      if (!document.fullscreenElement && document.fullscreenEnabled && el.requestFullscreen) {
        await el.requestFullscreen({ navigationUI: 'hide' }).catch(() => {});
      }
      if (screen.orientation && screen.orientation.lock) {
        const mode = desired === 'landscape' ? 'landscape' : 'portrait';
        screen.orientation.lock(mode).catch(() => {});
      }
    } catch {}
  }

  let gateBusy = false, gateDone = false;
  async function runPermissionGate() {
    if (gateBusy || gateDone) return;
    gateBusy = true;
    try {
      SFX.ui(); resumeAudio();
      await requestMotionPermissions();
      await attachCamera();
      if (WANT_MIC) await startMic();
      if (IS_ANDROID) {
        const desired = matchMedia('(orientation: landscape)').matches ? 'landscape' : 'portrait';
        await enterFullscreenIfPossible(desired);
      }
      showWelcome();
      gateDone = true;
    } catch (e) { console.warn('gate error', e); }
    finally { gateBusy = false; }
  }

  // 첫 사용자 제스처면 게이트 실행
  ['pointerdown','touchstart','click','keydown'].forEach(evt => {
    window.addEventListener(evt, () => { if (!gateDone) runPermissionGate(); }, { once: true, capture: true, passive: true });
  });

  // 버튼/배경에서도 실행
  ['pointerdown','touchstart','click'].forEach(evt => {
    qs('#permGateBtn').addEventListener(evt, (e) => { e.preventDefault(); runPermissionGate(); }, { passive: false });
    overlayEl.addEventListener(evt, (e) => {
      if (!gateDone && e.target === overlayEl) { e.preventDefault(); runPermissionGate(); }
    }, { passive: false });
  });

  addEventListener('orientationchange', () => {
    if (IS_ANDROID && matchMedia('(orientation: landscape)').matches) {
      setTimeout(() => enterFullscreenIfPossible('landscape'), 150);
    }
  }, { passive: true });

  /* ──────────────────────────────
   * Document Overlay
   * ────────────────────────────── */
  const docOverlay = qs('#docOverlay'), docGrid = qs('#docGrid'), docPane = qs('#docPane'), docTitle = qs('#docTitle'), docBody = qs('#docBody');
  const docLauncher = qs('#docLauncher'), btnExitDoc = qs('#btnExitDoc');
  function openDoc(){ docOverlay.style.display = 'block'; }
  function closeDoc(){ docOverlay.style.display = 'none'; }
  docLauncher.addEventListener('click', openDoc, { passive: true });
  btnExitDoc.addEventListener('click', closeDoc, { passive: true });
  (function buildDocGrid(){
    docGrid.innerHTML = '';
    for (let i = 1; i <= 8; i++) {
      const b = document.createElement('button');
      b.className = 'docBtn';
      b.textContent = `Document ${i}`;
      b.onclick = () => { docTitle.textContent = `Document ${i}`; docBody.innerHTML = '준비중입니다.'; docPane.style.display = 'block'; };
      docGrid.appendChild(b);
    }
  })();

  /* ──────────────────────────────
   * Game
   * ────────────────────────────── */
  const gameOverlay = qs('#gameOverlay'), gameCanvas = qs('#gameCanvas'), g = gameCanvas.getContext('2d');
  const dpad = qs('#dpad'), hudRoom = qs('#hudRoom'), interactHint = qs('#interactHint');
  const btnExitGame = qs('#btnExitGame'), mapLauncher = qs('#mapLauncher');

  const REND_W = 256, REND_H = 256, TILE = 16, MAP_W = 16, MAP_H = 16;
  const off = document.createElement('canvas'); off.width = REND_W; off.height = REND_H;
  const og = off.getContext('2d', { alpha: false }); og.imageSmoothingEnabled = false;

  const C = {
    bg:'#111', plate:'#1b1b1b', plate2:'#0f0f0f', border:'#2a2a2a', dot:'#242424',
    grave:'#bbbbbb', graveDark:'#666666', shadow:'rgba(0,0,0,.55)',
    seekerBody:'#cccccc', seekerEye:'#eeeeee',
    player:'#ffffff', playerDark:'#aaaaaa',
    brick:'#444444', brickDark:'#222222', phone:'#dddddd', phoneDial:'#bdbdbd'
  };

  // 맵
  const LEVEL0 = Array.from({length:MAP_H}, () => Array(MAP_W).fill(1));
  for (let y = 2; y < MAP_H - 1; y += 2) { for (let x = 1; x < MAP_W - 1; x++) LEVEL0[y][x] = 0; }
  for (let x = 2; x < MAP_W - 1; x += 2) { for (let y = 1; y < MAP_H - 1; y++) LEVEL0[y][x] = 0; }
  for (let y = 1; y < 5; y++) for (let x = 12; x < 15; x++) LEVEL0[y][x] = 0;
  LEVEL0[8][8] = LEVEL0[7][8] = LEVEL0[8][7] = LEVEL0[8][9] = 0;
  for (let x = 6; x <= 9; x++) LEVEL0[MAP_H - 1][x] = 0;

  const LEVEL1 = Array.from({length:MAP_H}, () => Array(MAP_W).fill(0));
  for (let x = 0; x < MAP_W; x++) { LEVEL1[0][x] = 1; LEVEL1[MAP_H - 1][x] = 1; }
  for (let y = 0; y < MAP_H; y++) { LEVEL1[y][0] = 1; LEVEL1[y][MAP_W - 1] = 1; }
  for (let x = 6; x <= 9; x++) LEVEL1[MAP_H - 1][x] = 0;

  const PHONES = [[1,3],[1,6],[1,9],[1,12],[4,1],[7,1],[10,1],[14,3],[14,6],[14,9],[4,13],[7,13],[10,13],[13,13]];
  const phoneSet = new Set(PHONES.map(([x,y]) => `${x},${y}`));

  function drawCommon(gg) {
    gg.fillStyle = C.bg; gg.fillRect(0,0,REND_W,REND_H);
    gg.fillStyle = C.border; gg.fillRect(6,6,REND_W-12,REND_H-12);
    gg.fillStyle = C.plate; gg.fillRect(12,12,REND_W-24,REND_H-24);
    gg.fillStyle = C.dot;
    for (let i = 0; i < 190; i++) {
      const x = 12 + ((i * 73) % (REND_W - 24));
      const y = 12 + ((i * 97) % (REND_H - 24));
      gg.fillRect(x, y, 1, 1);
    }
  }
  function dGrave(gg,px,py){
    gg.fillStyle = C.shadow; gg.fillRect(px+2,py+TILE-3,TILE-2,2);
    gg.fillStyle = C.graveDark; gg.fillRect(px+3,py+3,TILE-6,TILE-6);
    gg.fillStyle = C.grave; gg.fillRect(px+2,py+4,TILE-6,TILE-7);
    gg.fillStyle = 'rgba(255,255,255,.08)'; gg.fillRect(px+3,py+4,TILE-8,1);
  }
  function dBrick(gg,px,py){
    gg.fillStyle = C.brickDark; gg.fillRect(px,py,TILE,TILE);
    gg.fillStyle = C.brick; gg.fillRect(px+1,py+1,TILE-2,TILE-2);
    gg.fillStyle = 'rgba(0,0,0,.25)'; gg.fillRect(px+1,py+TILE-4,TILE-2,3);
  }
  function dPhone(gg,px,py){
    gg.fillStyle = C.phone; gg.fillRect(px+2,py+5,12,8);
    gg.fillStyle = C.phoneDial; gg.fillRect(px+5,py+7,6,4);
    gg.fillStyle = 'rgba(255,255,255,.12)'; gg.fillRect(px+3,py+6,8,1);
    gg.fillStyle = C.shadow; gg.fillRect(px+2,py+TILE-2,12,2);
  }

  const layer0 = (() => {
    const c = document.createElement('canvas'); c.width = REND_W; c.height = REND_H;
    const gg = c.getContext('2d'); gg.imageSmoothingEnabled = false;
    drawCommon(gg);
    for (let y = 0; y < MAP_H; y++) for (let x = 0; x < MAP_W; x++) if (LEVEL0[y][x] === 1) dGrave(gg, x*TILE, y*TILE);
    gg.fillStyle = C.plate2; gg.fillRect(6*TILE,15*TILE,4*TILE,TILE);
    return c;
  })();

  const layer1 = (() => {
    const c = document.createElement('canvas'); c.width = REND_W; c.height = REND_H;
    const gg = c.getContext('2d'); gg.imageSmoothingEnabled = false;
    drawCommon(gg);
    for (let y = 0; y < MAP_H; y++) for (let x = 0; x < MAP_W; x++) if (LEVEL1[y][x] === 1) dBrick(gg, x*TILE, y*TILE);
    for (const [x,y] of PHONES) dPhone(gg, x*TILE, y*TILE);
    gg.fillStyle = C.plate2; gg.fillRect(6*TILE,15*TILE,4*TILE,TILE);
    return c;
  })();

  // 엔티티
  function makePlayer(x, y) { return { x, y, spd: 0.09, anim: 0, stepTimer: 0, stepPhase: 0 }; }
  function makeSeeker(x, y) { return { x, y, spd: 0.07, path: [], target: null, repathAt: 0 }; }
  const player = makePlayer(13.5, 2.5);
  const seeker = makeSeeker(8.5, 8.5);

  let room = 0; // 0: 비석, 1: 전화
  function solidAt(tx, ty) {
    if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return true;
    if (room === 0) return LEVEL0[ty][tx] === 1;
    if (LEVEL1[ty][tx] === 1) return true;
    if (phoneSet.has(`${tx},${ty}`)) return true;
    return false;
  }
  function moveEntity(e, ax, ay) {
    const spd = e.spd;
    let nx = e.x + ax * spd, ny = e.y + ay * spd;
    if (!solidAt(nx|0, e.y|0)) e.x = nx;
    if (!solidAt(e.x|0, ny|0)) e.y = ny;
  }

  // 입력
  const keys = new Set();
  addEventListener('keydown', e => {
    if (!gameRunning) return;
    const k = e.key.toLowerCase();
    if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','e'].includes(k)) e.preventDefault();
    keys.add(k);
  }, { passive: false });
  addEventListener('keyup', e => { if (!gameRunning) return; keys.delete(e.key.toLowerCase()); }, { passive: true });

  const heldDirs = new Set(); const dpadState = { ax: 0, ay: 0 };
  function updateDirFromHeld() {
    let ax = 0, ay = 0;
    if (heldDirs.has('left')) ax -= 1;
    if (heldDirs.has('right')) ax += 1;
    if (heldDirs.has('up')) ay -= 1;
    if (heldDirs.has('down')) ay += 1;
    dpadState.ax = ax; dpadState.ay = ay;
  }
  dpad.addEventListener('pointerdown', e => {
    const dx = e.target.getAttribute('data-dx');
    const dy = e.target.getAttribute('data-dy');
    if (dx) heldDirs.add(+dx < 0 ? 'left' : 'right');
    if (dy) heldDirs.add(+dy < 0 ? 'up' : 'down');
    updateDirFromHeld();
    e.preventDefault();
  }, { passive: false });
  const clearHeld = () => { heldDirs.clear(); updateDirFromHeld(); };
  dpad.addEventListener('pointerup', clearHeld, { passive: true });
  dpad.addEventListener('pointercancel', clearHeld, { passive: true });
  addEventListener('pointerup', clearHeld, { passive: true });

  // 대화/기록
  const gameDialog = qs('#gameDialog'), dgTitle = qs('#dgTitle'), dgBody = qs('#dgBody'), dgChoices = qs('#dgChoices');
  function closeDialog() { gameDialog.style.display = 'none'; dgChoices.innerHTML = ''; inConvo = false; }
  gameDialog.addEventListener('click', (e) => { if (e.target === gameDialog) closeDialog(); }, { passive: true });

  function graveText(x, y) {
    const lines = [
      '나는 얼굴을 잃고, 귀로만 걷는다.',
      '빛이 고요를 문질러 소리가 났다.',
      '오차가 감정이고, 잔향이 초상이다.',
      '돌은 서 있고, 이야기는 흘러간다.',
      '너와 나 사이, 빈칸이 숨을 쉰다.',
      '시간의 모서리에 귀를 댔다.',
      '여기 눕힌 건 말들이다.',
      '망각의 틈에서 작은 불이 켜진다.'
    ];
    const idx = (x * 31 + y * 17) % lines.length;
    return lines[idx];
  }
  function nearestGrave(px, py) {
    let best = null, bd = 1e9;
    for (let y = 0; y < MAP_H; y++) for (let x = 0; x < MAP_W; x++) if (LEVEL0[y][x] === 1) {
      const cx = x + 0.5, cy = y + 0.5; const d = Math.hypot(px - cx, py - cy);
      if (d < bd) { bd = d; best = { x, y, cx, cy }; }
    }
    return { grave: best, dist: bd };
  }
  function nearestPhone(px, py) {
    let best = null, bd = 1e9;
    for (const [x, y] of PHONES) {
      const cx = x + 0.5, cy = y + 0.5; const d = Math.hypot(px - cx, py - cy);
      if (d < bd) { bd = d; best = { x, y, cx, cy }; }
    }
    return { phone: best, dist: bd };
  }

  const convo = [
    { npc: '……신호 포착. 너는 소리를 어떻게 듣지?', choices: ['몸으로 먼저 듣는다.','기억으로 해석한다.'], replies: ['좋아. 몸은 진실을 숨기지 않지.','그래, 기억은 언제나 편집본이야.'] },
    { npc: '여기 비석들은 잊힌 말들의 좌표야.', choices: ['좌표를 따라가면 어디에 닿을까?','말이 사라지면 무엇이 남지?'], replies: ['아마 네가 모르는 너에게.','침묵. 그리고 방향.'] },
    { npc: '마지막 질문. 너는 왜 계속 걷고 있어?', choices: ['누군가의 잔향을 찾고 있어.','멈추면, 들리지 않을까 봐.'], replies: ['그 잔향이 네 지도를 바꿀 거야.','걷는 침묵은 언제나 열려 있지.'] }
  ];
  let inConvo = false, stepIdx = 0;

  function openRobotConvo() {
    inConvo = true; stepIdx = 0; renderConvoStep(); gameDialog.style.display = 'flex'; SFX.interact();
  }
  function renderConvoStep() {
    dgTitle.textContent = '로봇(비석의 방 순찰)';
    const s = convo[stepIdx];
    dgBody.innerHTML = `<div style="white-space:pre-wrap">${s.npc}</div>`;
    dgChoices.innerHTML = '';
    s.choices.forEach((text, i) => {
      const b = document.createElement('button');
      b.textContent = text;
      b.onclick = () => {
        SFX.select();
        const reply = s.replies[i];
        dgBody.innerHTML += `\n\n> 너: ${text}\n로봇: ${reply}`;
        stepIdx++;
        if (stepIdx < convo.length) {
          setTimeout(() => renderConvoStep(), 420);
        } else {
          dgChoices.innerHTML = '';
          const done = document.createElement('button');
          done.textContent = '끝내기';
          done.onclick = () => { inConvo = false; gameDialog.style.display = 'none'; };
          dgChoices.appendChild(done);
        }
      };
      dgChoices.appendChild(b);
    });
  }

  // 로봇 순찰
  function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
  function randomWalkableTile0() {
    let tx, ty; do { tx = (Math.random() * MAP_W) | 0; ty = (Math.random() * MAP_H) | 0; } while (LEVEL0[ty]?.[tx] !== 0);
    return { tx, ty };
  }
  function bfsPath(level, fromX, fromY, toX, toY) {
    const Q = [[fromX, fromY]], V = new Set([fromX + ',' + fromY]), P = {}, dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const solid = (x, y) => {
      if (x < 0 || y < 0 || x >= MAP_W || y >= MAP_H) return true;
      return level === 0 ? (LEVEL0[y][x] === 1) : (LEVEL1[y][x] === 1 || phoneSet.has(`${x},${y}`));
    };
    while (Q.length) {
      const [x, y] = Q.shift();
      if (x === toX && y === toY) break;
      for (const [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (solid(nx, ny)) continue;
        const k = nx + ',' + ny;
        if (V.has(k)) continue;
        V.add(k); P[k] = [x, y]; Q.push([nx, ny]);
      }
    }
    const key = toX + ',' + toY;
    if (!(key in P) && !(fromX === toX && fromY === toY)) return [];
    let path = [[toX, toY]];
    let cx = toX, cy = toY;
    while (!(cx === fromX && cy === fromY)) {
      const prev = P[cx + ',' + cy]; if (!prev) break;
      path.push(prev); cx = prev[0]; cy = prev[1];
    }
    path.reverse(); return path;
  }

  const seekerObj = {
    ensureTarget(force = false) {
      if (room !== 0 || inConvo) return;
      const now = performance.now();
      if (force || !seeker.target || now > seeker.repathAt || seeker.path.length === 0) {
        let t = randomWalkableTile0(), tries = 0;
        while (dist({ x: t.tx + 0.5, y: t.ty + 0.5 }, player) < 3 && tries++ < 10) t = randomWalkableTile0();
        seeker.target = t;
        const sx = seeker.x | 0, sy = seeker.y | 0;
        seeker.path = bfsPath(0, sx, sy, t.tx, t.ty);
        seeker.repathAt = now + 5000 + Math.random() * 5000;
      }
    },
    step() {
      if (room !== 0 || inConvo) return;
      this.ensureTarget();
      if (seeker.path.length > 0) {
        const [nx, ny] = seeker.path[0], tx = nx + 0.5, ty = ny + 0.5;
        const dx = tx - seeker.x, dy = ty - seeker.y, m = Math.hypot(dx, dy);
        if (m < 0.05) { seeker.x = tx; seeker.y = ty; seeker.path.shift(); }
        else { const ax = dx / m, ay = dy / m; moveEntity(seeker, ax, ay); }
      } else this.ensureTarget(true);
    }
  };

  // 렌더링
  function drawSeeker() {
    if (room !== 0) return;
    const px = Math.round(seeker.x * TILE - TILE / 2), py = Math.round(seeker.y * TILE - TILE / 2);
    og.fillStyle = C.seekerBody; og.fillRect(px+3,py+6,10,6);
    og.fillStyle = '#ffffff'; og.fillRect(px+2,py+4,12,6);
    og.fillStyle = C.seekerEye; og.fillRect(px+5,py+6,2,2); og.fillRect(px+9,py+6,2,2);
    og.fillStyle = '#111'; og.fillRect(px+1,py+8,2,3); og.fillRect(px+13,py+8,2,3);
  }
  function drawPlayer(p) {
    const px = Math.round(p.x * TILE - TILE / 2), py = Math.round(p.y * TILE - TILE / 2);
    og.fillStyle = C.shadow; og.fillRect(px+2,py+TILE-2,TILE-4,2);
    og.fillStyle = C.player; og.fillRect(px+4,py+5,8,7);
    og.fillStyle = C.playerDark; og.fillRect(px+4,py+4,8,2);
    if (((p.anim * 10) | 0) % 20 < 10) { og.fillStyle = '#000'; og.fillRect(px+6,py+7,1,1); og.fillRect(px+9,py+7,1,1); }
  }

  // 루프
  let gameRunning = false, last = 0, gameRAF = 0;
  function gameLoop(t) {
    if (!gameRunning) return;
    gameRAF = requestAnimationFrame(gameLoop);
    const dt = Math.min(32, (t - last) || 16); last = t;
    updateGame(dt / 16); renderGame();
  }

  function updateGame(dt) {
    let ax = 0, ay = 0;
    if (keys.has('a') || keys.has('arrowleft')) ax -= 1;
    if (keys.has('d') || keys.has('arrowright')) ax += 1;
    if (keys.has('w') || keys.has('arrowup')) ay -= 1;
    if (keys.has('s') || keys.has('arrowdown')) ay += 1;
    ax += dpadState.ax; ay += dpadState.ay;
    const m = Math.hypot(ax, ay) || 1; ax /= m; ay /= m;

    const moving = Math.hypot(ax, ay) > 0.1 && !inConvo;
    if (!inConvo) moveEntity(player, ax, ay);
    player.anim += dt;
    if (moving) {
      player.stepTimer += dt * 1000;
      if (player.stepTimer >= 180) { player.stepTimer = 0; SFX.step(player.stepPhase++); }
    } else player.stepTimer = 0;

    seekerObj.step();

    // 방 전환(하단 통로)
    if ((player.y | 0) === MAP_H - 1 && (player.x | 0) >= 6 && (player.x | 0) <= 9) {
      room = room === 0 ? 1 : 0;
      hudRoom.textContent = room === 0 ? 'ROOM: 비석의 방 · 하단 출구 → 전화기의 방' : 'ROOM: 전화기의 방 · 하단 출구 → 비석의 방';
      player.x = 8.5; player.y = 14.2; inConvo = false; gameDialog.style.display = 'none'; dgChoices.innerHTML = '';
      SFX.ui();
    }

    // 상호작용
    let label = '', action = null;
    if (room === 0) {
      if (!inConvo && Math.hypot(player.x - seeker.x, player.y - seeker.y) < 0.85) {
        label = 'E: 로봇과 대화'; action = () => openRobotConvo();
      } else {
        const ng = nearestGrave(player.x, player.y);
        if (ng.grave && ng.dist < 1.1) {
          label = 'E: 비석에 귀 기울이기';
          action = () => {
            SFX.interact();
            dgTitle.textContent = '비석의 기록';
            dgBody.textContent = graveText(ng.grave.x, ng.grave.y);
            dgChoices.innerHTML = '';
            gameDialog.style.display = 'flex';
          };
        }
      }
    } else {
      const np = nearestPhone(player.x, player.y);
      if (np.phone && np.dist < 1.1) {
        label = 'E: 수화기 들기';
        action = () => {
          SFX.ring();
          dgTitle.textContent = '전화기의 방';
          dgBody.textContent = '...여보세요? (침묵 속의 목소리가 미세하게 울린다)';
          dgChoices.innerHTML = '';
          gameDialog.style.display = 'flex';
        };
      }
    }
    if (action) {
      interactHint.style.display = 'block';
      interactHint.textContent = label;
      interactHint.onclick = action;
    } else {
      interactHint.style.display = 'none';
      interactHint.onclick = null;
    }
  }

  function renderGame() {
    og.clearRect(0, 0, REND_W, REND_H);
    og.drawImage(room === 0 ? layer0 : layer1, 0, 0);
    drawSeeker(); drawPlayer(player);

    // 중앙 배치
    g.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    const sx = Math.floor(gameCanvas.width / REND_W), sy = Math.floor(gameCanvas.height / REND_H);
    const scale = Math.max(1, Math.min(sx, sy));
    const dw = REND_W * scale, dh = REND_H * scale, dx = (gameCanvas.width - dw) / 2, dy = (gameCanvas.height - dh) / 2;
    g.imageSmoothingEnabled = false;
    g.drawImage(off, dx, dy, dw, dh);
  }

  // 게임 열기/닫기
  function openGame() {
    hudRoom.textContent = room === 0 ? 'ROOM: 비석의 방 · 하단 출구 → 전화기의 방' : 'ROOM: 전화기의 방 · 하단 출구 → 비석의 방';
    gameOverlay.style.display = 'block';
    dpad.style.display = matchMedia('(pointer: coarse)').matches ? 'grid' : 'none';
    gameRunning = true; last = 0; gameRAF = requestAnimationFrame(gameLoop);
  }
  function closeGame() {
    gameOverlay.style.display = 'none';
    gameRunning = false;
    if (gameRAF) cancelAnimationFrame(gameRAF);
    inConvo = false; gameDialog.style.display = 'none'; interactHint.style.display = 'none';
    clearHeld();
  }

  mapLauncher.addEventListener('click', openGame, { passive: true });
  btnExitGame.addEventListener('click', closeGame, { passive: true });

  // 전역 E키 → 상호작용
  addEventListener('keydown', e => {
    if (!gameRunning) return;
    if (e.key === 'e' || e.key === 'E') {
      if (interactHint.style.display !== 'none') { e.preventDefault(); interactHint.click(); }
    }
  }, { passive: false });

  /* ──────────────────────────────
   * Permission Gate 초기 표시
   * ────────────────────────────── */
  overlayEl.style.display = 'flex';
})();
</script>
</body>
</html>
