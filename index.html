<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Motion Trails (BW)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #view { position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    #hint { position:fixed; left:12px; bottom:12px; color:#fff; font:14px/1.3 system-ui, sans-serif; opacity:.9 }
  </style>
</head>
<body>
  <!-- 비디오는 숨기고, 캔버스만 보여줌 -->
  <video id="video" autoplay playsinline muted style="display:none"></video>
  <canvas id="view"></canvas>
  <div id="hint">tap once if video is paused</div>

  <script>
    // ====== 튜닝 파라미터 ======
    const TRAIL_COUNT = 6;      // 잔상 프레임 개수 (높일수록 잔상 길어짐)
    const ALPHAS = [0.35,0.25,0.18,0.12,0.08,0.05]; // 각 잔상의 투명도(오래된 프레임부터)
    const SCALE = 0.6;          // 내부 처리 해상도 (0.5~0.7 권장: 퍼포먼스↑ 잔상 부드러움↑)
    const JITTER = 1.2;         // 잔상 오프셋 픽셀(살짝 흔들림 효과)
    // ===========================

    const video = document.getElementById('video');
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d', { alpha:false });

    // 잔상 버퍼: 축소 캔버스 재사용
    const trailPool = [];
    let w=0, h=0, sw=0, sh=0, playing=false;

    // iOS/Safari 자동재생 보조
    document.body.addEventListener('click', () => video.play(), { once:true });

    // 카메라 시작
    navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false })
      .then(stream => { video.srcObject = stream; })
      .catch(err => alert('카메라 접근 실패: ' + err.message));

    video.addEventListener('loadedmetadata', () => {
      resize();
      // 풀 해상도 캔버스에 그릴 때 흑백 필터 사용
      ctx.filter = 'grayscale(100%)';
      requestAnimationFrame(loop);
    });

    window.addEventListener('resize', resize);

    function resize(){
      if(!video.videoWidth || !video.videoHeight) return;
      w = canvas.width  = window.innerWidth;
      h = canvas.height = window.innerHeight;

      // 비디오 비율 유지해서 화면 채우기 위한 소스 크기
      const vw = video.videoWidth, vh = video.videoHeight;
      const s = Math.max(w/vw, h/vh);
      sw = Math.round(vw * s);
      sh = Math.round(vh * s);

      // 잔상용 축소 캔버스 풀 준비
      const tw = Math.max(1, Math.round(sw * SCALE));
      const th = Math.max(1, Math.round(sh * SCALE));
      while (trailPool.length < TRAIL_COUNT) {
        const c = document.createElement('canvas');
        c.width = tw; c.height = th;
        trailPool.push(c);
      }
      // 기존 캔버스 크기 업데이트
      trailPool.forEach(c => { c.width = tw; c.height = th; });
    }

    function loop(){
      // 비디오 프레임을 화면 크기에 맞춰 먼저 그림(흑백 필터 적용됨)
      if (sw && sh) {
        const x = (w - sw) >> 1;
        const y = (h - sh) >> 1;
        ctx.drawImage(video, x, y, sw, sh);

        // 최신 프레임을 축소해 trail 버퍼의 맨 뒤에 저장
        const last = trailPool[trailPool.length-1];
        if (last) {
          const tctx = last.getContext('2d');
          tctx.filter = 'grayscale(100%)';
          tctx.drawImage(video, 0, 0, last.width, last.height);
          // 회전시키듯 앞쪽으로 밀기
          trailPool.unshift(trailPool.pop());
        }

        // 이전 프레임들을 낮은 알파로 덧그리기 (잔상)
        for (let i=0; i<trailPool.length; i++){
          const src = trailPool[i];
          if (!src) continue;
          ctx.globalAlpha = (ALPHAS[i] ?? ALPHAS[ALPHAS.length-1] ?? 0.08);
          // 약간의 오프셋을 줘서 흐트러지는 느낌
          const off = (i+1) * (JITTER || 0);
          const x = ((w - sw) >> 1) + off;
          const y = ((h - sh) >> 1) + off;
          ctx.drawImage(src, x, y, sw, sh);
        }
        ctx.globalAlpha = 1;
      }
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
