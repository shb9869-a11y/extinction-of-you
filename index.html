<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Camera – Motion Volume/Pan + Haptics</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="app.webmanifest">

<style>
  :root{
    --frame: 40px; --ui-gap: 8px;
    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --pad-line: clamp(4px, 0.9vmin, 8px);
    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #view{width:100%;height:100%;display:block;position:fixed;left:0;top:0;z-index:0}
  .frameBox{position:fixed;left:var(--frame);top:var(--frame);right:var(--frame);bottom:var(--frame);border:1px solid #000;pointer-events:none;z-index:50}
  .uiBtn{background:#000;color:#fff;border:1px solid #000;font-size:var(--fs-strong);padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;border-radius:0;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
  .controls{position:fixed;right:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small)}
  .btn-capture{position:fixed;left:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:150}
  #overlay{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;padding:20px;font-family:"Courier New",monospace;color:#fff;pointer-events:none}
  #overlayContent{pointer-events:auto;line-height:1.7;font-size:var(--fs-body);max-width:min(72ch, calc(100vw - (var(--frame)*2)));max-height:calc(100vh - (var(--frame)*2));overflow:hidden;text-align:left}
  .line{display:inline;background:#000;color:#fff;padding:calc(var(--pad-line)*0.8) var(--pad-line);box-decoration-break:clone;-webkit-box-decoration-break:clone}
  .lineWrap{margin:6px 0}
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}
  #goodnight{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:250;display:none;text-align:center;font-family:"Courier New",monospace;font-size:var(--fs-strong);color:#fff;background:#000;padding:var(--pad-btn-y) var(--pad-btn-x);white-space:nowrap;transition:opacity .6s ease}
  #goodnight.show{display:block;opacity:1}
  #goodnight.fadeout{opacity:0}
  @media (orientation:landscape){ :root{ --frame: 32px; } }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <!-- 줌 -->
  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.2×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <!-- CAPTURE -->
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <!-- 오버레이 -->
  <div id="overlay" class="fade">
    <div id="overlayContent" class="fade">
      <button id="startBtn" class="uiBtn">PRESS HERE TO SLEEP</button>
    </div>
  </div>

  <!-- GOOD NIGHT -->
  <div id="goodnight">GOOD NIGHT</div>

<script>
(async ()=>{
  /* ========= 카메라(흑백+잔상) ========= */
  const view=document.getElementById('view');
  const vctx=view.getContext('2d',{alpha:false});
  const PROC_SCALE=0.60, TRAIL_ALPHA=0.12, GLOBAL_ALPHA=0.7;
  let ZOOM=1.2, ZOOM_MIN=0.5, ZOOM_MAX=3.0, ZOOM_STEP=0.1;

  const zoomVal=document.getElementById('zoomVal');
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const updateZoom=()=>zoomVal.textContent=ZOOM.toFixed(1)+'×';
  document.getElementById('zoomIn').onclick=()=>{ZOOM=clamp(ZOOM+ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  document.getElementById('zoomOut').onclick=()=>{ZOOM=clamp(ZOOM-ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  updateZoom();

  const camVideo=document.createElement('video');
  camVideo.autoplay=true; camVideo.playsInline=true; camVideo.muted=true;
  const proc=document.createElement('canvas');
  const pctx=proc.getContext('2d',{willReadFrequently:true});

  async function attachCamera(){
    try{
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
      camVideo.srcObject=s; await camVideo.play().catch(()=>{});
    }catch(e){console.error("카메라 실패:", e);}
  }

  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth,h=window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale = (window.matchMedia('(orientation: landscape)').matches) ? PROC_SCALE*0.9 : PROC_SCALE;
    proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale);
  }
  resizeAll(); addEventListener('resize',()=>setTimeout(resizeAll,50));

  function loop(){
    requestAnimationFrame(loop);
    const W=view.width/(window.devicePixelRatio||1);
    const H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;

    pctx.globalCompositeOperation="source-over";
    pctx.fillStyle=`rgba(0,0,0,${TRAIL_ALPHA})`; pctx.fillRect(0,0,PW,PH);

    if(camVideo.readyState>=2){
      const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
      if(vw && vh){
        const base=Math.max(PW/vw,PH/vh), sc=base*ZOOM;
        const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
        pctx.globalAlpha=GLOBAL_ALPHA; pctx.drawImage(camVideo,dx,dy,dw,dh);
        pctx.globalAlpha=1.0;
        const frame=pctx.getImageData(0,0,PW,PH); const d=frame.data;
        for(let i=0;i<d.length;i+=4){
          const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;
        }
        pctx.putImageData(frame,0,0);
      }
    }
    vctx.drawImage(proc,0,0,W,H);
  }
  await attachCamera(); loop();

  /* ========= 오디오(드론) + 기울기 매핑 + 햅틱 ========= */
  let audioCtx=null, masterGain=null;
  let bgOsc=null, bgGain=null, panner=null;
  let hapticTimer=null;

  // 파라미터(감도/범위/평활)
  const VOL_BASE=0.12;               // 기본 볼륨
  const VOL_MAX_ADD=0.5;             // 추가 볼륨 최대치
  const VOL_TILT_LIMIT=60;           // |pitch(β)| 0~60도 구간 사용
  const PAN_LIMIT_DEG=45;            // |roll(γ)| 0~45도 → -1..+1로 매핑
  const SMOOTH_TC=0.06;              // setTargetAtTime time-constant (초) → 지지직 완화
  const CTRL_SMOOTH_ALPHA=0.12;      // 1차 저역통과용 알파(값 작을수록 부드러움)
  const DEADZONE_VOL_DEG=5;          // 볼륨 데드존(미세 흔들림 무시)
  const DEADZONE_PAN_DEG=3;          // 패닝 데드존

  // 최신 기울기(orientation) 이벤트 값을 저장하고, RAF에서만 적용(스로틀링)
  let latestOri = {beta:0, gamma:0}; // pitch/front-back, roll/left-right
  function getScreenAngle(){
    const o = (screen.orientation && screen.orientation.angle)??window.orientation??0;
    // iOS는 90 / -90 / 0 / 180
    return (typeof o==='number') ? o : 0;
  }

  // 스크린 회전에 따른 축 보정: (β,γ) → (volTilt, panTilt)
  function mapOrientation(beta, gamma){
    const ang = ((getScreenAngle()%360)+360)%360; // 0,90,180,270
    let volTilt=0, panTilt=0;
    if(ang===0){            // 세로(기본)
      volTilt = beta;       // 위/아래 = 볼륨
      panTilt = gamma;      // 좌/우 = 패닝
    }else if(ang===90){     // 가로(우로 회전)
      volTilt = -gamma;
      panTilt = beta;
    }else if(ang===180){    // 뒤집힌 세로
      volTilt = -beta;
      panTilt = -gamma;
    }else if(ang===270){    // 가로(좌로 회전)
      volTilt = gamma;
      panTilt = -beta;
    }
    return {volTilt, panTilt};
  }

  // 데드존 + 범위 맵핑
  function tiltToVolume(volTilt){
    const t = Math.min(VOL_TILT_LIMIT, Math.max(-VOL_TILT_LIMIT, volTilt||0));
    const a = Math.max(0, Math.abs(t) - DEADZONE_VOL_DEG) / (VOL_TILT_LIMIT - DEADZONE_VOL_DEG);
    return VOL_BASE + VOL_MAX_ADD * a; // 0.12 ~ 0.62
  }
  function tiltToPan(panTilt){
    const t = Math.min(PAN_LIMIT_DEG, Math.max(-PAN_LIMIT_DEG, panTilt||0));
    const s = Math.max(-1, Math.min(1,
      (Math.abs(t) < DEADZONE_PAN_DEG) ? 0 : (t / PAN_LIMIT_DEG)
    ));
    return s; // -1..+1
  }

  // 제어용 저역통과
  let smVol=VOL_BASE, smPan=0;
  function smoothStep(target, current, alpha=CTRL_SMOOTH_ALPHA){
    return current + (target - current) * alpha;
  }

  function initAudio(){
    if(audioCtx) return;
    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value=0.7;
      panner = (audioCtx.createStereoPanner) ? audioCtx.createStereoPanner() : audioCtx.createGain();
      if(panner.pan===undefined) panner.pan={ value:0, setTargetAtTime: ()=>{} }; // 대체
      panner.connect(masterGain); masterGain.connect(audioCtx.destination);
    }catch(e){ console.warn('Audio init 실패:', e); }
  }

  function startDrone(){
    if(!audioCtx || bgOsc) return;
    bgOsc = audioCtx.createOscillator();
    bgGain = audioCtx.createGain();
    bgOsc.type='sine';
    bgOsc.frequency.value=55; // 낮은 드론
    // 팝 방지
    bgGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    bgGain.gain.setTargetAtTime(VOL_BASE, audioCtx.currentTime, 0.25);

    bgOsc.connect(bgGain).connect(panner);
    bgOsc.start();
  }

  // 지지직 최소화를 위해 AudioParam은 setTargetAtTime으로 천천히 수렴
  function applyAudioParams(vol, pan){
    if(!audioCtx||!bgGain||!panner) return;
    const now = audioCtx.currentTime;
    try{
      bgGain.gain.setTargetAtTime(vol, now, SMOOTH_TC);
    }catch(e){
      // 일부 구현에서 setTargetAtTime 미지원 시 폴백
      bgGain.gain.cancelScheduledValues(now);
      bgGain.gain.linearRampToValueAtTime(vol, now + 0.08);
    }
    if(panner.pan && typeof panner.pan.setTargetAtTime==='function'){
      panner.pan.setTargetAtTime(pan, now, SMOOTH_TC);
    }else if(panner.gain){ // 구형 대체(완전한 패닝은 불가)
      // 모노 유지(무시)
    }
  }

  // 지속 햅틱(노터치)
  function startHapticsPulse(intervalMs=600, burstMs=35){
    stopHapticsPulse();
    if('vibrate' in navigator){
      hapticTimer=setInterval(()=>navigator.vibrate(burstMs), intervalMs);
    }
  }
  function stopHapticsPulse(){
    if(hapticTimer){ clearInterval(hapticTimer); hapticTimer=null; }
    if('vibrate' in navigator){ navigator.vibrate(0); }
  }

  // 자동 시작 루프(브라우저 정책 회피용)
  function autoStart(){
    initAudio();
    if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
    startDrone();
    startHapticsPulse(600,35);
  }
  autoStart();
  document.addEventListener('visibilitychange', autoStart);
  window.addEventListener('focus', autoStart);
  setInterval(autoStart, 3000);

  // orientation 이벤트 수집(이벤트 핸들러에서는 값만 저장)
  if(typeof DeviceOrientationEvent!=='undefined'){
    if(typeof DeviceOrientationEvent.requestPermission==='function'){
      DeviceOrientationEvent.requestPermission().catch(()=>{});
    }
    window.addEventListener('deviceorientation', (e)=>{
      latestOri.beta = e.beta ?? 0;
      latestOri.gamma = e.gamma ?? 0;
    }, {passive:true});
  }

  // 제어 적용은 RAF에서만(스로틀 + 평활화로 지지직 방지)
  function controlLoop(){
    requestAnimationFrame(controlLoop);
    // 축 보정
    const {volTilt, panTilt} = mapOrientation(latestOri.beta, latestOri.gamma);
    // 목표값
    const volTarget = tiltToVolume(volTilt);
    const panTarget = tiltToPan(panTilt);
    // 저역통과
    smVol = smoothStep(volTarget, smVol);
    smPan = smoothStep(panTarget, smPan);
    // 오디오 매개변수 적용(부드럽게)
    applyAudioParams(smVol, smPan);
  }
  controlLoop();

  // 버튼/틱(저역 성향)
  function playClick(){
    if(!audioCtx) return;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='sine'; o.frequency.setValueAtTime(200,audioCtx.currentTime);
    g.gain.setValueAtTime(0.3,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.22);
    o.connect(g).connect(masterGain); o.start(); o.stop(audioCtx.currentTime+0.24);
  }
  function playTick(){
    if(!audioCtx) return;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='square'; o.frequency.value=420; g.gain.value=0.16;
    o.connect(g).connect(masterGain); o.start();
    g.gain.setValueAtTime(0.16,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.07);
    o.stop(audioCtx.currentTime+0.09);
  }

  /* ========= 오버레이/카운트다운 ========= */
  const overlay=document.getElementById('overlay');
  const overlayContent=document.getElementById('overlayContent');
  const startBtn=document.getElementById('startBtn');
  const goodnight=document.getElementById('goodnight');
  const captureBtn=document.getElementById('captureBtn');

  function crossfadeUpdate(html,nextAction){
    overlayContent.classList.add('hidden');
    setTimeout(()=>{ overlayContent.innerHTML=html; overlayContent.classList.remove('hidden'); nextAction&&nextAction(); },450);
  }
  function showGoodNight15s(){
    goodnight.classList.add('show');
    setTimeout(()=>{ goodnight.classList.add('fadeout');
      setTimeout(()=>{ goodnight.classList.remove('show','fadeout'); goodnight.style.display='none'; },600);
    },15000);
  }

  startBtn.addEventListener('click', ()=>{
    autoStart(); playClick();
    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    const introHTML = `
      ${line('<b>INTRODUCTION</b>')}
      ${line('1. 이곳은 이미 ‘너’가 죽어버린, ‘그것’들의 세계다.')}
      ${line('2. 곧 당신은 30분간의 잠에 들며, 무의식 속 여정을 시작한다.')}
      ${line('3. 그 여정 속에서 당신은 사라져간 ‘너’를 마주하게 된다.')}
      ${line('4. 이제 당신에게는 네 단계의 미션이 주어진다.')}
      ${line('5. 미션에 따라 ‘너’들의 목소리에 귀 기울이며, 휴대폰으로 잃어버린 ‘너’를 포착하라.')}
      <div id="countdown" class="lineWrap">
        <span class="line">THE DOOR WILL OPEN IN <span id="countNum">60</span> SECONDS.</span>
      </div>
    `;
    crossfadeUpdate(introHTML, ()=>{
      let count = 60; const numEl = document.getElementById('countNum');
      const timer = setInterval(()=>{
        count--;
        if(count>=0){ numEl.textContent=count; playTick(); }
        if(count<=0){
          clearInterval(timer);
          overlay.classList.add('hidden');
          setTimeout(()=>{overlay.style.display='none'; showGoodNight15s();},450);
        }
      },1000);
    });
  });

  captureBtn.addEventListener('click',()=>{
    playClick(); if('vibrate' in navigator){ navigator.vibrate(30); }
    try{ const a=document.createElement('a'); a.download=`capture_${Date.now()}.png`; a.href=view.toDataURL('image/png'); a.click(); }
    catch(e){ console.warn('CAPTURE 실패', e); }
  });

})();
</script>
</body>
</html>
