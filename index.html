<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Camera – BW + Trail + Frame</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #view{
    position:fixed; inset:0; width:100%; height:100%;
    background:#000; touch-action:none;
  }
  #start{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:12px 18px; border:0; border-radius:999px;
    font:700 16px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#fff; background:#12a150; z-index:10; display:none;
  }
  #hint{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    color:#fff; background:rgba(0,0,0,.55); padding:8px 12px; border-radius:8px;
    font:13px/1.3 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; display:none;
  }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <button id="start">카메라 시작</button>
  <div id="hint">iOS 권한/자동재생 때문에 버튼이 필요할 수 있어요</div>

<script>
(async ()=>{
  const view = document.getElementById('view');
  const vctx = view.getContext('2d', { alpha:false });
  const startBtn = document.getElementById('start');
  const hint = document.getElementById('hint');

  // 🎛️ 조절값
  const PROC_SCALE = 0.6;     // 내부 처리 해상도 스케일
  const TRAIL_ALPHA = 0.03;   // 잔상 길이 (작을수록 더 오래 남음)
  const FRAME_MARGIN = 40;    // 흰색 점선 프레임과 화면 사이 여백(px)

  const camVideo = document.createElement('video');
  camVideo.autoplay = true; camVideo.playsInline = true; camVideo.muted = true;

  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', { alpha:false });

  function resizeAll(){
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(1, Math.floor(window.innerWidth));
    const h = Math.max(1, Math.floor(window.innerHeight));

    view.style.width = w+'px'; view.style.height = h+'px';
    view.width = Math.floor(w * dpr); view.height = Math.floor(h * dpr);
    vctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    proc.width  = Math.max(1, Math.floor(w * PROC_SCALE));
    proc.height = Math.max(1, Math.floor(h * PROC_SCALE));
  }
  window.addEventListener('resize', resizeAll);
  window.addEventListener('orientationchange', ()=>setTimeout(resizeAll, 200));
  resizeAll();

  function drawCover(video, ctx, w, h){
    const vw = video.videoWidth || 0, vh = video.videoHeight || 0;
    if (!vw || !vh) return;
    const scale = Math.max(w / vw, h / vh);
    const dw = vw * scale, dh = vh * scale;
    const dx = (w - dw) / 2, dy = (h - dh) / 2;
    ctx.drawImage(video, dx, dy, dw, dh);
  }

  async function attachCamera(){
    try{
      const s = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ ideal:'environment' } }, audio:false
      });
      camVideo.srcObject = s;
      await camVideo.play();
    }catch(e){
      const s2 = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      camVideo.srcObject = s2;
      await camVideo.play();
    }
  }

  let rafId = 0;
  function loop(){
    rafId = requestAnimationFrame(loop);

    const W = view.width / (window.devicePixelRatio||1);
    const H = view.height / (window.devicePixelRatio||1);
    const PW = proc.width, PH = proc.height;

    // 1) 잔상 페이드
    pctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
    pctx.fillRect(0,0,PW,PH);

    // 2) 카메라 그리기
    if (camVideo.readyState >= 2){
      const vw = camVideo.videoWidth || 0, vh = camVideo.videoHeight || 0;
      if (vw && vh){
        const scale = Math.max(PW / vw, PH / vh);
        const dw = vw * scale, dh = vh * scale;
        const dx = (PW - dw) / 2, dy = (PH - dh) / 2;
        pctx.drawImage(camVideo, dx, dy, dw, dh);
      }

      // 흑백 변환
      let frame = pctx.getImageData(0,0,PW,PH);
      let d = frame.data;
      for (let i=0; i<d.length; i+=4){
        const r=d[i], g=d[i+1], b=d[i+2];
        const gray = (0.299*r + 0.587*g + 0.114*b)|0;
        d[i]=d[i+1]=d[i+2]=gray;
      }
      pctx.putImageData(frame,0,0);
    }

    // 3) 처리용 → 메인 캔버스 업스케일
    vctx.drawImage(proc, 0, 0, W, H);

    // 4) 흰색 점선 프레임
    vctx.save();
    vctx.strokeStyle = "white";
    vctx.lineWidth = 3;
    vctx.setLineDash([12, 8]); // 점선 패턴
    vctx.strokeRect(FRAME_MARGIN, FRAME_MARGIN, W-2*FRAME_MARGIN, H-2*FRAME_MARGIN);
    vctx.restore();
  }

  async function startAll(){
    try{
      await attachCamera();
      startBtn.style.display = 'none';
      hint.style.display = 'none';
      if (!rafId) loop();
    }catch(e){
      startBtn.style.display = 'inline-block';
      hint.style.display = 'block';
    }
  }

  startBtn.addEventListener('click', startAll, { once:true });
  startAll();

  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden){
      camVideo.play().catch(()=>{});
    }
  });
})();
</script>
</body>
</html>
