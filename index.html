<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>SLEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEP</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEEEEP">
<meta name="theme-color" content="#000000">

<style>
  :root{
    --appH: 100svh;
    --frame: clamp(16px, 4vmin, 40px);
    --ui-gap: 8px;

    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --fs-name: clamp(16px,3.2vmin,22px);

    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);

    --safe-t: env(safe-area-inset-top, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);

    --dialogue-offset-vh: 8vh;
    --char-offset-vh: 16vh;
  }

  html,body{margin:0;height:var(--appH);background:#000;overflow:hidden;touch-action:manipulation}
  body{
    font-family:Impact,"Anton","Arial Black",system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans KR",sans-serif;
    -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
  }
  *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
  input, textarea{ -webkit-user-select:text; user-select:text; }

  .fade{opacity:0; transition:opacity 1800ms ease}
  .fade.show{opacity:1}

  /* 배경 카메라 */
  #view{position:fixed;left:0;top:0;width:100%;height:var(--appH);display:block;z-index:0}

  /* ✅ 전면 레이어(풀+캐릭터+말풍선) — 대화창보다 ‘무조건’ 위 */
  #fg{position:fixed;left:0;top:0;width:100%;height:var(--appH);display:block;z-index:880;pointer-events:none}

  #freezeLayer{position:fixed;inset:0;z-index:500;display:none}

  .frameBox{
    position:fixed;
    left:calc(var(--frame) + var(--safe-l));
    top:calc(var(--frame) + var(--safe-t));
    right:calc(var(--frame) + var(--safe-r));
    bottom:calc(var(--frame) + var(--safe-b));
    border:2px solid rgba(255,255,255,.22); pointer-events:none; z-index:50;
  }

  .uiBtn{background:transparent;color:#fff;border:none;font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",ui-monospace,monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc( var(--pad-btn-x)*0.6)}
  .uiBtn.flat{border:none;background:transparent;text-decoration:none}
  .uiBtn[disabled]{opacity:.35;pointer-events:none;filter:grayscale(1)}
  .hide{display:none !important;}

  .controls{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:400;display:flex;gap:6px;align-items:center; opacity:0; transition:opacity 1800ms ease;}
  .controls.show{opacity:1}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",ui-monospace,monospace;font-size:var(--fs-small);color:#ddd}

  .btn-capture{
    position:fixed;
    left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:450; opacity:0; transition:opacity 1800ms ease;}
  .btn-capture.show{opacity:1}

  #mapLauncher, #docLauncher, #audioToggle { display:none; }

  #runTimer{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
    z-index:460;
    font-family:"Courier New",ui-monospace,monospace;
    font-size:var(--fs-strong);
    color:#fff; opacity:.95;
    pointer-events:none; user-select:none;
    display:none;
  }

  .credits{ font-family:"Courier New",ui-monospace,monospace; letter-spacing:.08em; }

  #rotateOverlay{
    position:fixed; inset:0; z-index:1000; display:none;
    align-items:center; justify-content:center; text-align:center;
    background:#000; color:#fff; padding:40px; font-family:"Courier New",ui-monospace,monospace;
    pointer-events:auto;
  }

  /* Gate */
  #overlay{position:fixed;inset:0;z-index:300;display:flex;align-items:center;justify-content:center;padding:calc(20px + var(--safe-t)) calc(20px + var(--safe-r)) calc(20px + var(--safe-b)) calc(20px + var(--safe-l));color:#fff;background:rgba(0,0,0,.85); pointer-events:auto;}
  #overlayContent{max-width:min(92vw, 72ch);font-family:"Courier New",ui-monospace,monospace;line-height:1.7;text-align:center}
  .gateLine{display:inline-block;font-family:"Courier New",ui-monospace,monospace;font-size:var(--fs-strong);border:none;background:transparent;color:#fff;cursor:pointer;padding:6px 10px;width:100%}
  .gateHint{opacity:.7;margin-top:6px}

  /* Name */
  #nameOverlay{position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.85); color:#fff;}
  #nameCard{ width:min(92vw,600px); text-align:center; font-family:"Courier New",ui-monospace,monospace; }
  #nameCard h2{ margin:0 0 12px 0; letter-spacing:.08em; font-size:var(--fs-name); font-weight:400; }
  #nick{ width:100%; padding:12px 14px; background:#000; border:1px solid #555; color:#fff; font-size:var(--fs-name); outline:none; }
  #nameRow{ display:flex; gap:10px; margin-top:12px; justify-content:center; }
  #nameRow .uiBtn{ padding:10px 14px; }
  #nameRow .uiBtn.flat{ font-family:"Courier New",ui-monospace,monospace; font-size:var(--fs-name); font-weight:400; }

  /* Preset */
  #preset{position:fixed;inset:0;z-index:250;background:#000;display:none;cursor:pointer}
  #presetCanvas{position:absolute;left:0;top:0;width:100%;height:100%}

  /* Welcome */
  #overlayWelcome{
    position:fixed; inset:0; z-index:220;
    display:none; place-items:center;
    color:#fff;background:rgba(0,0,0,.55);
    padding:0;
  }
  #welcomeCard{
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    width:100%; max-width:min(92vw, 900px); margin:0 auto; text-align:center;
    padding:calc(20px + var(--safe-t)) 20px calc(20px + var(--safe-b)) 20px;
  }
  #welcomeCard .title{ font-size:clamp(32px, 12vmin, 120px); font-weight:900; letter-spacing:.04em; line-height:1.02; margin:0 0 6px 0; text-transform:uppercase; }
  #goIntro{ margin-top:10px; }

  /* Intro title */
  #introBig{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; pointer-events:none; z-index:210;}
  #introBigText{ color:#fff; font-weight:900; letter-spacing:.06em; font-size:clamp(48px, 22vmin, 260px); text-transform:uppercase; text-align:center; white-space:nowrap; text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7); padding:0 .02em; }

  /* ⬇️ 대화 패널은 의도적으로 낮게 (풀 레이어보다 아래) */
  #dialogueWrap{
    position:fixed; left:calc(var(--frame) + var(--safe-l)); right:calc(var(--frame) + var(--safe-r));
    bottom:0; z-index:230;
    transform: translateY(calc(-1 * var(--dialogue-offset-vh)));
    display:none; pointer-events:none;
  }
  #dialogueBox{
    width:100%; max-width:1200px; margin:0 auto;
    background:#000; color:#fff;
    border:1px solid rgba(255,255,255,.25); border-bottom:none;
    padding:14px 16px;
    font-family:"Courier New",ui-monospace,monospace; line-height:1.7;
    min-height:calc(var(--frame) + var(--safe-b) + var(--dialogue-offset-vh));
    box-shadow:0 -10px 30px rgba(0,0,0,.35) inset;
  }
  #dialogueHeader{ opacity:.9; font-size:clamp(12px, 2.2vmin, 15px); letter-spacing:.08em; margin-bottom:6px; }
  #dialogueText{ font-size:clamp(14px, 2.6vmin, 19px); min-height:3lh; }

  /* First Sleep (풀보다 위로 올릴 필요 없으면 850 아래 유지 가능) */
  #firstSleep{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; pointer-events:none; z-index:850; }
  #firstSleepText{
    color:#fff; font-weight:900; letter-spacing:.06em;
    font-size:clamp(48px, 22vmin, 260px);
    text-transform:uppercase; text-align:center; white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    padding:0 .02em;
  }

  /* NOTICE 팝업(최상단 유지) */
  #noticePopup{
    position:fixed; inset:0; z-index:900; display:none;
    align-items:center; justify-content:center; background:rgba(0,0,0,.72);
  }
  #noticeCard{
    width:min(92vw, 640px);
    background:#0b0b0b; color:#fff; border:1px solid #333;
    padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.6);
    font-family:"Courier New",ui-monospace,monospace; line-height:1.7;
  }
  #noticeCard h3{ margin:0 0 6px 0; letter-spacing:.06em; font-weight:700; font-size:clamp(15px,3vmin,20px); }
  #noticeCard p{ margin:4px 0; font-size:clamp(12px,2.4vmin,16px); }
  #noticeActions{ margin-top:10px; text-align:right; }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <!-- ✅ 풀/캐릭터/말풍선 레이어 -->
  <canvas id="fg"></canvas>

  <canvas id="freezeLayer"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <button id="docLauncher" class="uiBtn small">DOCUMENT</button>
  <button id="mapLauncher" class="uiBtn small">MAP</button>
  <button id="audioToggle" class="uiBtn small">AUDIO</button>
  <div id="runTimer" aria-live="polite">08:00</div>

  <div id="rotateOverlay" aria-live="polite">
    <div>
      <b>Landscape mode required</b><br/>
      Please rotate your device to landscape to continue.
    </div>
  </div>

  <!-- Gate -->
  <div id="overlay" class="fade show">
    <div id="overlayContent">
      <div class="credits" style="margin-bottom:10px;">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <button id="permGateBtn" class="gateLine" type="button">
        Tap anywhere to allow Camera, Microphone & Motion sensors
      </button>
      <div class="gateHint">After allowing, you'll move to the name screen.</div>
    </div>
  </div>

  <!-- Name -->
  <div id="nameOverlay" class="fade">
    <div id="nameCard">
      <h2>TELL ME YOUR NAME</h2>
      <input id="nick" type="text" maxlength="24" placeholder="Type your nickname" autocomplete="off" />
      <div id="nameRow">
        <button id="nameSubmit" class="uiBtn flat" type="button">GO</button>
      </div>
    </div>
  </div>

  <!-- Preset -->
  <div id="preset" class="fade" title="Tap to continue">
    <canvas id="presetCanvas"></canvas>
  </div>

  <!-- Welcome -->
  <div id="overlayWelcome" class="fade">
    <div id="welcomeCard">
      <div class="credits" style="margin-bottom:12px;">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <div class="title">SLEEEEEEEEEEEEEEEEEEEEEEEEEP,</div>
      <div class="title">SLEEEEEEEEEEEEEEEEEEEEEEEEEP</div>
      <button id="goIntro" class="uiBtn flat" type="button">PRESS HERE TO SLEEP</button>
    </div>
  </div>

  <!-- INTRODUCTION -->
  <div id="introBig" class="fade"><div id="introBigText">INTRODUCTION</div></div>

  <!-- 인트로 대화 패널 (아래로 두기) -->
  <div id="dialogueWrap">
    <div id="dialogueBox">
      <div id="dialogueHeader">VOICE:</div>
      <div id="dialogueText" aria-live="polite"></div>
    </div>
  </div>

  <!-- THE FIRST SLEEP -->
  <div id="firstSleep"><div id="firstSleepText">THE FIRST SLEEP</div></div>

  <!-- NOTICE Popup -->
  <div id="noticePopup" class="fade" role="dialog" aria-modal="true" aria-labelledby="noticeTitle">
    <div id="noticeCard">
      <h3 id="noticeTitle">NOTICE</h3>
      <p>※ “THE FIRST SLEEP”은 눈으로 타자를 인식해 나가는 챕터입니다.</p>
      <p>※ 앞으로 당신의 태블릿 위로 타자와 몇가지 흔적들이 텍스트로 제시될 것입니다.</p>
      <p>※ 당신은 내면 세계의 탐험가로써 그 흔적들을 화면 아래 ‘CAPTURE’와 ‘+’, ‘-’버튼을 눌러 포착하세요.</p>
      <p>※ 확인하셨다면, 아래 ‘OK’버튼을 눌러주세요</p>
      <div id="noticeActions">
        <button id="noticeOk" class="uiBtn flat" type="button">OK</button>
      </div>
    </div>
  </div>

<script>
(() => {
  /* — 기존 로직 동일 —
     변경 핵심: CSS에서 #fg(z-index:880)로 올림, #dialogueWrap(z-index:230)로 내림.
     아래 스크립트는 이전 버전과 동일하게 동작합니다. */

  (function injectManifest(){
    const manifest = {"name":"SLEEEEEP","short_name":"SLEEEEEP","display":"standalone","start_url":"./","background_color":"#000","theme_color":"#000","icons":[]};
    const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:"application/manifest+json"}));
    const link = document.createElement('link'); link.rel='manifest'; link.href=url; document.head.appendChild(link);
  })();

  const FADE = 1800;
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const qs = s => document.querySelector(s);
  const nextFrame = () => new Promise(resolve=>requestAnimationFrame(()=>resolve()));

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  function fadeShow(el, dur=FADE, display='flex'){
    el.style.display=display; el.style.opacity='0';
    el.style.transition=`opacity ${dur}ms ease`;
    requestAnimationFrame(()=> el.style.opacity='1');
  }
  function fadeHide(el, dur=FADE){
    el.style.transition=`opacity ${dur}ms ease`;
    el.style.opacity='0';
    setTimeout(()=>{ el.style.display='none'; }, dur);
  }

  function setAppH(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH(); addEventListener('resize', setAppH, {passive:true});
  if (window.visualViewport){ visualViewport.addEventListener('resize', ()=>setTimeout(setAppH,50)); }

  const rotateOverlay = document.getElementById('rotateOverlay');
  function isPortrait(){
    const vv = window.visualViewport;
    const w = vv ? vv.width : innerWidth;
    const h = vv ? vv.height : innerHeight;
    return h > w;
  }
  function updateRotateOverlay(){ rotateOverlay.style.display = isPortrait() ? 'flex' : 'none'; }
  ['load','pageshow','resize','orientationchange','visibilitychange'].forEach(ev=>{
    addEventListener(ev, updateRotateOverlay, {passive:true});
  });
  updateRotateOverlay();

  const overlay = qs('#overlay');
  const permBtn = qs('#permGateBtn');
  const nameOverlay = qs('#nameOverlay');
  const nickInput = qs('#nick');
  const nameSubmit = qs('#nameSubmit');
  const preset = qs('#preset');
  const presetCanvas = qs('#presetCanvas');
  const welcome = qs('#overlayWelcome');
  const goIntroBtn = qs('#goIntro');

  const introBig = qs('#introBig');
  const introBigText = qs('#introBigText');

  const dialogueWrap = qs('#dialogueWrap');
  const dialogueText = qs('#dialogueText');

  const firstSleep = qs('#firstSleep');
  const firstSleepText = qs('#firstSleepText');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');
  const view = qs('#view');
  const fg = qs('#fg');
  const freezeLayer = qs('#freezeLayer');
  const runTimer = qs('#runTimer');

  const noticePopup = qs('#noticePopup');
  const noticeOk = qs('#noticeOk');
  const noticeCard = qs('#noticeCard');

  let vctx = null, pctx = null, proc = null;
  let fgctx = null;

  let camPermGranted = false;
  let camStream = null, camVideo = null, ZOOM = 1.0;
  let animStarted = false, capturing = false;
  let ROTATE_FORCE = false;
  let warmupFrames = 0;

  let showIntroLayer = false;
  let fgAlpha = 1.0;

  let audioCtx = null;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  async function ensureResumed(){ try{ ensureAudio(); if(audioCtx.state==='suspended') await audioCtx.resume(); }catch{} }

  async function playWoongClick(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type='sine';
      o.frequency.setValueAtTime(180, now);
      o.frequency.exponentialRampToValueAtTime(70, now+0.32);
      f.type='lowpass'; f.frequency.setValueAtTime(1400, now); f.Q.value=0.7;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.8, now+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.55);
      o.connect(f).connect(g).connect(audioCtx.destination);
      o.start(); o.stop(now+0.58);
    }catch(e){}
  }
  async function playTduung(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const comp = audioCtx.createDynamicsCompressor();
      comp.threshold.value=-18; comp.knee.value=24; comp.ratio.value=3; comp.attack.value=0.004; comp.release.value=0.18;
      o1.type='sine'; o2.type='sine';
      o1.frequency.setValueAtTime(90, now);
      o2.frequency.setValueAtTime(45, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(1.0, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
      o1.connect(g); o2.connect(g); g.connect(comp).connect(audioCtx.destination);
      o1.start(); o2.start(); o1.stop(now+0.62); o2.stop(now+0.62);
    }catch(e){}
  }
  function typeTick(){
    try{
      ensureAudio();
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='square'; o.frequency.value=900;
      g.gain.value=0.0001;
      g.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.10);
      o.connect(g).connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime+0.12);
    }catch(e){}
  }

  function updateZoomLabel(){ zoomVal.textContent = ZOOM.toFixed(1)+'×'; }
  updateZoomLabel();
  zoomIn.addEventListener('click', async ()=>{ ZOOM=Math.min(3.0, ZOOM+0.05); updateZoomLabel(); await playWoongClick(); }, {passive:true});
  zoomOut.addEventListener('click', async ()=>{ ZOOM=Math.max(0.35, ZOOM-0.05); updateZoomLabel(); await playWoongClick(); }, {passive:true});

  async function immediateGestureStart(e){
    e && e.preventDefault && e.preventDefault();
    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().catch(()=>{});
      }
    }catch(_) {}
    ensureAudio(); await ensureResumed(); playWoongClick();

    navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:'environment'},
        width:{min:1280, ideal:1920},
        height:{min:720,  ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}
    })
    .then(s=>{
      s.getTracks().forEach(t=>t.stop());
      camPermGranted = true;
    })
    .catch(err=>{ console.warn('permission error:', err); })
    .finally(()=>{
      fadeHide(overlay, FADE);
      Ambient.start(0.8, 1.0);
      fadeShow(nameOverlay, FADE);
      setTimeout(()=>nickInput && nickInput.focus && nickInput.focus(), 60);
    });
  }
  ['click','touchstart','pointerdown'].forEach(type=>{
    permBtn.addEventListener(type, immediateGestureStart, {passive:false});
    overlay.addEventListener(type, immediateGestureStart, {passive:false});
    window.addEventListener(type, (ev)=>{
      if(getComputedStyle(overlay).display !== 'none'){ immediateGestureStart(ev); }
    }, {passive:false});
  });

  let displayName = '____';
  async function acceptName(){
    const v = (nickInput.value||'').trim();
    if(v.length>0){ displayName = v; }
    await ensureResumed();
    await playWoongClick();
    fadeHide(nameOverlay, FADE);
    showPreset();
  }
  nameSubmit.addEventListener('click', acceptName, {passive:true});
  nickInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ acceptName(); }});

  async function enforceLandscapeConstraints(){
    try{
      if(!camStream) return;
      const track = camStream.getVideoTracks()[0];
      if(!track) return;
      const s = track.getSettings ? track.getSettings() : {};
      const inLandscape = !isPortrait();
      if(inLandscape && s.height && s.width && s.height > s.width){
        await track.applyConstraints({
          advanced:[ { aspectRatio: 16/9 }, { width:{min:1280} }, { height:{max:1080} } ]
        }).catch(()=>{});
      }
    }catch(e){ console.warn(e); }
  }
  addEventListener('orientationchange', ()=>setTimeout(enforceLandscapeConstraints, 300), {passive:true});
  addEventListener('resize', ()=>setTimeout(enforceLandscapeConstraints, 300), {passive:true});

  let saverObjs = []; let saverMode = 'scatter'; let saverT0 = 0;
  const presetClick = async ()=>{
    await playWoongClick();
    fadeHide(preset, FADE);
    await startCameraFresh(false);
    fadeShow(welcome, FADE);
  };
  function showPreset(){
    preset.style.display='block'; preset.classList.add('show');
    fadeShow(preset, FADE);
    initSaver();
    startCameraFresh(true);
  }
  function initSaver(){
    const w = preset.clientWidth, h = preset.clientHeight;
    saverObjs = [];
    const letters = ['S','L','E','E','P'];
    for(let i=0;i<20;i++){
      saverObjs.push({
        ch: letters[i%5],
        x: Math.random()*w, y: Math.random()*h,
        vx: (Math.random()*1.2+0.3) * (Math.random()<.5?-1:1),
        vy: (Math.random()*1.2+0.3) * (Math.random()<.5?-1:1),
        phase: Math.random()*Math.PI*2,
        size: Math.floor(Math.random()*60)+90
      });
    }
    saverT0 = performance.now();
    requestAnimationFrame(saverLoop);
  }
  function saverTargetsForWord(){
    const w = preset.clientWidth, h = preset.clientHeight;
    const base = Math.min(w,h)*0.55;
    const cx = w/2, cy = h/2;
    const spacing = base/5;
    const left = cx - (spacing*2);
    return [{x:left,y:cy},{x:left+spacing,y:cy},{x:left+spacing*2,y:cy},{x:left+spacing*3,y:cy},{x:left+spacing*4,y:cy}];
  }
  function saverLoop(){
    if(preset.style.display==='none') return;
    const now = performance.now();
    const w = preset.clientWidth, h = preset.clientHeight, dpr = devicePixelRatio||1;
    presetCanvas.width = w*dpr; presetCanvas.height = h*dpr;
    const ctx = presetCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h); ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
    ctx.textAlign='center'; ctx.textBaseline='middle';

    const dt = (now - saverT0)/1000;
    if(dt>Math.random()*2+6){
      saverMode = (saverMode==='scatter' ? 'assemble' : 'scatter');
      saverT0 = now;
    }

    const targets = saverMode==='assemble' ? saverTargetsForWord() : null;

    for(const o of saverObjs){
      if(saverMode==='assemble'){
        const idx = ['S','L','E','E','P'].indexOf(o.ch);
        const goal = targets[idx];
        o.vx += (goal.x - o.x)*0.0006;
        o.vy += (goal.y - o.y)*0.0006;
      }
      o.x += o.vx; o.y += o.vy;
      if(o.x<0||o.x>w) o.vx*=-1;
      if(o.y<0||o.y>h) o.vy*=-1;

      const wob = Math.sin(now/500 + o.phase)*0.12 + 1;
      ctx.save();
      ctx.translate(o.x, o.y); ctx.scale(wob, 1/wob);
      ctx.font = `900 ${o.size}px Impact, Anton, "Arial Black", system-ui, sans-serif`;
      ctx.fillStyle='#fff';
      ctx.fillText(o.ch, 0, 0);
      ctx.restore();
    }
    requestAnimationFrame(saverLoop);
  }
  preset.addEventListener('click', presetClick, {passive:true});

  function captureIntroTexts(){
    return [
      "안녕하세요?","작게 대답해주세요.","안녕하세요?","대답을 해주셔야 프로그램이 진행될 수 있습니다.","안녕하세요?","감사합니다.",
      `지금 이 화면을 보고 있는 당신은 ${displayName}의 내면 세계를 탐험하는 탐험가입니다.`,
      "지금부터 우리는 주변의 소리에 귀를 기울이며 30분 간의 짧은 낮잠에 빠져볼 것입니다.",
      "자, 천천히 공간을 거닐어보세요.","무릎을 들고, 발을 앞으로 뻗어보세요.","참 잘했어요.",
      "맞아요. 그래 맞아요. 우리는 늘 그랬어요.","우리는 언제나 타자와 함께 존재해 왔습니다.",
      "가족, 친구, 교수님, 지나가는 그들, 그리고 당신과 처음 만나는 저도 우리는 늘 함께 존재해왔습니다",
      "그러나 어느 순간 ‘너’로 불리던 그들은 ‘그것’으로 전락했습니다",
      "이유는 아무도 몰라요. 그저 우리가 ‘너’들을 ‘그것’들로 부르기 시작한 것이죠.",
      "김춘추의 <꽃>이 떠오르네요.","(진지한 톤으로) 내가 그의 이름을 불러주기 전에는 그는 다만 하나의 몸짓에 지나지 않았다.",
      "크으으으으으으....","네. 각설하고.","이제 우리는 어느 곳에서도 ‘너’를 찾아볼 수 없습니다.",
      "우리는 이제 ‘너’가 사라진 세상에 살아가고 있으니까요.",
      "그런 특정했던 ‘너’는 서서히 희미해지고 퇴색되고 잊혀지고 잃어지고 앓아가고 있습니다",
      "마치 꿈 속에서 만난 누군가가 ... 그게 누구였지? ... 하고 떠오르지 않는 것처럼",
      "이곳은 바로 ‘너’가 사라진 공간","‘너’가 제거된, 제거해버린",
      `${displayName}의 내면 세계입니다`,
      `그리고 당신은 지금 이 순간 ${displayName}의 내면 세계로 발을 디딥니다`,
      "두 번의 심호흡을 하기도 하면서, 후 -- 하, 후 .... 하 ~",
      "이제 눈으로 감고, 천천히 수면 아래로 내려갑니다.","귀를 기울여 ‘보세요’",
      "내면의 미로를 탐험하여 사라진 ‘너’의 소리에","말이 길었습니다. 잠시 후에 만나요."
    ];
  }

  let introWalking = false;
  let introStartTime = 0;
  const INTRO_WALK_DURATION = 60_000;
  const BETWEEN_LINES_WAIT = 1500;
  let dialogueLines = [];
  let dialogueIndex = 0;

  function getFrameRect(){ return document.querySelector('.frameBox').getBoundingClientRect(); }

  function fitTitleLine(el){
    if(!el) return;
    const fr = getFrameRect();
    const maxW = Math.min(window.innerWidth*0.96, fr.width*0.90);
    const cs = getComputedStyle(el);
    let size = parseFloat(cs.fontSize)||48;
    el.style.whiteSpace='nowrap';
    while(el.scrollWidth > maxW && size > 24){
      size *= 0.94; el.style.fontSize = size+'px';
    }
  }

  async function typeSentenceTo(el, sentence, speed=34){
    el.textContent='';
    for(let i=0;i<sentence.length;i++){
      el.textContent += sentence[i];
      if(/\S/.test(sentence[i])) typeTick();
      await sleep(speed);
    }
  }

  const PIXEL_SPRITE = [
    "..XXXXXX....",".XXXXXXXX...",".XX.XX.XX...",".XXXXXXXX...",
    "..XXXXXX....",".XXXXXXXX...",".XXXXXXXX...",".XX.XX.XX...",
    ".XXXXXXXX...", "..XXXXXX....",".XX....XX...",".XX....XX...",
    ".XX....XX...", ".XX....XX...", "..XX..XX....","..XX..XX...."
  ];
  const COLOR_FILL = '#ff8a3c'; const COLOR_STROKE = '#000';

  function drawPixelHuman(ctx, cx, baselineY, W, hop=0, alpha=1){
    const cell = Math.max(2, Math.min(4, Math.floor(W * 0.0018)));
    const cols = PIXEL_SPRITE[0].length, rows = PIXEL_SPRITE.length;
    const width = cols * cell, height = rows * cell;
    const x0 = Math.round(cx - width/2), y0 = Math.round(baselineY - height - hop);

    ctx.globalAlpha = alpha;

    ctx.fillStyle = COLOR_STROKE;
    for(let y=0; y<rows; y++){
      const row = PIXEL_SPRITE[y];
      for(let x=0; x<cols; x++){
        if(row[x]==='X'){
          ctx.fillRect(x0 + x*cell - 1, y0 + y*cell, cell, cell);
          ctx.fillRect(x0 + x*cell + 1, y0 + y*cell, cell, cell);
          ctx.fillRect(x0 + x*cell, y0 + y*cell - 1, cell, cell);
          ctx.fillRect(x0 + x*cell, y0 + y*cell + 1, cell, cell);
        }
      }
    }
    ctx.fillStyle = COLOR_FILL;
    for(let y=0; y<rows; y++){
      const row = PIXEL_SPRITE[y];
      for(let x=0; x<cols; x++){
        if(row[x]==='X'){ ctx.fillRect(x0 + x*cell, y0 + y*cell, cell, cell); }
      }
    }
    ctx.globalAlpha = 1;
  }

  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }

  function getProsceniumRect(){
    const r = getFrameRect();
    return { x: r.left, y: r.top, w: r.width, h: r.height };
  }

  let grassPatches = [];
  function placeGrassPatches(count=8, keepSeeds=false){
    const pr = getProsceniumRect();
    const marginX = pr.w * 0.06;
    const baseYTop = pr.y + pr.h * 0.45;
    const baseYBot = pr.y + pr.h * 0.92;

    const oldSeeds = keepSeeds ? grassPatches.map(p=>p.seed) : [];
    grassPatches = [];
    for(let i=0;i<count;i++){
      const seed = oldSeeds[i] ?? Math.floor(Math.random()*1e9);
      const rand = mulberry32(seed);
      const rx = (i+1)/(count+1);
      const jitter = (rand()-0.5)*0.18;
      const x = pr.x + marginX + (pr.w - marginX*2) * clamp(rx + jitter, 0.05, 0.95);
      const y = baseYTop + (baseYBot-baseYTop) * (0.2 + (rand()*0.8));
      const blades = Math.max(18, Math.floor(pr.w*0.04));
      const maxH = Math.max(24, Math.floor(pr.w*0.05));
      const paths = [];
      const colors = [];
      for(let b=0;b<blades;b++){
        const bx = x + ((rand()*2-1) * pr.w*0.01);
        const h = maxH * (0.5 + rand()*0.8);
        const sway = (rand()*0.7 + 0.3) * (rand()<.5?-1:1);
        const p = new Path2D();
        p.moveTo(bx, y);
        p.quadraticCurveTo(bx + sway*6, y - h*0.5, bx + sway*2, y - h);
        p.lineTo(bx + sway*1.4, y - h*0.9);
        p.quadraticCurveTo(bx + sway*3, y - h*0.45, bx + sway*0.2, y);
        p.closePath();
        paths.push(p);
        const hue = 110 + rand()*20;
        const sat = 50 + rand()*30;
        const light= 35 + rand()*20;
        colors.push(`hsl(${hue}, ${sat}%, ${light}%)`);
      }
      const pixels = [];
      const cell = 3;
      for(let yy=0; yy<6; yy++){
        for(let c=0;c<26;c++){
          if(rand()>0.55){
            pixels.push({
              x: Math.round(x-40 + c*cell/1.6),
              y: Math.round(y - yy*cell),
              w: cell, h: cell
            });
          }
        }
      }
      grassPatches.push({seed,x,y,paths,colors,pixels});
    }
  }

  function drawAllGrassStatic(ctx){
    for(const g of grassPatches){
      for(let i=0;i<g.paths.length;i++){
        ctx.fillStyle = g.colors[i];
        ctx.fill(g.paths[i]);
      }
      ctx.imageSmoothingEnabled = false;
      ctx.fillStyle = '#0b2';
      for(const px of g.pixels){
        ctx.fillRect(px.x, px.y, px.w, px.h);
      }
    }
  }

  function drawBubble(ctx, x, y, text){
    const pad = 6, r = 6;
    ctx.font = '12px "Courier New", monospace';
    const m = ctx.measureText(text);
    const w = Math.max(28, m.width + pad*2);
    const h = 18 + pad*2;
    const bx = Math.round(x - w/2), by = Math.round(y - h - 18);
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(bx+r,by);
    ctx.arcTo(bx+w,by,bx+w,by+h,r);
    ctx.arcTo(bx+w,by+h,bx,by+h,r);
    ctx.arcTo(bx,by+h,bx,by,r);
    ctx.arcTo(bx,by,bx+w,by,r);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x-6, by+h-1);
    ctx.lineTo(x, by+h+6);
    ctx.lineTo(x+6, by+h-1);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.fillText(text, bx+pad, by+pad+12);
    ctx.restore();
  }

  function spiralPos(t01){
    const pr = getProsceniumRect();
    const baselineY = Math.round(pr.y + pr.h * 0.60 - (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--char-offset-vh'))/100)*pr.h);
    const R = Math.round(pr.x + pr.w * 0.92);
    const cx = pr.x + pr.w*0.46, cy = baselineY - pr.h*0.06;
    const turns = 2.2;
    const theta = turns * Math.PI * 2 * t01;
    const r0 = pr.w*0.22, r1 = pr.w*0.02;
    const r = r0 + (r1 - r0) * t01;
    let sx = cx + r * Math.cos(theta);
    let sy = cy + r * Math.sin(theta);
    const pull = t01*t01;
    sx = sx*(1-pull) + R*pull;
    sy = sy*(1-pull) + baselineY*pull;
    return {x:sx, y:sy, baselineY};
  }

  const bubbleSeqBase = ["HELLO", "…", "HI", "…", "HELLO!", "…"];
  const bubbleCute = [
    "…헤헤", "기억나?", "여기 있어.", "…쉿", "보고 있어", "꿈이야?", "아냐", "…조금 더 가까이",
    "같이 갈래?", "손… 잡을래?", "…응", "괜찮아", "거기 있어", "작게 불러", "내 이름"
  ];
  let bubbleSeq = bubbleSeqBase.concat(bubbleCute);
  let bubbleTimer = 0, bubbleIdx = 0;

  function fitTitleLineAll(){ fitTitleLine(introBigText); fitTitleLine(firstSleepText); }
  window.addEventListener('load', fitTitleLineAll);

  async function showIntroFlow(){
    introBig.style.display='flex';
    introBig.style.opacity='0';
    await nextFrame();
    fitTitleLine(introBigText);
    introBig.style.transition='opacity 800ms ease';
    introBig.style.opacity='1';
    await sleep(1200);
    introBig.style.opacity='0';
    await sleep(700);
    introBig.style.display='none';

    dialogueLines = captureIntroTexts();
    dialogueIndex = 0;
    dialogueWrap.style.display='flex';
    dialogueWrap.style.opacity='0';
    dialogueWrap.style.transition='opacity 800ms ease';
    requestAnimationFrame(()=> dialogueWrap.style.opacity='1');

    placeGrassPatches(8);
    showIntroLayer = true;
    fgAlpha = 1.0;

    introWalking = true;
    introStartTime = performance.now();

    while(dialogueIndex < dialogueLines.length){
      const sentence = dialogueLines[dialogueIndex];
      await typeSentenceTo(dialogueText, sentence, 34);
      await sleep(1500);
      dialogueIndex++;
    }

    const elapsed = performance.now() - introStartTime;
    if(elapsed < 60_000) await sleep(60_000 - elapsed);

    introWalking = false;

    dialogueWrap.style.transition='opacity 600ms ease';
    dialogueWrap.style.opacity='0';
    await sleep(650);
    dialogueWrap.style.display='none';

    await sleep(400);
    await playTduung();
    startTransition();
  }

  document.getElementById('goIntro').addEventListener('click', ()=>{ ensureResumed().then(async ()=>{ await playWoongClick(); fadeHide(welcome, FADE); showIntroFlow(); }); }, {passive:true});

  let eightTimer = null, eightLeft = 8*60;
  function formatMMSS(s){ const m=Math.floor(s/60), ss=(s%60).toString().padStart(2,'0'); return `${m.toString().padStart(2,'0')}:${ss}`; }
  function startEightTimer(){
    eightLeft = 8*60;
    runTimer.textContent = formatMMSS(eightLeft);
    runTimer.style.display='block';
    if(eightTimer) clearInterval(eightTimer);
    eightTimer = setInterval(()=>{
      eightLeft = Math.max(0, eightLeft-1);
      runTimer.textContent = formatMMSS(eightLeft);
      if(eightLeft<=0){ clearInterval(eightTimer); }
    },1000);
  }

  const Ambient = (() => {
    let ctx, master, delay, fb, hp, lp, mix, busGain, running=false, loops=[];
    function midi(n){ return 440 * Math.pow(2, (n-69)/12); }
    function makeBus(){
      ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value = 0.0001;
      delay = ctx.createDelay(2.5); delay.delayTime.value = 0.35;
      fb = ctx.createGain(); fb.gain.value = 0.35; delay.connect(fb).connect(delay);
      hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=150;
      lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=4500;
      mix = ctx.createGain(); mix.gain.value = 0.6; mix.connect(hp).connect(lp).connect(master);
      busGain = ctx.createGain(); busGain.gain.value=0.9; busGain.connect(master);
      master.connect(ctx.destination);
    }
    function connectDryWet(node){ node.connect(busGain); node.connect(delay); delay.connect(mix); }
    function slowPad(root){
      const out = ctx.createGain(); out.gain.value=0.35;
      const filt = ctx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=600; filt.Q.value=0.6;
      const lfo = ctx.createOscillator(); const lfoG = ctx.createGain();
      lfo.type='sine'; lfo.frequency.value=0.05; lfoG.gain.value=220; lfo.connect(lfoG); lfoG.connect(filt.frequency); lfo.start();
      [0,7,12].forEach((i,k)=>{ const o=ctx.createOscillator(); o.type='sawtooth'; o.frequency.value=midi(root+i); o.detune.value=(k-1)*6;
        const g=ctx.createGain(); g.gain.value=0.08; o.connect(g).connect(filt); o.start(); loops.push(()=>g.disconnect()); });
      filt.connect(out); connectDryWet(out); loops.push(()=>{ try{ out.disconnect(); }catch{} });
    }
    function airyNoise(){
      const b=ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate), d=b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.15;
      const s=ctx.createBufferSource(); s.buffer=b; s.loop=true;
      const g=ctx.createGain(); g.gain.value=0.02; const f=ctx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=800; f.Q.value=0.7;
      s.connect(f).connect(g); connectDryWet(g); s.start(); loops.push(()=>{ try{s.stop();}catch{} });
    }
    async function start(fadeIn=1.0, target=1.0){
      await ensureResumed(); if(running) return; makeBus(); running=true; airyNoise();
      const seq=[57,52,48,43]; let i=0; (function tick(){ if(!running) return; slowPad(seq[i%seq.length]); i++; setTimeout(tick,8000); })();
      const t=(ctx||audioCtx).currentTime;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.exponentialRampToValueAtTime(target, t+fadeIn);
    }
    function stop(fade=2.0){
      if(!running||!master) return;
      const t=(ctx||audioCtx).currentTime;
      master.gain.linearRampToValueAtTime(0.0001, t+fade);
      setTimeout(()=>{ loops.forEach(fn=>{try{fn();}catch{}}); loops=[]; running=false; }, fade*1000+120);
    }
    return { start, stop, isRunning:()=>running };
  })();

  let micStream=null, micSrc=null, panNode=null, lpf=null, lowshelf=null, highshelf=null, revConvolver=null, dryGain=null, wetGain=null;
  function makeImpulse(ctx, seconds=5.0, decay=7.0){
    const rate=ctx.sampleRate, len=rate*seconds, ir=ctx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const data=ir.getChannelData(ch);
      for(let i=0;i<len;i++){ const t=i/len; data[i]=(Math.random()*2-1) * Math.pow(1-t, decay); }
    }
    return ir;
  }
  async function startMicFXFadeIn(fadeSec=2.8){
    try{
      await ensureResumed();
      if(!micStream) micStream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}, video:false});
      if(!micSrc) micSrc = audioCtx.createMediaStreamSource(micStream);

      panNode = audioCtx.createStereoPanner(); panNode.pan.value = 0.0;
      lpf = audioCtx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=2200; lpf.Q.value=0.9;
      lowshelf = audioCtx.createBiquadFilter(); lowshelf.type='lowshelf'; lowshelf.frequency.value=200; lowshelf.gain.value=0;
      highshelf = audioCtx.createBiquadFilter(); highshelf.type='highshelf'; highshelf.frequency.value=3800; highshelf.gain.value=0;
      revConvolver = audioCtx.createConvolver(); revConvolver.buffer = makeImpulse(audioCtx, 5.0, 7.0);
      dryGain = audioCtx.createGain(); dryGain.gain.value=0.0;
      wetGain = audioCtx.createGain(); wetGain.gain.value=0.0;
      const out = audioCtx.createGain(); out.gain.value=0.98;

      micSrc.connect(lowshelf).connect(highshelf).connect(lpf).connect(panNode);
      panNode.connect(dryGain);
      panNode.connect(revConvolver);
      revConvolver.connect(wetGain);
      dryGain.connect(out); wetGain.connect(out);
      out.connect(audioCtx.destination);

      window.addEventListener('deviceorientation', onTiltAudio, {passive:true});

      const t=audioCtx.currentTime;
      dryGain.gain.linearRampToValueAtTime(0.85, t+fadeSec);
      wetGain.gain.linearRampToValueAtTime(0.85, t+fadeSec);
    }catch(e){ console.warn('startMicFX error', e); }
  }
  function onTiltAudio(e){
    if(!audioCtx) return;
    const gamma = clamp(e.gamma ?? 0, -60, 60);
    const beta  = clamp(e.beta ?? 0, -60, 60);
    let panVal = 0;
    if(gamma > 2) panVal = +1; else if(gamma < -2) panVal = -1;
    if(panNode) panNode.pan.value = panVal;

    const bassBoost = (beta>=0) ? ( (beta/60)*16 ) : ( (beta/60)*4 );
    const trebleBoost = (beta<0) ? ((-beta/60)*16) : 0;

    if(lowshelf) lowshelf.gain.value = clamp(bassBoost, -8, 16);
    if(highshelf) highshelf.gain.value = clamp(trebleBoost, 0, 16);
    if(lpf){
      const cutoff = (beta>=0) ? 2200 - (beta/60)*(2200-500) : 8500 + (beta/60)*(8500-2600);
      lpf.frequency.value = clamp(cutoff, 250, 9000);
    }
    if(wetGain && dryGain){
      const wet = (beta>=0) ? (0.85 - (beta/60)*(0.85-0.55)) : (1.0 + (beta/60)*(1.0-0.75));
      wetGain.gain.value = clamp(wet, 0.4, 1.0);
      dryGain.gain.value = clamp(1.0 - wetGain.gain.value*0.45, 0.2, 1.0);
    }
  }

  let metaReady = false;
  async function startCameraFresh(warmupOnly=false){
    try{
      if(!camPermGranted){
        await navigator.mediaDevices.getUserMedia({
          video:{ facingMode:{ideal:'environment'} },
          audio:true
        }).then(s=>{ s.getTracks().forEach(t=>t.stop()); camPermGranted=true; });
      }
      if(!camVideo){
        camVideo = document.createElement('video');
        camVideo.setAttribute('playsinline',''); camVideo.autoplay = true; camVideo.playsInline = true; camVideo.muted = true;
      }
      if(!camStream){
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:{ideal:'environment'},
            width:{min:1280, ideal:1920},
            height:{min:720,  ideal:1080},
            aspectRatio:{ideal:16/9}
          },
          audio:false
        });
        camVideo.srcObject = camStream;
      }

      await camVideo.play().catch(()=>{});
      if (camVideo.readyState < 1) {
        await new Promise(res => camVideo.addEventListener('loadedmetadata', res, {once:true}));
      }
      await enforceLandscapeConstraints();

      metaReady = true;
      resizeAll();
      warmupFrames = 30;

      if(!vctx){
        vctx = view.getContext('2d',{alpha:false});
        proc = document.createElement('canvas');
        pctx = proc.getContext('2d',{willReadFrequently:true});
      }
      if(!fgctx){
        fgctx = fg.getContext('2d',{alpha:true});
      }
      resizeAll();

      if(!animStarted && !warmupOnly){ animStarted = true; loop(); }
      document.querySelectorAll('.uiBtn').forEach(b=>b.addEventListener('click', ()=>{ ensureResumed().then(playWoongClick); }, {passive:true}));
    }catch(e){ console.warn('startCameraFresh error:', e); }
  }

  function resizeAll(){
    const dpr = window.devicePixelRatio||1;
    const w = window.innerWidth, h = window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; if(vctx) vctx.setTransform(dpr,0,0,dpr,0,0);
    fg.width=w*dpr; fg.height=h*dpr; if(fgctx) fgctx.setTransform(dpr,0,0,dpr,0,0);
    const scale = (!isPortrait())? 0.86 : 0.9;
    if(proc){ proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale); }
    if(grassPatches.length){ placeGrassPatches(grassPatches.length, true); }
  }
  addEventListener('resize', ()=>{ setTimeout(resizeAll,30); warmupFrames=30; }, {passive:true});
  document.addEventListener('visibilitychange', async ()=>{
    if(document.visibilityState==='visible' && camVideo){
      try{
        if(camVideo.paused){ await camVideo.play(); }
        if(!camStream || camStream.getVideoTracks().every(t=>t.readyState!=='live')){
          await startCameraFresh();
        }
        warmupFrames=30;
        await enforceLandscapeConstraints();
      }catch{}
    }
  });

  function drawBestCover(ctx, video, W, H, PW, PH){
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(!vw||!vh) return;

    function coverScore(rot){
      let rw = rot? vh: vw, rh = rot? vw: vh;
      const s = Math.max(PW/rw, PH/rh)*ZOOM;
      const dw = rw*s, dh = rh*s;
      const letter = Math.max(0, (PW - dw)) + Math.max(0, (PH - dh));
      return {rot, s, dw, dh, letter};
    }
    const a = coverScore(false);
    const b = coverScore(true);
    let best = (b.letter < a.letter) ? b : a;

    ctx.save();
    if(best.rot){
      ctx.translate(PW/2, PH/2);
      ctx.rotate(Math.PI/2);
      ctx.globalAlpha = .7;
      ctx.drawImage(video, -best.dh/2, -best.dw/2, best.dh, best.dw);
    }else{
      const dx=(PW-best.dw)/2, dy=(PH-best.dh)/2;
      ctx.globalAlpha=.7;
      ctx.drawImage(video, dx, dy, best.dw, best.dh);
    }
    ctx.restore();
    ctx.globalAlpha=1;
  }

  function loop(){
    requestAnimationFrame(loop);
    if(capturing) return;
    if(!vctx || !pctx || !fgctx) return;

    const W=view.width/(window.devicePixelRatio||1), H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;

    if(warmupFrames>0){ resizeAll(); warmupFrames--; }

    pctx.fillStyle='rgba(0,0,0,.14)'; pctx.fillRect(0,0,PW,PH);
    if(camVideo && camVideo.readyState>=2){
      drawBestCover(pctx, camVideo, W, H, PW, PH);
      const frame=pctx.getImageData(0,0,PW,PH),d=frame.data;
      for(let i=0;i<d.length;i+=4){const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;}
      pctx.putImageData(frame,0,0);
    }
    vctx.imageSmoothingEnabled = false;
    vctx.drawImage(proc,0,0,W,H);

    const pr = getProsceniumRect();
    fgctx.clearRect(0,0,W,H);

    if(showIntroLayer && fgAlpha > 0.001){
      fgctx.save();
      fgctx.globalAlpha = fgAlpha;

      fgctx.beginPath(); fgctx.rect(pr.x, pr.y, pr.w, pr.h); fgctx.clip();

      drawAllGrassStatic(fgctx);

      if(introWalking){
        const now = performance.now();
        const tRaw = (now - introStartTime)/60_000;
        const t = Math.max(0, Math.min(1, tRaw));
        const pos = spiralPos(t);
        const hop = Math.max(0, 10*Math.sin(t* Math.PI*20));
        drawPixelHuman(fgctx, Math.round(pos.x), Math.round(pos.baselineY), W, hop, 1);

        if(now - bubbleTimer > 600){
          bubbleIdx = (bubbleIdx+1) % bubbleSeq.length;
          bubbleTimer = now;
        }
        drawBubble(fgctx, Math.round(pos.x), Math.round(pos.baselineY)-28, bubbleSeq[bubbleIdx]);
      }
      fgctx.restore();
    }
  }

  function fadeIntroLayerOut(ms=8000){
    const t0 = performance.now();
    const startAlpha = fgAlpha;
    function step(){
      const t = performance.now();
      const k = Math.min(1, (t - t0)/ms);
      fgAlpha = startAlpha * (1 - k);
      if(k < 1){ requestAnimationFrame(step); }
      else{
        fgAlpha = 0; showIntroLayer = false;
        const W=view.width/(devicePixelRatio||1), H=view.height/(devicePixelRatio||1);
        fgctx && fgctx.clearRect(0,0,W,H);
      }
    }
    step();
  }

  let captureAnimating = false;
  captureBtn.addEventListener('click', async ()=>{
    if(captureAnimating) return;
    await playWoongClick();
    captureAnimating = true;

    capturing = true;
    const cssW = view.clientWidth, cssH = view.clientHeight;
    freezeLayer.width = cssW; freezeLayer.height = cssH;
    const displayCtx = freezeLayer.getContext('2d');
    displayCtx.imageSmoothingEnabled = false;
    freezeLayer.style.transition='';
    freezeLayer.style.opacity='0';
    freezeLayer.style.display='block';

    const snapshot = document.createElement('canvas');
    snapshot.width = cssW; snapshot.height = cssH;
    const snapCtx = snapshot.getContext('2d');
    snapCtx.imageSmoothingEnabled = false;
    snapCtx.drawImage(view, 0, 0, view.width, view.height, 0, 0, cssW, cssH);
    snapCtx.drawImage(fg, 0, 0, fg.width, fg.height, 0, 0, cssW, cssH);

    const off = document.createElement('canvas');
    const oc = off.getContext('2d');
    let px = 2.4;
    const step = 1.015;
    let revealed = false;

    function anim(){
      if(px > 420){
        freezeLayer.style.transition='opacity 2000ms ease';
        freezeLayer.style.opacity='0';
        setTimeout(()=>{
          freezeLayer.style.display='none';
          freezeLayer.style.transition='';
          capturing = false;
          captureAnimating = false;
        }, 2020);
        return;
      }
      const w = Math.max(1, Math.floor(cssW/px));
      const h = Math.max(1, Math.floor(cssH/px));
      off.width = w; off.height = h;
      oc.imageSmoothingEnabled=false;
      oc.clearRect(0,0,w,h);
      oc.drawImage(snapshot,0,0,cssW,cssH,0,0,w,h);
      displayCtx.clearRect(0,0,cssW,cssH);
      displayCtx.imageSmoothingEnabled=false;
      displayCtx.globalAlpha = 1.0;
      displayCtx.drawImage(off,0,0,w,h,0,0,cssW,cssH);
      if(!revealed){ freezeLayer.style.opacity='1'; revealed = true; }
      px = px * step + 0.35;
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  });

  async function startTransition(){
    firstSleep.style.display='flex';
    firstSleep.style.opacity='1';
    await nextFrame();
    fitTitleLine(firstSleepText);

    await ensureResumed();
    startEightTimer();

    await nextFrame();
    controls.classList.add('show');
    captureBtn.classList.add('show');

    await startMicFXFadeIn(4.0);

    const fadeDur = 8000;
    fadeIntroLayerOut(fadeDur);

    await sleep(900);
    firstSleep.style.transition=`opacity ${fadeDur}ms ease`;
    firstSleep.style.opacity='0';
    Ambient.stop(fadeDur/1000);
    await sleep(fadeDur+200);
    firstSleep.style.display='none';
    firstSleep.style.transition='';

    showNoticePopup();
  }

  function showNoticePopup(){
    function bgTrap(e){
      if(!e.target.closest('#noticeCard')){
        e.stopPropagation(); e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup.addEventListener(ev, bgTrap, {passive:false});
    });

    fadeShow(noticePopup, 280, 'flex');
    setTimeout(()=>{ noticeOk && noticeOk.focus && noticeOk.focus(); }, 50);

    noticeOk.onclick = async (e)=>{
      e.stopPropagation();
      await playWoongClick();
      fadeHide(noticePopup, 250);
    };
  }

  document.getElementById('goIntro').addEventListener('click', ()=>{});
  preset.addEventListener('click', ()=>{});

  window.addEventListener('load', fitTitleLineAll);
  preset.addEventListener('click', async ()=>{ await presetClick(); }, {passive:true});
})();
</script>
</body>
</html>
