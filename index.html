<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>SLEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEP</title>

<!-- 픽셀 게임 폰트 -->
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEEEEP">
<meta name="theme-color" content="#000000">

<style>
  :root{
    --appH: 100svh;
    --frame: clamp(16px, 4vmin, 40px);
    --ui-gap: 8px;

    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --fs-name: clamp(14px,2.8vmin,20px);

    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);

    --safe-t: env(safe-area-inset-top, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);

    --dialogue-offset-vh: 8vh;
    --char-offset-vh: 16vh;

    /* 건물 노란 불빛 색 */
    --accent-yellow: #ffd840;
  }

  html,body{
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    background:#000;
    overflow:hidden;
    touch-action:manipulation;
  }

  body{
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans KR",sans-serif;
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
  }

  *{
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    box-sizing:border-box;
  }
  input, textarea{
    -webkit-user-select:text;
    user-select:text;
  }

  .fade{opacity:0; transition:opacity 1800ms ease}
  .fade.show{opacity:1}

  /* 카메라: 흑백 유지 */
  #view{
    position:fixed;
    left:0;
    top:0;
    width:100vw;
    height:100vh;
    display:block;
    z-index:0;
    filter:grayscale(1); /* 흑백 */
  }
  #fg{
    position:fixed;
    left:0;
    top:0;
    width:100vw;
    height:100vh;
    display:block;
    z-index:880;
    pointer-events:none;
  }

  #freezeLayer{
    position:fixed;
    inset:0;
    z-index:500;
    display:none;
  }

  .frameBox{
    position:fixed;
    left:calc(var(--frame) + var(--safe-l));
    top:calc(var(--frame) + var(--safe-t));
    right:calc(var(--frame) + var(--safe-r));
    bottom:calc(var(--frame) + var(--safe-b));
    border:2px solid rgba(255,255,255,.22);
    pointer-events:none;
    z-index:50;
  }

  .uiBtn{
    background:transparent;
    color:var(--accent-yellow);
    border:none;
    font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    white-space:nowrap;
    cursor:pointer;
    user-select:none;
  }
  .uiBtn.small{
    font-size:var(--fs-small);
    padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6);
  }
  .uiBtn.flat{
    border:none;
    background:transparent;
    text-decoration:none;
  }
  .uiBtn[disabled]{
    opacity:.35;
    pointer-events:none;
    filter:grayscale(1);
  }
  .hide{display:none !important;}

  .controls{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:400;
    display:flex;
    gap:6px;
    align-items:center;
    opacity:0;
    transition:opacity 1800ms ease;
    pointer-events:none; /* 기본은 클릭 불가 */
  }
  .controls.show{
    opacity:1;
    pointer-events:auto; /* FIRST SLEEP 이후에만 활성화 */
  }

  .readout{
    min-width:48px;
    text-align:center;
    opacity:.9;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:var(--fs-small);
    color:var(--accent-yellow);
  }

  .btn-capture{
    position:fixed;
    left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:450;
    opacity:0;
    transition:opacity 1800ms ease;
    pointer-events:none;
  }
  .btn-capture.show{
    opacity:1;
    pointer-events:auto;
  }

  #mapLauncher, #docLauncher, #audioToggle { display:none; }

  #runTimer{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
    z-index:460;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:var(--fs-strong);
    color:var(--accent-yellow);
    opacity:.95;
    pointer-events:none;
    user-select:none;
    display:none;
  }

  .credits{
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    letter-spacing:.08em;
    font-size:clamp(9px,1.4vmin,11px);
    margin:0;
    color:var(--accent-yellow);
  }

  #rotateOverlay{
    position:fixed;
    inset:0;
    z-index:1000;
    display:none;
    align-items:center;
    justify-content:center;
    text-align:center;
    background:#000;
    color:var(--accent-yellow);
    padding:40px;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    pointer-events:auto;
  }

  /* Permission Gate */
  #overlay{
    position:fixed;
    inset:0;
    z-index:300;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:calc(20px + var(--safe-t)) calc(20px + var(--safe-r)) calc(20px + var(--safe-b)) calc(20px + var(--safe-l));
    color:var(--accent-yellow);
    background:rgba(0,0,0,.85);
  }
  #overlayContent{
    max-width:min(92vw, 72ch);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    line-height:1.7;
    text-align:center;
  }
  .gateLine{
    display:inline-block;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:var(--fs-small);
    border:none;
    background:transparent;
    color:var(--accent-yellow);
    cursor:pointer;
    padding:6px 10px;
    width:100%;
    line-height:1.6;
  }
  .gateHint{
    opacity:.7;
    margin-top:6px;
    font-size:clamp(9px,1.6vmin,11px);
    color:var(--accent-yellow);
  }

  /* Name */
  #nameOverlay{
    position:fixed;
    inset:0;
    z-index:260;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.9);
    color:var(--accent-yellow);
    overflow:hidden;
  }
  #nameCity{
    position:absolute;
    inset:0;
    z-index:0;
  }
  #nameCard{
    position:relative;
    z-index:1;
    width:min(92vw,600px);
    text-align:center;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    color:var(--accent-yellow);
  }
  #nameCard h2{
    margin:0 0 12px 0;
    letter-spacing:.12em;
    font-size:var(--fs-name);
    font-weight:400;
    text-shadow:0 0 6px rgba(0,0,0,.9);
    color:var(--accent-yellow);
  }
  #nick{
    width:100%;
    padding:14px 14px;
    background:rgba(0,0,0,.88);
    border:1px solid #777;
    color:var(--accent-yellow);
    font-size:var(--fs-name);
    outline:none;
    box-shadow:0 0 12px rgba(0,0,0,.8);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  }
  #nameRow{
    display:flex;
    gap:10px;
    margin-top:16px;
    justify-content:center;
  }
  #nameRow .uiBtn{
    padding:10px 18px;
  }

  /* Preset */
  #preset{
    position:fixed;
    inset:0;
    z-index:250;
    background:#000;
    display:none;
    cursor:pointer;
  }
  #presetCanvas{
    position:absolute;
    left:0;top:0;width:100%;height:100%;
  }

  /* Welcome */
  #overlayWelcome{
    position:fixed;
    inset:0;
    z-index:220;
    display:none;
    place-items:center;
    color:var(--accent-yellow);
    background:transparent;
    padding:0;
  }
  #welcomeCard{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    width:100%;
    max-width:min(92vw, 820px);
    margin:0 auto;
    text-align:center;
    padding:calc(20px + var(--safe-t)) 20px calc(20px + var(--safe-b)) 20px;
    gap:18px;
  }
  #welcomeCard .title{
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:clamp(40px, 12vmin, 96px);
    font-weight:400;
    letter-spacing:.16em;
    line-height:1.1;
    margin:0;
    text-transform:uppercase;
    text-shadow:0 0 8px rgba(0,0,0,0.8);
    color:var(--accent-yellow);
  }
  #goIntro{
    margin-top:0;
    font-size:var(--fs-small);
  }

  /* INTRO big title */
  #introBig{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    z-index:210;
  }
  #introBigText{
    color:var(--accent-yellow);
    font-weight:400;
    letter-spacing:.16em;
    font-size:clamp(32px, 12vmin, 160px);
    text-transform:uppercase;
    text-align:center;
    white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    padding:0 .02em;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  }

  /* INTRODUCTION paragraphs (우측 하단 + NEXT) */
  #introOverlay{
    position:fixed;
    inset:0;
    z-index:230;
    display:none;
    align-items:flex-end;   /* 하단 */
    justify-content:flex-end; /* 오른쪽 */
    background:transparent;
    pointer-events:auto;
  }
  #introOverlayCenter{
    max-width:min(420px, 60vw);
    max-height:60vh;
    text-align:left;
    padding:16px 18px;
    margin-right:calc(var(--frame) + var(--safe-r));
    margin-bottom:calc(var(--frame) + var(--safe-b));
    background:rgba(0,0,0,0.78);
    border:1px solid rgba(255,255,255,0.35);
    box-shadow:0 8px 22px rgba(0,0,0,0.7);
    border-radius:6px;
  }
  #introOverlayText{
    font-family:"Courier New",ui-monospace,monospace;
    font-size:clamp(11px, 2.0vmin, 16px);
    line-height:1.9;
    color:var(--accent-yellow);
    white-space:pre-line;
  }
  #introNextRow{
    margin-top:10px;
    text-align:right;
  }

  /* FIRST SLEEP title block (SLEEEEEE… + THE FIRST SLEEP) */
  #firstSleep{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    z-index:850;
  }
  #firstSleepInner{
    text-align:center;
  }
  .sleepWordLine{
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-weight:400;
    letter-spacing:.16em;
    font-size:clamp(28px,10vmin,90px);
    text-transform:uppercase;
    color:var(--accent-yellow);
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    margin:0 0 8px 0;
    white-space:nowrap; /* 화면을 살짝 벗어나도록 */
  }
  #firstSleepText{
    color:var(--accent-yellow);
    font-weight:400;
    letter-spacing:.16em;
    font-size:clamp(24px, 7vmin, 72px);
    text-transform:uppercase;
    text-align:center;
    white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    padding:0 .02em;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    opacity:0;
  }

  /* SECOND SLEEP title block */
  #secondSleep{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    z-index:960;
  }
  #secondSleepInner{
    text-align:center;
  }
  #secondSleepText{
    color:var(--accent-yellow);
    font-weight:400;
    letter-spacing:.16em;
    font-size:clamp(24px, 7vmin, 72px);
    text-transform:uppercase;
    text-align:center;
    white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    padding:0 .02em;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    opacity:0;
  }

  /* 1장 NOTICE Popup */
  #noticePopup{
    position:fixed;
    inset:0;
    z-index:900;
    display:none;
    align-items:center;
    justify-content:center;
    background:transparent;
  }
  #noticeCard{
    width:min(92vw, 640px);
    background:#0b0b0b;
    color:var(--accent-yellow);
    border:1px solid #333;
    padding:18px;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    font-family:"Courier New",ui-monospace,monospace;
    line-height:1.7;
  }
  #noticeCard h3{
    margin:0 0 6px 0;
    letter-spacing:.06em;
    font-weight:700;
    font-size:clamp(15px,3vmin,20px);
    color:var(--accent-yellow);
  }
  #noticeCard p{
    margin:4px 0;
    font-size:clamp(12px,2.4vmin,16px);
    color:var(--accent-yellow);
  }
  #noticeActions{
    margin-top:10px;
    text-align:right;
  }

  /* 2장 NOTICE Popup (NOTE) */
  #notice2Popup{
    position:fixed;
    inset:0;
    z-index:970;
    display:none;
    align-items:center;
    justify-content:center;
    background:transparent;
  }
  #notice2Card{
    width:min(92vw, 640px);
    background:#0b0b0b;
    color:var(--accent-yellow);
    border:1px solid #333;
    padding:18px;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    font-family:"Courier New",ui-monospace,monospace;
    line-height:1.7;
  }
  #notice2Card h3{
    margin:0 0 6px 0;
    letter-spacing:.06em;
    font-weight:700;
    font-size:clamp(15px,3vmin,20px);
    color:var(--accent-yellow);
  }
  #notice2Card p{
    margin:4px 0;
    font-size:clamp(12px,2.4vmin,16px);
    color:var(--accent-yellow);
  }
  #notice2Actions{
    margin-top:10px;
    text-align:right;
  }

  /* FIRST SLEEP: 1장 텍스트 (화면 중앙) */
  #chapterOverlay{
    position:fixed;
    inset:0;
    z-index:930;
    display:none;
    align-items:center;
    justify-content:center;
    background:transparent;
    color:var(--accent-yellow);
    padding:24px;
    pointer-events:none;
  }
  #chapterCenter{
    max-width:min(900px, 92vw);
    max-height:80vh;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    overflow:hidden;
  }
  #chapterBox{
    font-family:"Courier New",ui-monospace,monospace;
    line-height:1.8;
    font-size:clamp(11px,2.0vmin,15px);
    color:var(--accent-yellow);
    text-align:center; /* 문장 자체도 중앙 정렬 */
  }
  #chapterBox .charBox{
    display:inline-block;
    min-width:0.6em;
    padding:2px 3px;
    margin:1px;
    background:#000;
    border-radius:2px;
    color:var(--accent-yellow);
  }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <canvas id="fg"></canvas>

  <canvas id="freezeLayer"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <button id="docLauncher" class="uiBtn small">DOCUMENT</button>
  <button id="mapLauncher" class="uiBtn small">MAP</button>
  <button id="audioToggle" class="uiBtn small">AUDIO</button>
  <div id="runTimer" aria-live="polite">04:00</div>

  <div id="rotateOverlay" aria-live="polite">
    <div>
      <b>Landscape mode required</b><br/>
      Please rotate your device to landscape to continue.<br/>
      If the screen doesn’t rotate, unlock orientation in your device settings.
    </div>
  </div>

  <!-- Permission Gate -->
  <div id="overlay" class="fade show">
    <div id="overlayContent">
      <div class="credits">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <button id="permGateBtn" class="gateLine" type="button">
        Tap anywhere to allow Camera, Microphone & Motion sensors
      </button>
      <div class="gateHint">After allowing, you'll move to the name screen.</div>
    </div>
  </div>

  <!-- Name -->
  <div id="nameOverlay" class="fade">
    <canvas id="nameCity"></canvas>
    <div id="nameCard">
      <h2>TELL ME YOUR NAME</h2>
      <!-- Type your name 텍스트 제거: placeholder 비움 -->
      <input id="nick" type="text" maxlength="24" placeholder="" autocomplete="off" />
      <div id="nameRow">
        <button id="nameSubmit" class="uiBtn flat" type="button">GO</button>
      </div>
    </div>
  </div>

  <!-- Preset -->
  <div id="preset" class="fade" title="Tap to continue">
    <canvas id="presetCanvas"></canvas>
  </div>

  <!-- Welcome -->
  <div id="overlayWelcome" class="fade">
    <div id="welcomeCard">
      <div class="credits">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <div class="title">SLEEEEEP</div>
      <div class="title">SLEEEEEP</div>
      <div class="title">SLEEEEEP</div>
      <div class="title">SLEEEEEP</div>
      <button id="goIntro" class="uiBtn flat" type="button">PRESS HERE TO SLEEP</button>
    </div>
  </div>

  <!-- INTRODUCTION title -->
  <div id="introBig" class="fade"><div id="introBigText">INTRODUCTION</div></div>

  <!-- INTRODUCTION sentences (우측 하단 + NEXT) -->
  <div id="introOverlay" class="fade">
    <div id="introOverlayCenter">
      <div id="introOverlayText"></div>
      <div id="introNextRow">
        <button id="introNext" class="uiBtn small" type="button">NEXT</button>
      </div>
    </div>
  </div>

  <!-- THE FIRST SLEEP block -->
  <div id="firstSleep">
    <div id="firstSleepInner">
      <div id="firstSleepTop" class="sleepWordLine"></div>
      <div id="firstSleepText">THE FIRST SLEEP</div>
    </div>
  </div>

  <!-- THE SECOND SLEEP block -->
  <div id="secondSleep">
    <div id="secondSleepInner">
      <div id="secondSleepLine1" class="sleepWordLine"></div>
      <div id="secondSleepLine2" class="sleepWordLine"></div>
      <div id="secondSleepText">THE SECOND SLEEP</div>
    </div>
  </div>

  <!-- 1장 NOTICE Popup -->
  <div id="noticePopup" class="fade" role="dialog" aria-modal="true" aria-labelledby="noticeTitle">
    <div id="noticeCard">
      <h3 id="noticeTitle">NOTICE</h3>
      <p>※ “THE FIRST SLEEP”은 눈으로 인식하던 타자를 귀로 인식해 나가는 챕터입니다.</p>
      <p>※ 앞으로 당신의 태블릿 위로 타자와 몇가지 흔적들이 텍스트로 제시될 것입니다.</p>
      <p>※ 당신은 내면 세계의 탐험가로써 그 흔적들을 화면 아래 ‘CAPTURE’와 ‘+’, ‘-’버튼을 눌러 포착하세요.</p>
      <p>※ 확인하셨다면, 아래 ‘OK’버튼을 눌러주세요</p>
      <div id="noticeActions">
        <button id="noticeOk" class="uiBtn flat" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- 2장 NOTICE Popup (NOTE) -->
  <div id="notice2Popup" class="fade" role="dialog" aria-modal="true" aria-labelledby="notice2Title">
    <div id="notice2Card">
      <h3 id="notice2Title">NOTE</h3>
      <p>※ “THE SECOND SLEEP”은 귀로 타자를 인식해 나가는 챕터입니다.</p>
      <p>※ 공간 곳곳에 1번~8번까지의 피켓이 설치되어 있습니다.</p>
      <p>※ 그곳의 주변으로 이동해 그 공간에 남아있는 누군가의 목소리를 들어보세요.</p>
      <p>※ 이상하게 마음이 끌리는 소리가 있다면, 그곳의 옆에 있는 의자에 앉아 잠깐의 시간동안 귀를 기울여보세요.</p>
      <p>※ 확인하셨다면, 아래 ‘OK’버튼을 눌러주세요</p>
      <div id="notice2Actions">
        <button id="notice2Ok" class="uiBtn flat" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- FIRST SLEEP: 1장 텍스트 -->
  <div id="chapterOverlay" class="fade">
    <div id="chapterCenter">
      <div id="chapterBox"></div>
    </div>
  </div>

<script>
(() => {
  /* ===== Manifest fullscreen ===== */
  (function injectManifest(){
    const manifest = {
      "name":"SLEEEEEP",
      "short_name":"SLEEEEEP",
      "display":"fullscreen",
      "start_url":"./",
      "background_color":"#000",
      "theme_color":"#000",
      "icons":[]
    };
    const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:"application/manifest+json"}));
    const link = document.createElement('link');
    link.rel='manifest';
    link.href=url;
    document.head.appendChild(link);
  })();

  const ACCENT = '#ffd840'; // 건물 노란 불빛 색
  const SLEEP_WORD = 'SLEEEEEEEEP'; // E 8개

  /* ===== Fullscreen / Orientation / Wake Lock ===== */
  async function enterFullscreen(){
    try{
      const el = document.documentElement;
      if (!document.fullscreenElement) {
        if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      }
    }catch(e){}
    try{
      if (screen.orientation && screen.orientation.lock) {
        await screen.orientation.lock('landscape').catch(()=>{});
      }
    }catch(e){}
  }
  let wakeLock = null;
  async function keepAwake(){
    try{
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', ()=>{});
      }
    }catch(e){}
  }
  function claimImmersive(){ enterFullscreen(); keepAwake(); }
  document.addEventListener('visibilitychange', async ()=>{
    if (document.visibilityState === 'visible' && wakeLock) {
      try{ wakeLock = await navigator.wakeLock.request('screen'); }catch(e){}
    }
  });

  /* ===== Common utils ===== */
  const FADE = 1800;
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const qs = s => document.querySelector(s);
  const nextFrame = () => new Promise(resolve=>requestAnimationFrame(()=>resolve()));

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  function fadeShow(el, dur=FADE, display='flex'){
    el.style.display=display;
    el.style.opacity='0';
    el.style.transition=`opacity ${dur}ms ease`;
    requestAnimationFrame(()=> el.style.opacity='1');
  }
  function fadeHide(el, dur=FADE){
    el.style.transition=`opacity ${dur}ms ease`;
    el.style.opacity='0';
    setTimeout(()=>{ el.style.display='none'; }, dur);
  }

  function setAppH(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH();
  addEventListener('resize', setAppH, {passive:true});
  if (window.visualViewport){
    visualViewport.addEventListener('resize', ()=>setTimeout(setAppH,50));
  }

  /* ===== Rotate guard ===== */
  const rotateOverlay = document.getElementById('rotateOverlay');
  function isPortrait(){
    const vv=window.visualViewport;
    const w=vv?vv.width:innerWidth, h=vv?vv.height:innerHeight;
    return h>w;
  }
  function updateRotateOverlay(){
    rotateOverlay.style.display = isPortrait() ? 'flex' : 'none';
  }
  ['load','pageshow','resize','orientationchange','visibilitychange'].forEach(ev=>{
    addEventListener(ev, updateRotateOverlay, {passive:true});
  });
  updateRotateOverlay();

  /* ===== Refs ===== */
  const overlay = qs('#overlay');
  const permBtn = qs('#permGateBtn');
  const nameOverlay = qs('#nameOverlay');
  const nameCityCanvas = qs('#nameCity');
  const nickInput = qs('#nick');
  const nameSubmit = qs('#nameSubmit');
  const preset = qs('#preset');
  const presetCanvas = qs('#presetCanvas');
  const welcome = qs('#overlayWelcome');

  const introBig = qs('#introBig');
  const introBigText = qs('#introBigText');

  const introOverlay = qs('#introOverlay');
  const introOverlayText = qs('#introOverlayText');
  const introNext = qs('#introNext');

  const firstSleep = qs('#firstSleep');
  const firstSleepTop = qs('#firstSleepTop');
  const firstSleepText = qs('#firstSleepText');

  const secondSleep = qs('#secondSleep');
  const secondSleepLine1 = qs('#secondSleepLine1');
  const secondSleepLine2 = qs('#secondSleepLine2');
  const secondSleepText = qs('#secondSleepText');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');
  const view = qs('#view');
  const fg = qs('#fg');
  const freezeLayer = qs('#freezeLayer');
  const runTimer = qs('#runTimer');

  const noticePopup = qs('#noticePopup');
  const noticeOk = qs('#noticeOk');

  const notice2Popup = qs('#notice2Popup');
  const notice2Ok = qs('#notice2Ok');

  const chapterOverlay = qs('#chapterOverlay');
  const chapterBox = qs('#chapterBox');

  /* ===== Canvas ===== */
  let vctx=null, fgctx=null;

  /* ===== State ===== */
  let camPermGranted=false;
  let camStream=null, camVideo=null, ZOOM=1.0;
  let animStarted=false, capturing=false, warmupFrames=0;

  let showIntroLayer=true, fgAlpha=1.0;

  /* ===== Audio ===== */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  async function ensureResumed(){
    try{
      ensureAudio();
      if(audioCtx.state==='suspended') await audioCtx.resume();
    }catch{}
  }

  // ---- Ambient BG ----
  const Ambient = (() => {
    let ctx, master, delay, fb, hp, lp, mix, busGain, running=false, killers=[];
    function midi(n){ return 440 * Math.pow(2, (n-69)/12); }
    function setup(){
      ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value=0.0001;
      delay = ctx.createDelay(2.5); delay.delayTime.value=0.35;
      fb = ctx.createGain(); fb.gain.value=0.35; delay.connect(fb).connect(delay);
      hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=150;
      lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=4500;
      mix = ctx.createGain(); mix.gain.value = 0.6; mix.connect(hp).connect(lp).connect(master);
      busGain = ctx.createGain(); busGain.gain.value=0.9; busGain.connect(master);
      master.connect(ctx.destination);
    }
    function connectDW(node){ node.connect(busGain); node.connect(delay); delay.connect(mix); }
    function airy(){
      const b=audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
      const d=b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.15;
      const s=audioCtx.createBufferSource();
      s.buffer=b; s.loop=true;
      const g=audioCtx.createGain(); g.gain.value=0.02;
      const f=audioCtx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=800; f.Q.value=0.7;
      s.connect(f).connect(g);
      connectDW(g);
      s.start();
      killers.push(()=>{ try{s.stop();}catch{} });
    }
    function pad(root){
      const out = audioCtx.createGain(); out.gain.value=0.35;
      const filt=audioCtx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=600; filt.Q.value=0.6;
      const lfo=audioCtx.createOscillator(); const lfoG=audioCtx.createGain();
      lfo.type='sine'; lfo.frequency.value=0.05; lfoG.gain.value=220;
      lfo.connect(lfoG).connect(filt.frequency); lfo.start();
      [0,7,12].forEach((i,k)=>{
        const o=audioCtx.createOscillator();
        o.type='sawtooth';
        o.frequency.value=midi(root+i);
        o.detune.value=(k-1)*6;
        const g=audioCtx.createGain(); g.gain.value=0.08;
        o.connect(g).connect(filt);
        o.start();
        killers.push(()=>g.disconnect());
      });
      filt.connect(out);
      connectDW(out);
      killers.push(()=>{ try{ out.disconnect(); }catch{} });
    }
    async function start(fadeIn=0.8, target=1.0){
      await ensureResumed();
      if(running) return;
      setup();
      running=true;
      airy();
      const seq=[57,52,48,43];
      let i=0;
      (function tick(){
        if(!running) return;
        pad(seq[i%seq.length]);
        i++;
        setTimeout(tick,8000);
      })();
      const t=(audioCtx||ctx).currentTime;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.exponentialRampToValueAtTime(target, t+fadeIn);
    }
    function stop(fade=2.0){
      if(!running||!master) return;
      const t=(audioCtx||ctx).currentTime;
      master.gain.linearRampToValueAtTime(0.0001, t+fade);
      setTimeout(()=>{
        killers.forEach(fn=>{try{fn();}catch{}});
        killers=[];
        running=false;
      }, fade*1000+120);
    }
    function isRunning(){ return running; }
    return { start, stop, isRunning };
  })();

  // ---- UI sounds ----
  async function playWoongClick(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type='sine';
      o.frequency.setValueAtTime(180, now);
      o.frequency.exponentialRampToValueAtTime(70, now+0.32);
      f.type='lowpass';
      f.frequency.setValueAtTime(1400, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.8, now+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.55);
      o.connect(f).connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(now+0.58);
    }catch(e){}
  }
  async function playTduung(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o1.type='sine'; o2.type='sine';
      o1.frequency.value=90; o2.frequency.value=45;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(1.0, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
      o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
      o1.start(); o2.start();
      o1.stop(now+0.62); o2.stop(now+0.62);
    }catch(e){}
  }
  function typeTick(){
    try{
      ensureAudio();
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='square'; o.frequency.value=900;
      g.gain.value=0.0001;
      g.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.10);
      o.connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime+0.12);
    }catch(e){}
  }

  function updateZoomLabel(){
    zoomVal.textContent = ZOOM.toFixed(1)+'×';
  }
  updateZoomLabel();
  zoomIn.addEventListener('click', async ()=>{
    ZOOM=Math.min(3.0, ZOOM+0.05);
    updateZoomLabel();
    await playWoongClick();
  }, {passive:true});
  zoomOut.addEventListener('click', async ()=>{
    ZOOM=1.0;
    updateZoomLabel();
    await playWoongClick();
  }, {passive:true});

  /* ===== Permission Gate ===== */
  async function immediateGestureStart(e){
    e && e.preventDefault && e.preventDefault();

    claimImmersive();
    await ensureResumed();

    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(()=>{ claimImmersive(); })
          .catch(()=>{});
      }
    }catch(_){}

    navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:'environment'},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}
    })
    .then(async (s)=>{
      await ensureResumed();
      if(!Ambient.isRunning()) Ambient.start(0.8, 1.0);

      claimImmersive();

      s.getTracks().forEach(t=>t.stop());
      camPermGranted = true;
    })
    .catch(err=>{
      console.warn('permission error:', err);
    })
    .finally(()=>{
      fadeHide(overlay, FADE);
      fadeShow(nameOverlay, FADE);
      startNameCity();
      setTimeout(()=>nickInput && nickInput.focus && nickInput.focus(), 60);
    });
  }

  ['click','touchstart','pointerdown'].forEach(type=>{
    permBtn.addEventListener(type, immediateGestureStart, {passive:false});
    overlay.addEventListener(type, immediateGestureStart, {passive:false});
    window.addEventListener(type, (ev)=>{
      if(getComputedStyle(overlay).display !== 'none'){
        immediateGestureStart(ev);
      }
    }, {passive:false});
  });

  /* ===== Name → Preset → Welcome ===== */
  let displayName = '____';
  async function acceptName(){
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.2, 1.0);
    const v = (nickInput.value||'').trim();
    if(v.length>0){ displayName = v; }
    await playWoongClick();
    stopNameCity();
    fadeHide(nameOverlay, FADE);
    showPreset();
  }
  nameSubmit.addEventListener('click', acceptName, {passive:true});
  nickInput.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){ acceptName(); }
  });

  let saverObjs=[], saverMode='scatter', saverT0=0;
  function showPreset(){
    preset.style.display='block';
    preset.classList.add('show');
    fadeShow(preset, FADE);
    initSaver();
    startCameraFresh(true);
  }
  function initSaver(){
    const w=preset.clientWidth, h=preset.clientHeight;
    saverObjs=[];
    const letters=['S','L','E','E','P'];
    for(let i=0;i<20;i++){
      saverObjs.push({
        ch:letters[i%5],
        x:Math.random()*w,
        y:Math.random()*h,
        vx:(Math.random()*1.2+0.3)*(Math.random()<.5?-1:1),
        vy:(Math.random()*1.2+0.3)*(Math.random()<.5?-1:1),
        phase:Math.random()*Math.PI*2,
        size:(Math.floor(Math.random()*60)+90)*2
      });
    }
    saverT0=performance.now();
    requestAnimationFrame(saverLoop);
  }
  function saverTargetsForWord(){
    const w=preset.clientWidth, h=preset.clientHeight;
    const base=Math.min(w,h)*0.55;
    const cx=w/2, cy=h/2;
    const spacing=base/5;
    const left=cx-(spacing*2);
    return [
      {x:left,y:cy},
      {x:left+spacing,y:cy},
      {x:left+spacing*2,y:cy},
      {x:left+spacing*3,y:cy},
      {x:left+spacing*4,y:cy}
    ];
  }
  function saverLoop(){
    if(preset.style.display==='none') return;
    const now=performance.now();
    const w=preset.clientWidth, h=preset.clientHeight;
    const dpr=devicePixelRatio||1;
    presetCanvas.width=w*dpr;
    presetCanvas.height=h*dpr;
    const ctx=presetCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,w,h);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    const dt=(now-saverT0)/1000;
    if(dt>Math.random()*2+6){
      saverMode=(saverMode==='scatter'?'assemble':'scatter');
      saverT0=now;
    }
    const targets=saverMode==='assemble'?saverTargetsForWord():null;
    for(const o of saverObjs){
      if(saverMode==='assemble'){
        const idx=['S','L','E','E','P'].indexOf(o.ch);
        const g=targets[idx];
        o.vx += (g.x-o.x)*0.0006;
        o.vy += (g.y-o.y)*0.0006;
      }
      o.x+=o.vx;
      o.y+=o.vy;
      if(o.x<0||o.x>w) o.vx*=-1;
      if(o.y<0||o.y>h) o.vy*=-1;
      const wob=Math.sin(now/500+o.phase)*0.12+1;
      ctx.save();
      ctx.translate(o.x,o.y);
      ctx.scale(wob,1/wob);
      ctx.font=`900 ${o.size}px "Press Start 2P", system-ui, sans-serif`;
      ctx.fillStyle=ACCENT;
      ctx.fillText(o.ch,0,0);
      ctx.restore();
    }
    requestAnimationFrame(saverLoop);
  }

  preset.addEventListener('click', async ()=>{
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.2, 1.0);
    await playWoongClick();
    fadeHide(preset, FADE);
    await startCameraFresh(false);
    fadeShow(welcome, FADE);
  }, {passive:true});

  /* ===== INTRO big title & INTRO sentences + NEXT ===== */

  function getIntroSentences(){
    return [
      "안녕하세요?",
      "작게 대답해주세요.",
      "안녕하세요?",
      "대답을 해주셔야 프로그램이 진행될 수 있습니다.",
      "안녕하세요?",
      "감사합니다.",
      "아실지 모르겠지만, 저는 이 공간의 안내자,",
      "당신의 내면 세계에 존재하는 무의식입니다.",
      `지금부터 우리는 ${displayName}의 내면 세계를 탐험하는 탐험가가 될 것입니다.`,
      "주변의 소리에 귀를 기울이며,",
      "30분 간의 짧은 낮잠을 통해서 말이죠.",
      "자, 그럼 천천히 공간을 거닐어보세요.",
      "무릎을 들고, 발을 앞으로 뻗어보세요.",
      "하셨나요?",
      "참 잘했어요.",
      "맞아요. 그래 맞아요. 우리는 늘 그랬어요.",
      "우리는 언제나 타자와 함께 존재해 왔습니다.",
      "가족, 친구, 교수님, 지나가는 그들,",
      "그리고 당신과 처음 만나는 저도 우리는 늘 함께 존재해왔습니다",
      "그러나 어느 순간 '너'로 불리던 그들은 '그것'으로 전락하기 시작했습니다.",
      "이유는 아무도 몰라요.",
      "그저 우리가 '너'들을 '그것'들로 부르기 시작한 것일까요?",
      "이유는 아무도 모르죠.",
      "아...",
      "갑자기 김춘추의 <꽃>이 떠오르네요.",
      "(진지한 톤으로) 내가 그의 이름을 불러주기 전에는 그는 다만 하나의 몸짓에 지나지 않았다.",
      "크으으으으으으....",
      "네. 각설하고.",
      "말씀드린 것처럼, 이제 우리는 어느 곳에서도 '너'를 찾아볼 수 없습니다.",
      "우리는 이제 '너'가 사라진 세상에 살아가고 있으니까요.",
      "그런 특정했던 '너'는 서서히 희미해지고 퇴색되고 잊혀지고 잃어지고 앓아가고 있습니다",
      "마치 꿈 속에서 만난 누군가가",
      "...",
      "그게 누구였지?",
      "...",
      "하고 떠오르지 않는 것처럼",
      " '너'가 사라진 공간",
      " '너'가 제거된 공간",
      " '너'를 제거해버린 공간",
      `${displayName}의 내면 세계`,
      `이제 곧 ${displayName}의 내면 세계로 발을 디딥니다`,
      "두 번의 심호흡을 하기도 하면서,",
      "후 --",
      "하- ,",
      "후 ....",
      "하 ~",
      "이제 눈으로 감고,",
      "천천히 수면 아래로 내려갑니다.",
      "귀를 기울여 '보세요'",
      "내면의 미로를 탐험하여 사라진 '너'의 소리에",
      "말이 길었습니다.",
      "잠시 후에 만나요.",
      "수면으로",
      "내려갑니다."
    ];
  }

  function getFrameRect(){
    return document.querySelector('.frameBox').getBoundingClientRect();
  }
  function fitTitleLine(el){
    if(!el) return;
    const fr=getFrameRect();
    const maxW=Math.min(window.innerWidth*0.96, fr.width*0.90);
    const cs=getComputedStyle(el);
    let size=parseFloat(cs.fontSize)||48;
    el.style.whiteSpace='nowrap';
    while(el.scrollWidth>maxW && size>16){
      size*=0.94;
      el.style.fontSize=size+'px';
    }
  }
  function fitTitleLineSafe(){
    fitTitleLine(introBigText);
  }
  window.addEventListener('load', fitTitleLineSafe);

  const PIXEL_SPRITE=[
    "..XXXXXX....",
    ".XXXXXXXX...",
    ".XX.XX.XX...",
    ".XXXXXXXX...",
    "..XXXXXX....",
    ".XXXXXXXX...",
    ".XXXXXXXX...",
    ".XX.XX.XX...",
    ".XXXXXXXX...",
    "..XXXXXX....",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    "..XX..XX....",
    "..XX..XX...."
  ];
  const COLOR_FILL='#ff8a3c';
  const COLOR_STROKE='#000';

  function drawPixelHuman(ctx, cx, baselineY, W, hop=0, alpha=1){
    const cell=Math.max(2, Math.min(4, Math.floor(W*0.0018)));
    const cols=PIXEL_SPRITE[0].length;
    const rows=PIXEL_SPRITE.length;
    const width=cols*cell;
    const height=rows*cell;
    const x0=Math.round(cx-width/2);
    const y0=Math.round(baselineY-height-hop);

    ctx.globalAlpha=alpha;
    ctx.fillStyle=COLOR_STROKE;
    for(let y=0;y<rows;y++){
      const row=PIXEL_SPRITE[y];
      for(let x=0;x<cols;x++){
        if(row[x]==='X'){
          ctx.fillRect(x0+x*cell-1,y0+y*cell,cell,cell);
          ctx.fillRect(x0+x*cell+1,y0+y*cell,cell,cell);
          ctx.fillRect(x0+x*cell,y0+y*cell-1,cell,cell);
          ctx.fillRect(x0+x*cell,y0+y*cell+1,cell,cell);
        }
      }
    }
    ctx.fillStyle=COLOR_FILL;
    for(let y=0;y<rows;y++){
      const row=PIXEL_SPRITE[y];
      for(let x=0;x<cols;x++){
        if(row[x]==='X'){
          ctx.fillRect(x0+x*cell,y0+y*cell,cell,cell);
        }
      }
    }
    ctx.globalAlpha=1;
  }

  function getProsceniumRect(){
    const r=getFrameRect();
    return {x:r.left,y:r.top,w:r.width,h:r.height};
  }

  function spiralPos(t01){
    const pr=getProsceniumRect();
    const baselineY=Math.round(
      pr.y+pr.h*0.60-(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--char-offset-vh'))/100)*pr.h
    );
    const R=Math.round(pr.x+pr.w*0.92);
    const cx=pr.x+pr.w*0.46;
    const cy=baselineY-pr.h*0.06;
    const turns=2.2;
    const theta=turns*Math.PI*2*t01;
    const r0=pr.w*0.22;
    const r1=pr.w*0.02;
    const r=r0+(r1-r0)*t01;
    let sx=cx+r*Math.cos(theta);
    let sy=cy+r*Math.sin(theta);
    const pull=t01*t01;
    sx=sx*(1-pull)+R*pull;
    sy=sy*(1-pull)+baselineY*pull;
    return {x:sx,y:sy,baselineY};
  }

  function drawBubble(ctx, x, y, text){
    const pad=6, r=6;
    ctx.font='12px "Courier New", monospace';
    const m=ctx.measureText(text);
    const w=Math.max(28,m.width+pad*2);
    const h=18+pad*2;
    const bx=Math.round(x-w/2);
    const by=Math.round(y-h-18);
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.85)';
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(bx+r,by);
    ctx.arcTo(bx+w,by,bx+w,by+h,r);
    ctx.arcTo(bx+w,by+h,bx,by+h,r);
    ctx.arcTo(bx,by+h,bx,by,r);
    ctx.arcTo(bx,by,bx+w,by,r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x-6,by+h-1);
    ctx.lineTo(x,by+h+6);
    ctx.lineTo(x+6,by+h-1);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle=ACCENT;
    ctx.fillText(text,bx+pad,by+pad+12);
    ctx.restore();
  }

  let introWalking=false, introStartTime=0;
  const INTRO_WALK_DURATION=60_000;
  let bubbleSeq=[
    "HELLO","…","HI","…","HELLO!","…",
    "…헤헤","기억나?","여기 있어.","…쉿","보고 있어",
    "꿈이야?","아냐","…조금 더 가까이","같이 갈래?",
    "손… 잡을래?","…응","괜찮아","거기 있어",
    "작게 불러","내 이름"
  ];
  let bubbleTimer=0, bubbleIdx=0;

  /* 인트로: 문장 단위 + NEXT + 한 줄씩 타이핑 */
  let introSentences = [];
  let introIdx = 0;
  let introActive = false;
  let introIsTyping = false;

  async function typeIntroSentence(text){
    introIsTyping = true;
    introOverlayText.innerHTML = '';
    const span = document.createElement('span');
    introOverlayText.appendChild(span);
    for(let i=0;i<text.length;i++){
      span.textContent += text[i];
      typeTick();
      await sleep(40);
    }
    introIsTyping = false;
  }

  function showIntroSentence(){
    if(!introActive) return;
    if(introIsTyping) return;
    if(introIdx >= introSentences.length){
      introActive = false;
      fadeHide(introOverlay, 600);
      (async ()=>{
        await playTduung();
        startTransition();
      })();
      return;
    }
    const line = introSentences[introIdx++];
    typeIntroSentence(line);
  }

  function startIntroSentences(){
    introSentences = getIntroSentences();
    introIdx = 0;
    introActive = true;
    fadeShow(introOverlay, 400, 'flex');
    showIntroSentence();
  }

  async function showIntroFlow(){
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.2, 1.0);

    introBig.style.display='flex';
    introBig.style.opacity='0';
    await nextFrame();
    fitTitleLine(introBigText);
    introBig.style.transition='opacity 800ms ease';
    introBig.style.opacity='1';
    await sleep(1200);
    introBig.style.opacity='0';
    await sleep(700);
    introBig.style.display='none';

    introWalking=true;
    introStartTime=performance.now();
    showIntroLayer=true;
    fgAlpha=1.0;

    startIntroSentences();
  }

  introNext.addEventListener('click', ()=>{
    ensureResumed().then(async ()=>{
      await playWoongClick();
      showIntroSentence();
    });
  }, {passive:true});

  document.getElementById('goIntro').addEventListener('click', ()=>{
    ensureResumed().then(async ()=>{
      claimImmersive();
      if(!Ambient.isRunning()) Ambient.start(0.2,1.0);
      await playWoongClick();
      fadeHide(welcome, FADE);
      showIntroFlow();
    });
  });

  /* 4-minute Timer */
  let eightTimer=null, eightLeft=4*60;
  function formatMMSS(s){
    const m=Math.floor(s/60);
    const ss=(s%60).toString().padStart(2,'0');
    return `${m.toString().padStart(2,'0')}:${ss}`;
  }
  function startEightTimer(){
    eightLeft=4*60;
    runTimer.textContent=formatMMSS(eightLeft);
    runTimer.style.display='block';
    if(eightTimer) clearInterval(eightTimer);
    eightTimer=setInterval(()=>{
      eightLeft=Math.max(0,eightLeft-1);
      runTimer.textContent=formatMMSS(eightLeft);
      if(eightLeft<=0){
        clearInterval(eightTimer);
        eightTimer=null;
        onTimerEnded();
      }
    },1000);
  }

  async function onTimerEnded(){
    claimImmersive();
    await ensureResumed();
    await showSecondSleepIntro();
  }

  /* Mic FX */
  let micStream=null, micSrc=null, panNode=null, lpf=null, lowshelf=null, highshelf=null, revConvolver=null, dryGain=null, wetGain=null, micPreGain=null;
  function makeImpulse(ctx, seconds=6.0, decay=8.0){
    const rate=ctx.sampleRate;
    const len=rate*seconds;
    const ir=ctx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const data=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len;
        data[i]=(Math.random()*2-1)*Math.pow(1-t,decay);
      }
    }
    return ir;
  }

  async function startMicFXFadeIn(fadeSec=4.0){
    try{
      await ensureResumed();
      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({
          audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false},
          video:false
        });
      }
      if(!micSrc){
        micSrc = audioCtx.createMediaStreamSource(micStream);
      }

      micPreGain = audioCtx.createGain();
      micPreGain.gain.value = 1.8;

      lowshelf = audioCtx.createBiquadFilter();
      highshelf = audioCtx.createBiquadFilter();
      lpf = audioCtx.createBiquadFilter();
      panNode = audioCtx.createStereoPanner();

      lpf.type='lowpass';
      lpf.frequency.value=2800;
      lpf.Q.value=0.3;

      lowshelf.type='lowshelf';
      lowshelf.frequency.value=350;
      lowshelf.gain.value=0;

      highshelf.type='highshelf';
      highshelf.frequency.value=3500;
      highshelf.gain.value=0;

      revConvolver = audioCtx.createConvolver();
      revConvolver.buffer = makeImpulse(audioCtx, 6.0, 8.0);

      dryGain = audioCtx.createGain();
      wetGain = audioCtx.createGain();
      dryGain.gain.value = 0.0;
      wetGain.gain.value = 0.0;

      const out = audioCtx.createGain();
      out.gain.value = 0.92;

      micSrc.connect(micPreGain);
      micPreGain.connect(lowshelf)
               .connect(highshelf)
               .connect(lpf)
               .connect(panNode);

      panNode.connect(dryGain);
      panNode.connect(revConvolver);
      revConvolver.connect(wetGain);

      dryGain.connect(out);
      wetGain.connect(out);
      out.connect(audioCtx.destination);

      window.addEventListener('deviceorientation', onTiltAudio, {passive:true});

      const t = audioCtx.currentTime;
      dryGain.gain.linearRampToValueAtTime(0.72, t+fadeSec);
      wetGain.gain.linearRampToValueAtTime(0.58, t+fadeSec);
    }catch(e){
      console.warn('startMicFX error', e);
    }
  }

  function onTiltAudio(e){
    if(!audioCtx || !panNode) return;

    const gamma = clamp(e.gamma ?? 0, -90, 90);
    panNode.pan.value = gamma / 90;

    const beta = clamp(e.beta ?? 0, -90, 90);

    if(lowshelf) {
      lowshelf.gain.value = (beta < 0) ? (beta / 90) * 10 : 0;
    }

    if(highshelf) {
      highshelf.gain.value = (beta > 0) ? (beta / 90) * 10 : 0;
    }

    if(lpf) {
      let cutoff;
      if(beta >= 0) {
        cutoff = 2800 + (beta / 90) * (4500 - 2800);
      } else {
        cutoff = 2800 + (beta / 90) * (2800 - 900);
      }
      lpf.frequency.value = clamp(cutoff, 900, 4500);
      lpf.Q.value = 0.2 + (Math.abs(beta) / 90) * 0.3;
    }

    if(wetGain && dryGain) {
      const tilt = Math.abs(beta) / 90;
      const wetBase = 0.42;
      const wetAmount = wetBase + tilt * 0.25;
      wetGain.gain.value = clamp(wetAmount, 0.35, 0.67);
      dryGain.gain.value = clamp(1.0 - wetGain.gain.value * 0.5, 0.5, 0.85);
    }
  }

  /* Camera & Render */
  let metaReady=false;
  async function startCameraFresh(warmupOnly=false){
    try{
      if(!camPermGranted){
        await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}, audio:true})
          .then(s=>{
            s.getTracks().forEach(t=>t.stop());
            camPermGranted=true;
          });
      }
      if(!camVideo){
        camVideo=document.createElement('video');
        camVideo.setAttribute('playsinline','');
        camVideo.autoplay=true;
        camVideo.playsInline=true;
        camVideo.muted=true;
      }
      if(!camStream){
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:{ideal:'environment'},
            width:{min:1280,ideal:1920},
            height:{min:720,ideal:1080},
            aspectRatio:{ideal:16/9}
          },
          audio:false
        });
        camVideo.srcObject=camStream;
      }
      await camVideo.play().catch(()=>{});
      if (camVideo.readyState < 1){
        await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
      }
      metaReady=true;
      resizeAll();
      warmupFrames=0;

      if(!vctx){
        vctx=view.getContext('2d',{alpha:false});
      }
      if(!fgctx){
        fgctx=fg.getContext('2d',{alpha:true});
      }
      resizeAll();
      if(!animStarted && !warmupOnly){
        animStarted=true;
        loop();
      }
      document.querySelectorAll('.uiBtn').forEach(b=>{
        b.addEventListener('click', ()=>{
          ensureResumed().then(playWoongClick);
        }, {passive:true});
      });
    }catch(e){
      console.warn('startCameraFresh error:', e);
    }
  }

  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    if(vctx) vctx.setTransform(dpr,0,0,dpr,0,0);
    fg.width=w*dpr;
    fg.height=h*dpr;
    if(fgctx) fgctx.setTransform(dpr,0,0,dpr,0,0);
    if(nameCityRunning) initNameCity(true);
  }
  addEventListener('resize', ()=>{
    setTimeout(resizeAll,30);
    warmupFrames=30;
  }, {passive:true});

  function drawBestCover(ctx, video, W, H, PW, PH){
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(!vw||!vh) return;
    function coverScore(rot){
      let rw=rot?vh:vw, rh=rot?vw:vh;
      const s=Math.max(PW/rw, PH/rh)*ZOOM;
      const dw=rw*s, dh=rh*s;
      const letter=Math.max(0,(PW-dw))+Math.max(0,(PH-dh));
      return {rot,s,dw,dh,letter};
    }
    const a=coverScore(false), b=coverScore(true);
    let best=(b.letter<a.letter)?b:a;
    ctx.save();
    if(best.rot){
      ctx.translate(PW/2,PH/2);
      ctx.rotate(Math.PI/2);
      ctx.globalAlpha=1.0;
      ctx.drawImage(video,-best.dh/2,-best.dw/2,best.dh,best.dw);
    }else{
      const dx=(PW-best.dw)/2;
      const dy=(PH-best.dh)/2;
      ctx.globalAlpha=1.0;
      ctx.drawImage(video,dx,dy,best.dw,best.dh);
    }
    ctx.restore();
    ctx.globalAlpha=1;
  }

  function loop(){
    requestAnimationFrame(loop);
    if(capturing) return;
    if(!vctx || !fgctx) return;

    const W=view.width/(devicePixelRatio||1);
    const H=view.height/(devicePixelRatio||1);
    if(warmupFrames>0){
      resizeAll();
      warmupFrames--;
    }

    vctx.clearRect(0,0,W,H);
    vctx.imageSmoothingEnabled=true;
    if(camVideo && camVideo.readyState>=2){
      drawBestCover(vctx, camVideo, W, H, W, H);
    }

    const pr=getProsceniumRect();
    fgctx.clearRect(0,0,W,H);
    if(showIntroLayer && fgAlpha>0.001){
      fgctx.save();
      fgctx.globalAlpha=fgAlpha;
      fgctx.beginPath();
      fgctx.rect(pr.x,pr.y,pr.w,pr.h);
      fgctx.clip();

      if(introWalking){
        const now=performance.now();
        const tRaw=(now-introStartTime)/INTRO_WALK_DURATION;
        const t=Math.max(0,Math.min(1,tRaw));
        const pos=spiralPos(t);
        const hop=Math.max(0,10*Math.sin(t*Math.PI*20));
        drawPixelHuman(fgctx, Math.round(pos.x), Math.round(pos.baselineY), W, hop, 1);
        if(now-bubbleTimer>600){
          bubbleIdx=(bubbleIdx+1)%bubbleSeq.length;
          bubbleTimer=now;
        }
        drawBubble(fgctx, Math.round(pos.x), Math.round(pos.baselineY)-28, bubbleSeq[bubbleIdx]);
      }
      fgctx.restore();
    }
  }

  /* Capture */
  let captureAnimating=false;
  captureBtn.addEventListener('click', async ()=>{
    claimImmersive();
    if(captureAnimating) return;
    await ensureResumed();
    await playWoongClick();
    captureAnimating=true;
    capturing=true;
    const cssW=view.clientWidth;
    const cssH=view.clientHeight;
    freezeLayer.width=cssW;
    freezeLayer.height=cssH;
    const displayCtx=freezeLayer.getContext('2d');
    displayCtx.imageSmoothingEnabled=false;
    freezeLayer.style.transition='';
    freezeLayer.style.opacity='0';
    freezeLayer.style.display='block';

    const snapshot=document.createElement('canvas');
    snapshot.width=cssW;
    snapshot.height=cssH;
    const snapCtx=snapshot.getContext('2d');
    snapCtx.imageSmoothingEnabled=false;
    snapCtx.drawImage(view,0,0,view.width,view.height,0,0,cssW,cssH);
    snapCtx.drawImage(fg,0,0,fg.width,fg.height,0,0,cssW,cssH);

    const off=document.createElement('canvas');
    const oc=off.getContext('2d');
    let px=2.4;
    const step=1.015;
    let revealed=false;
    function anim(){
      if(px>420){
        freezeLayer.style.transition='opacity 2000ms ease';
        freezeLayer.style.opacity='0';
        setTimeout(()=>{
          freezeLayer.style.display='none';
          freezeLayer.style.transition='';
          capturing=false;
          captureAnimating=false;
        },2020);
        return;
      }
      const w=Math.max(1,Math.floor(cssW/px));
      const h=Math.max(1,Math.floor(cssH/px));
      off.width=w;
      off.height=h;
      oc.imageSmoothingEnabled=false;
      oc.clearRect(0,0,w,h);
      oc.drawImage(snapshot,0,0,cssW,cssH,0,0,w,h);
      displayCtx.clearRect(0,0,cssW,cssH);
      displayCtx.imageSmoothingEnabled=false;
      displayCtx.globalAlpha=1.0;
      displayCtx.drawImage(off,0,0,w,h,0,0,cssW,cssH);
      if(!revealed){
        freezeLayer.style.opacity='1';
        revealed=true;
      }
      px=px*step+0.35;
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  });

  /* Intro → FIRST SLEEP transition */
  function fadeIntroLayerOut(ms=8000){
    const t0=performance.now();
    const startAlpha=fgAlpha;
    function step(){
      const k=Math.min(1,(performance.now()-t0)/ms);
      fgAlpha=startAlpha*(1-k);
      if(k<1){
        requestAnimationFrame(step);
      }else{
        fgAlpha=0;
        showIntroLayer=false;
        const W=view.width/(devicePixelRatio||1);
        const H=view.height/(devicePixelRatio||1);
        fgctx && fgctx.clearRect(0,0,W,H);
      }
    }
    step();
  }

  async function startTransition(){
    Ambient.stop(4.0);

    claimImmersive();
    await ensureResumed();

    // THE FIRST SLEEP / SLEEEEEEEEP 블록 표시
    firstSleep.style.display='flex';
    firstSleep.style.opacity='1';
    firstSleep.style.transition='opacity 800ms ease';
    firstSleepTop.textContent='';
    firstSleepText.style.opacity='0';
    firstSleepText.style.transition='opacity 900ms ease';

    // 타이머, 컨트롤, 마이크, 인트로 레이어 페이드 아웃 동시에 시작
    startEightTimer();
    await nextFrame();
    controls.classList.add('show');
    captureBtn.classList.add('show');
    startMicFXFadeIn(4.0);
    fadeIntroLayerOut(8000);

    // "SLEEEEEEEEP" (E 8개) 타이핑
    for(let i=0;i<SLEEP_WORD.length;i++){
      firstSleepTop.textContent += SLEEP_WORD[i];
      typeTick();
      await sleep(110);
    }

    // 약간 쉬고 "THE FIRST SLEEP" 페이드 인
    await sleep(200);
    firstSleepText.style.opacity='1';

    // 3초 유지
    await sleep(3000);

    // 전체 페이드 아웃
    firstSleep.style.opacity='0';
    await sleep(1200);
    firstSleep.style.display='none';
    firstSleepText.style.transition='';

    // 1장 NOTICE 등장
    showNoticePopup();
  }

  function showNoticePopup(){
    function bgTrap(e){
      if(!e.target.closest('#noticeCard')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup.addEventListener(ev, bgTrap, {passive:false});
    });
    fadeShow(noticePopup, 280, 'flex');
    setTimeout(()=>{
      noticeOk && noticeOk.focus && noticeOk.focus();
    }, 50);
    noticeOk.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      await playWoongClick();
      fadeHide(noticePopup, 250);
      await sleep(260);
      startFirstSleepStory();
    };
  }

  /* FIRST SLEEP: 문장 리스트 (한 줄씩 → 2초 → 다음 줄) */
  const firstSleepLines = [
    "당신은 공간을 거닐고 있다.",
    "마침내 당신은 도시의 어둠, 그리고 스산한 안개 속으로 천천히 발을 내딛었다.",
    "지금은 새벽 4시. 당신은 축축하고 푹신한 수면 위로 걷는 느낌을 느낀다.",
    "뒤꿈치부터 발바닥을 거쳐 발가락까지 차례로 내리눌러보기도 하며, 당신이 서 있는 곳이 당신을 타고 올라오게 천천히 내버려둔다.",
    "당신은 어디선가 잔잔한 종 소리를 듣는다.",
    "당신은 잠시 후, 또 다시 어디선가 들려오는 아이들의 웃음 소리를 듣는다.",
    "당신은 지금 내면의 바다를 듣고 있다.",
    "갑자기 프란츠 카프카의 <학술원에 보내는 보고서>라는 소설이 떠올랐다.",
    "소설은 아프리카 해안 어느 숲 속에서 무한한 자유를 누리며 원숭이답게 살아가는 빨간 피터라는 원숭이의 이야기를 다루고 있다.",
    "그러던 어느날 피터의 앞으로 백인들은 그를 잡아가 우리에 가둔다.",
    "난생 처음 우리에 가둔 피터는 처음으로 고민에 빠진다.",
    "탈출을 할 것인가? 혹은 그대로 있을 것인가?",
    "그러던 중 피터가 마지막으로 한 선택은 인간들처럼 되기 위한 선택을 내린다.",
    "침을 뱉고, 술을 마시고, 악수를 하고, 담배를 태우며 서서히 인간 세계의 일원이 되어가는 것이다.",
    "사람들을 흉내 내는 일은 전혀 어렵지 않았습니다.",
    "침 뱉기는 며칠만에 거뜬히 배웠죠. 파이프 담배도 곧 영감처럼 피웠어요.",
    "가장 어려웠던 것은 술병이었습니다.",
    "냄새가 지독했거든요.",
    "저는 그동안 배운 대로 코르크 마개를 빼고 술병을 입에 갖다 댔죠.",
    "그러곤 전혀 망설임 없이 표정 하나 변하지 않고 술을 들이켰어요.",
    "진짜 술꾼처럼 눈동자도 데굴데굴 굴리고, 꿀꺽꿀꺽 소리도 내면서 그야말로 남김없이 술병을 비워버린 겁니다.",
    "참을 수 없는 충동에 정신이 멍해져서 \"헬로!\"하고 짤막하게 외쳤습니다.",
    "인간의 소리를 내뱉은 거였죠.",
    "이 한마디의 외침으로 저는 인간세계에 뛰어들었고, 거기엔 반향이 뒤따랐습니다.",
    " \"들어 봐, 저놈이 말을 해!\"",
    "그 반향은 땀방울이 뚝뚝 떨어지는 제 온몸에 쏟아지는 입맞춤 같았답니다."
  ];

  async function typeBoxedTextLine(el, text, charDelay){
    for(let i=0;i<text.length;i++){
      const ch = text[i];
      const span = document.createElement('span');
      span.className = 'charBox';
      span.textContent = (ch === ' ' ? '\u00A0' : ch);
      el.appendChild(span);
      typeTick();
      await sleep(charDelay);
    }
  }

  async function startMorseSequence(){
    const pattern = "... . ... .. ... ..   .. .   ..... .   .  . ";
    chapterBox.innerHTML='';

    for(let i=0;i<pattern.length;i++){
      const ch = pattern[i];
      if(ch === '.'){
        const span = document.createElement('span');
        span.className='charBox';
        span.textContent='·';
        chapterBox.appendChild(span);
        typeTick();
        await sleep(120);
      }else if(ch === ' '){
        await sleep(80);
      }
      if(i>0 && i%18===0){
        chapterBox.appendChild(document.createElement('br'));
        await sleep(220);
      }
    }

    await sleep(1500);
    fadeHide(chapterOverlay, 1200);
  }

  async function startFirstSleepStory(){
    claimImmersive();
    await ensureResumed();
    chapterBox.innerHTML='';
    fadeShow(chapterOverlay, 400, 'flex');
    await sleep(420);

    for(const line of firstSleepLines){
      const trimmed = line;
      chapterBox.innerHTML='';            // 이전 문장 지우기
      await typeBoxedTextLine(chapterBox, trimmed, 45); // 한 줄 타이핑
      await sleep(2000);                  // 2초 유지
    }

    await sleep(2000);
    await startMorseSequence();
  }

  /* SECOND SLEEP 타이틀 + 2장 NOTICE */

  async function showSecondSleepIntro(){
    fadeHide(chapterOverlay, 800);

    secondSleep.style.display='flex';
    secondSleep.style.opacity='1';
    secondSleep.style.transition='opacity 800ms ease';
    secondSleepLine1.textContent='';
    secondSleepLine2.textContent='';
    secondSleepText.style.opacity='0';
    secondSleepText.style.transition='opacity 900ms ease';

    // SLEEEEEEEEP 1줄
    for(let i=0;i<SLEEP_WORD.length;i++){
      secondSleepLine1.textContent += SLEEP_WORD[i];
      typeTick();
      await sleep(110);
    }
    await sleep(300);

    // SLEEEEEEEEP 2줄
    for(let i=0;i<SLEEP_WORD.length;i++){
      secondSleepLine2.textContent += SLEEP_WORD[i];
      typeTick();
      await sleep(110);
    }

    await sleep(250);
    secondSleepText.style.opacity='1';

    await sleep(3000);

    secondSleep.style.opacity='0';
    await sleep(1200);
    secondSleep.style.display='none';
    secondSleepText.style.transition='';

    showSecondNotice();
  }

  function showSecondNotice(){
    function bgTrap(e){
      if(!e.target.closest('#notice2Card')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      notice2Popup.addEventListener(ev, bgTrap, {passive:false});
    });
    fadeShow(notice2Popup, 280, 'flex');
    setTimeout(()=>{
      notice2Ok && notice2Ok.focus && notice2Ok.focus();
    }, 50);

    notice2Ok.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      await playWoongClick();
      fadeHide(notice2Popup, 250);
      // 여기서 THE SECOND SLEEP 체험 로직으로 넘어가면 됨
    };
  }

  /* ===== Name screen city ===== */
  let nameCityCtx = null;
  let nameBuildings = [];
  let nameCityRunning = false;
  let lastFlicker = 0;

  function initNameCity(keepRunning=false){
    if(!nameCityCanvas) return;
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;
    nameCityCanvas.width = w * dpr;
    nameCityCanvas.height = h * dpr;
    nameCityCtx = nameCityCanvas.getContext('2d');
    nameCityCtx.setTransform(dpr,0,0,dpr,0,0);

    nameBuildings = [];
    const baseGround = h * 0.82;

    const layers = [
      { depth:0, offsetY: h * 0.16, heightMul:0.45, shade:-8 },
      { depth:1, offsetY: h * 0.08, heightMul:0.65, shade:0 },
      { depth:2, offsetY: 0,       heightMul:0.85, shade:+5 }
    ];

    for(const layer of layers){
      let groundY = baseGround - layer.offsetY;
      const totalW = w;
      let x = -totalW * 0.1;
      const maxX = w + totalW * 0.1;

      while(x < maxX){
        const bw = Math.random()* (w * 0.04) + (w * 0.018);
        let bh = (Math.random()* (h * 0.3) + (h * 0.25)) * layer.heightMul;
        let bTop = groundY - bh;

        const minTop = h * 0.10;
        const maxBottom = h * 0.92;

        if(groundY > maxBottom) groundY = maxBottom;
        bTop = groundY - bh;
        if(bTop < minTop){
          bTop = minTop;
          bh = groundY - bTop;
        }

        const baseLight = 18 + layer.shade;
        const col = `hsl(${220 + Math.random()*10}, ${18+Math.random()*8}%, ${baseLight+Math.random()*8}%)`;

        const winW = bw * 0.16;
        const winH = winW * 1.1;
        const hGap = winW * 0.4;
        const vGap = winH * 0.5;
        const colsN = Math.max(1, Math.floor((bw - winW*0.4) / (winW + hGap)));
        const rowsN = Math.max(2, Math.floor((bh - winH*1.5) / (winH + vGap)));

        const windows = [];
        for(let iy=0; iy<rowsN; iy++){
          for(let ix=0; ix<colsN; ix++){
            const wx = x + (bw - (colsN*winW + (colsN-1)*hGap))/2 + ix*(winW+hGap);
            const wy = groundY - winH*1.2 - iy*(winH+vGap);
            const onInit = Math.random() < 0.2;
            windows.push({
              x: wx,
              y: wy,
              w: winW,
              h: winH,
              value: onInit ? 1.0 : 0.0,
              target: onInit ? 1.0 : 0.0
            });
          }
        }

        nameBuildings.push({
          x,
          width: bw,
          top: bTop,
          bottom: groundY,
          color: col,
          depth: layer.depth,
          windows
        });

        x += bw * (0.2 + Math.random()*0.3);
      }
    }

    if(!keepRunning && nameCityRunning){
      drawNameCity(performance.now());
    }
  }

  function drawNameCity(timestamp){
    if(!nameCityCtx) return;
    const w = window.innerWidth;
    const h = window.innerHeight;

    nameCityCtx.clearRect(0,0,w,h);
    nameCityCtx.fillStyle = '#000';
    nameCityCtx.fillRect(0,0,w,h);

    const grad = nameCityCtx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#050509');
    grad.addColorStop(1, '#050505');
    nameCityCtx.fillStyle = grad;
    nameCityCtx.fillRect(0,0,w,h);

    const sorted = [...nameBuildings].sort((a,b)=>a.bottom - b.bottom);

    for(const b of sorted){
      nameCityCtx.fillStyle = b.color;
      nameCityCtx.fillRect(b.x, b.top, b.width, b.bottom - b.top);

      nameCityCtx.fillStyle = 'rgba(0,0,0,0.6)';
      nameCityCtx.fillRect(b.x, b.top - 3, b.width, 3);

      for(const wv of b.windows){
        const speed = 0.02;
        wv.value += (wv.target - wv.value) * speed;

        const v = clamp(wv.value, 0, 1);
        const off = { r:20, g:20, b:30 };
        const on  = { r:255, g:216, b:64 }; // 노란 불빛
        const r = off.r + (on.r - off.r) * v;
        const g = off.g + (on.g - off.g) * v;
        const bcol = off.b + (on.b - off.b) * v;
        nameCityCtx.fillStyle = `rgba(${r|0},${g|0},${bcol|0},0.95)`;
        nameCityCtx.fillRect(wv.x, wv.y, wv.w, wv.h);
      }
    }

    if(timestamp - lastFlicker > 2800){
      lastFlicker = timestamp;
      for(const b of nameBuildings){
        for(const wv of b.windows){
          if(Math.random() < 0.08){
            wv.target = (wv.target > 0.5) ? 0.0 : 1.0;
          }
        }
      }
    }
  }

  function stepNameCity(ts){
    if(!nameCityRunning) return;
    drawNameCity(ts);
    requestAnimationFrame(stepNameCity);
  }

  function startNameCity(){
    nameCityRunning = true;
    initNameCity();
    requestAnimationFrame(stepNameCity);
  }

  function stopNameCity(){
    nameCityRunning = false;
  }

  /* Camera warmup */
  startCameraFresh(true);
})();
</script>
</body>
</html>
