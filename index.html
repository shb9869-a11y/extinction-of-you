<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Dialogue into Silence — Game Only</title>
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Dialogue into Silence">
<style>
  :root{
    --safe-t: env(safe-area-inset-top, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);
  }
  html,body{
    margin:0;height:100%;background:#000;overscroll-behavior:none;
    touch-action:manipulation
  }
  /* 화면 한가운데, 캔버스만 */
  #wrap{
    position:fixed; inset:0;
    padding:var(--safe-t) var(--safe-r) var(--safe-b) var(--safe-l);
    display:grid; place-items:center;
  }
  #gameCanvas{
    image-rendering:pixelated; image-rendering:crisp-edges;
    background:#000; display:block;
  }

  /* 모바일 D-패드 (데스크톱은 숨김) */
  #dpad{
    position:fixed; left:calc(10px + var(--safe-l)); bottom:calc(10px + var(--safe-b));
    display:none; grid-template-columns:repeat(3,56px); grid-template-rows:repeat(3,56px); gap:8px; z-index:10;
  }
  #dpad .k{
    width:56px;height:56px;border:1px solid #444;background:#000;color:#fff;
    opacity:.8;display:flex;align-items:center;justify-content:center;font:700 14px "Courier New",monospace;
    user-select:none;-webkit-user-select:none;border-radius:10px;
  }
  #dpad .k:active{opacity:1}
  @media (pointer:coarse){ #dpad{display:grid;} }

  /* 대화/기록 모달 (흑백 미니멀) */
  #gameDialog{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20; background:rgba(0,0,0,.55);}
  #gameDialog .box{ min-width:260px; max-width:86vw; background:#111; color:#eee; border:1px solid #444; border-radius:10px; padding:12px; box-shadow:0 10px 24px rgba(0,0,0,.6); font:12px/1.6 "Courier New",monospace; }
  #gameDialog .box h3{ margin:0 0 8px; font:700 12px "Courier New",monospace; color:#f0f0f0; }
  #gameDialog .choices{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  #gameDialog .choices button{ padding:6px 10px; border-radius:8px; border:1px solid #555; background:#222; color:#fff; font:600 12px "Courier New",monospace; }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="gameCanvas" width="256" height="256" aria-label="Game canvas"></canvas>
  </div>
  <div id="dpad" aria-hidden="false">
    <div></div><div class="k" data-dy="-1">▲</div><div></div>
    <div class="k" data-dx="-1">◀</div><div class="k" data-dy="1">▼</div><div class="k" data-dx="1">▶</div>
    <div></div><div></div><div></div>
  </div>
  <!-- 대화/기록 -->
  <div id="gameDialog" role="dialog" aria-modal="true">
    <div class="box">
      <h3 id="dgTitle">기록</h3>
      <div id="dgBody">...</div>
      <div id="dgChoices" class="choices"></div>
    </div>
  </div>

<script>
(()=>{
  /* ===== 캔버스 최대화: 정수 배율로 ‘가능한 크게’ ===== */
  const canvas = document.getElementById('gameCanvas');
  const g = canvas.getContext('2d', { alpha:false });
  g.imageSmoothingEnabled = false;

  function fitCanvas(){
    const w = window.innerWidth - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-l'))||0) - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-r'))||0);
    const h = window.innerHeight - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-t'))||0) - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-b'))||0);
    const scale = Math.max(1, Math.floor(Math.min(w/canvas.width, h/canvas.height))); // 정수배
    canvas.style.width  = (canvas.width * scale) + 'px';
    canvas.style.height = (canvas.height * scale) + 'px';
  }
  addEventListener('resize', ()=>setTimeout(fitCanvas, 50), {passive:true});
  addEventListener('orientationchange', ()=>setTimeout(fitCanvas, 120), {passive:true});
  fitCanvas();

  /* ====== 색상 팔레트(흑백) ====== */
  const C={
    bg:'#111', plate:'#1b1b1b', plate2:'#0f0f0f', border:'#2a2a2a', dot:'#242424',
    grave:'#bbbbbb', graveDark:'#666666', shadow:'rgba(0,0,0,.55)',
    seekerBody:'#cccccc', seekerEye:'#eeeeee',
    player:'#ffffff', playerDark:'#aaaaaa',
    brick:'#444444', brickDark:'#222222', phone:'#dddddd', phoneDial:'#bdbdbd'
  };

  /* ====== 레벨/맵 (비석의 방 & 전화기의 방) ====== */
  const TILE=16, MAP_W=16, MAP_H=16;
  const off = document.createElement('canvas'); off.width=256; off.height=256; const og = off.getContext('2d'); og.imageSmoothingEnabled=false;

  const LEVEL0=Array.from({length:MAP_H},()=>Array(MAP_W).fill(1));
  for(let y=2;y<MAP_H-1;y+=2){ for(let x=1;x<MAP_W-1;x++) LEVEL0[y][x]=0; }
  for(let x=2;x<MAP_W-1;x+=2){ for(let y=1;y<MAP_H-1;y++) LEVEL0[y][x]=0; }
  for(let y=1;y<5;y++) for(let x=12;x<15;x++) LEVEL0[y][x]=0;
  LEVEL0[8][8]=0; LEVEL0[7][8]=0; LEVEL0[8][7]=0; LEVEL0[8][9]=0;
  for(let x=6;x<=9;x++) LEVEL0[MAP_H-1][x]=0;

  const LEVEL1=Array.from({length:MAP_H},()=>Array(MAP_W).fill(0));
  for(let x=0;x<MAP_W;x++){ LEVEL1[0][x]=1; LEVEL1[MAP_H-1][x]=1; }
  for(let y=0;y<MAP_H;y++){ LEVEL1[y][0]=1; LEVEL1[y][MAP_W-1]=1; }
  for(let x=6;x<=9;x++) LEVEL1[MAP_H-1][x]=0;

  const PHONES=[[1,3],[1,6],[1,9],[1,12],[4,1],[7,1],[10,1],[14,3],[14,6],[14,9],[4,13],[7,13],[10,13],[13,13]];
  const phoneSet=new Set(PHONES.map(([x,y])=>`${x},${y}`));

  // 프리렌더
  function drawCommon(gg){ gg.fillStyle=C.bg; gg.fillRect(0,0,off.width,off.height);
    gg.fillStyle=C.border; gg.fillRect(6,6,off.width-12,off.height-12);
    gg.fillStyle=C.plate; gg.fillRect(12,12,off.width-24,off.height-24);
    gg.fillStyle=C.dot; for(let i=0;i<190;i++){ const x=12+((i*73)%(off.width-24)); const y=12+((i*97)%(off.height-24)); gg.fillRect(x,y,1,1); } }
  function dGrave(gg,px,py){ gg.fillStyle=C.shadow; gg.fillRect(px+2,py+TILE-3,TILE-2,2);
    gg.fillStyle=C.graveDark; gg.fillRect(px+3,py+3,TILE-6,TILE-6); gg.fillStyle=C.grave; gg.fillRect(px+2,py+4,TILE-6,TILE-7);
    gg.fillStyle='rgba(255,255,255,.08)'; gg.fillRect(px+3,py+4,TILE-8,1); }
  function dBrick(gg,px,py){ gg.fillStyle=C.brickDark; gg.fillRect(px,py,TILE,TILE); gg.fillStyle=C.brick; gg.fillRect(px+1,py+1,TILE-2,TILE-2); gg.fillStyle='rgba(0,0,0,.25)'; gg.fillRect(px+1,py+TILE-4,TILE-2,3); }
  function dPhone(gg,px,py){ gg.fillStyle=C.phone; gg.fillRect(px+2,py+5,12,8); gg.fillStyle=C.phoneDial; gg.fillRect(px+5,py+7,6,4); gg.fillStyle='rgba(255,255,255,.12)'; gg.fillRect(px+3,py+6,8,1); gg.fillStyle=C.shadow; gg.fillRect(px+2,py+TILE-2,12,2); }

  const layer0=(function(){ const c=document.createElement('canvas'); c.width=off.width; c.height=off.height; const gg=c.getContext('2d'); gg.imageSmoothingEnabled=false;
    drawCommon(gg); for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL0[y][x]===1) dGrave(gg,x*TILE,y*TILE);
    gg.fillStyle=C.plate2; gg.fillRect(6*TILE,15*TILE,4*TILE,TILE); return c; })();
  const layer1=(function(){ const c=document.createElement('canvas'); c.width=off.width; c.height=off.height; const gg=c.getContext('2d'); gg.imageSmoothingEnabled=false;
    drawCommon(gg); for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL1[y][x]===1) dBrick(gg,x*TILE,y*TILE);
    for(const [x,y] of PHONES) dPhone(gg,x*TILE,y*TILE);
    gg.fillStyle=C.plate2; gg.fillRect(6*TILE,15*TILE,4*TILE,TILE); return c; })();

  /* ====== 엔티티 ====== */
  function makePlayer(x,y){ return {x,y,spd:0.09,anim:0,stepTimer:0,stepPhase:0}; }
  function makeSeeker(x,y){ return {x,y,spd:0.07,path:[],target:null,repathAt:0}; }
  const player=makePlayer(13.5,2.5);
  const seeker=makeSeeker(8.5,8.5);

  /* ====== 입력 (키보드 + D-패드) ====== */
  const keys=new Set();
  addEventListener('keydown',e=>{const k=e.key.toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','e'].includes(k)) e.preventDefault(); keys.add(k);});
  addEventListener('keyup',e=> keys.delete(e.key.toLowerCase()));

  const dpad=document.getElementById('dpad'), heldDirs=new Set(), dpadState={ax:0,ay:0};
  function updateDirFromHeld(){ let ax=0,ay=0; if(heldDirs.has('left')) ax-=1; if(heldDirs.has('right')) ax+=1; if(heldDirs.has('up')) ay-=1; if(heldDirs.has('down')) ay+=1; dpadState.ax=ax; dpadState.ay=ay; }
  dpad.addEventListener('pointerdown',e=>{ const dx=e.target.getAttribute('data-dx'); const dy=e.target.getAttribute('data-dy'); if(dx) heldDirs.add(+dx<0?'left':'right'); if(dy) heldDirs.add(+dy<0?'up':'down'); updateDirFromHeld(); e.preventDefault(); },{passive:false});
  dpad.addEventListener('pointerup',()=>{ heldDirs.clear(); updateDirFromHeld(); },{passive:true});
  dpad.addEventListener('pointercancel',()=>{ heldDirs.clear(); updateDirFromHeld(); });

  /* ====== 충돌/이동 ====== */
  let room=0; // 0: 비석의 방, 1: 전화기의 방
  function solidAt(tx,ty){
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return true;
    if(room===0) return LEVEL0[ty][tx]===1;
    if(LEVEL1[ty][tx]===1) return true;
    if(phoneSet.has(`${tx},${ty}`)) return true;
    return false;
  }
  function moveEntity(e,ax,ay){ const spd=e.spd; let nx=e.x+ax*spd, ny=e.y+ay*spd;
    if(!solidAt(nx|0, e.y|0)) e.x=nx; if(!solidAt(e.x|0, ny|0)) e.y=ny;
  }

  /* ====== 대화/기록 ====== */
  const dlg=document.getElementById('gameDialog'), dgTitle=document.getElementById('dgTitle'), dgBody=document.getElementById('dgBody'), dgChoices=document.getElementById('dgChoices');
  function closeDialog(){ dlg.style.display='none'; dgChoices.innerHTML=''; inConvo=false; }
  dlg.addEventListener('click',(e)=>{ if(e.target===dlg) closeDialog(); });

  function graveText(x,y){ const lines=["나는 얼굴을 잃고, 귀로만 걷는다.","빛이 고요를 문질러 소리가 났다.","오차가 감정이고, 잔향이 초상이다.","돌은 서 있고, 이야기는 흘러간다.","너와 나 사이, 빈칸이 숨을 쉰다.","시간의 모서리에 귀를 댔다.","여기 눕힌 건 말들이다.","망각의 틈에서 작은 불이 켜진다."]; const idx=(x*31+y*17)%lines.length; return lines[idx]; }
  function nearestGrave(px,py){ let best=null,bd=1e9; for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL0[y][x]===1){ const cx=x+0.5, cy=y+0.5; const d=Math.hypot(px-cx,py-cy); if(d<bd){bd=d; best={x,y,cx,cy};}} return {grave:best, dist:bd}; }
  function nearestPhone(px,py){ let best=null,bd=1e9; for(const [x,y] of PHONES){ const cx=x+0.5, cy=y+0.5; const d=Math.hypot(px-cx,py-cy); if(d<bd){bd=d; best={x,y,cx,cy};}} return {phone:best, dist:bd}; }

  const convo=[
    {npc:"……신호 포착. 너는 소리를 어떻게 듣지?",choices:["몸으로 먼저 듣는다.","기억으로 해석한다."],replies:["좋아. 몸은 진실을 숨기지 않지.","그래, 기억은 언제나 편집본이야."]},
    {npc:"여기 비석들은 잊힌 말들의 좌표야.",choices:["좌표를 따라가면 어디에 닿을까?","말이 사라지면 무엇이 남지?"],replies:["아마 네가 모르는 너에게.","침묵. 그리고 방향."]},
    {npc:"마지막 질문. 너는 왜 계속 걷고 있어?",choices:["누군가의 잔향을 찾고 있어.","멈추면, 들리지 않을까 봐."],replies:["그 잔향이 네 지도를 바꿀 거야.","걷는 침묵은 언제나 열려 있지."]}
  ];
  let inConvo=false, stepIdx=0;
  function openRobotConvo(){ inConvo=true; stepIdx=0; renderConvoStep(); dlg.style.display='flex'; }
  function renderConvoStep(){
    dgTitle.textContent='로봇(비석의 방 순찰)'; const s=convo[stepIdx];
    dgBody.innerHTML=`<div style="white-space:pre-wrap">${s.npc}</div>`; dgChoices.innerHTML='';
    s.choices.forEach((text,i)=>{ const b=document.createElement('button'); b.textContent=text;
      b.onclick=()=>{ const reply=s.replies[i]; dgBody.innerHTML+=`\n\n> 너: ${text}\n로봇: ${reply}`; stepIdx++; if(stepIdx<convo.length){ setTimeout(()=>renderConvoStep(),420);} else { dgChoices.innerHTML=''; const done=document.createElement('button'); done.textContent='끝내기'; done.onclick=()=>{ inConvo=false; dlg.style.display='none'; }; dgChoices.appendChild(done);} };
      dgChoices.appendChild(b);
    });
  }

  /* ====== 로봇 순찰 ====== */
  function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
  function randomWalkableTile0(){ let tx,ty; do{ tx=(Math.random()*MAP_W)|0; ty=(Math.random()*MAP_H)|0; }while(LEVEL0[ty]?.[tx]!==0); return {tx,ty}; }
  function bfsPath(level, fromX,fromY,toX,toY){
    const Q=[[fromX,fromY]], V=new Set([fromX+','+fromY]), P={}, dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const solid=(x,y)=>{ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return true; return level===0 ? (LEVEL0[y][x]===1) : (LEVEL1[y][x]===1 || phoneSet.has(`${x},${y}`)); };
    while(Q.length){
      const [x,y]=Q.shift(); if(x===toX&&y===toY) break;
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy; if(solid(nx,ny)) continue;
        const k=nx+','+ny; if(V.has(k)) continue; V.add(k); P[k]=[x,y]; Q.push([nx,ny]);
      }
    }
    const key=toX+','+toY; if(!(key in P) && !(fromX===toX && fromY===toY)) return [];
    let path=[[toX,toY]]; let cx=toX, cy=toY;
    while(!(cx===fromX && cy===fromY)){ const prev=P[cx+','+cy]; if(!prev) break; path.push(prev); cx=prev[0]; cy=prev[1]; }
    path.reverse(); return path;
  }
  const seekerObj={ensureTarget(force=false){
    if(room!==0||inConvo) return;
    const now=performance.now();
    if(force || !seeker.target || now>seeker.repathAt || seeker.path.length===0){
      let t=randomWalkableTile0(), tries=0;
      while(dist({x:t.tx+0.5,y:t.ty+0.5}, player)<3 && tries++<10) t=randomWalkableTile0();
      seeker.target=t; const sx=seeker.x|0, sy=seeker.y|0;
      seeker.path=bfsPath(0, sx,sy,t.tx,t.ty); seeker.repathAt=now+5000+Math.random()*5000;
    }
  }, step(){
    if(room!==0||inConvo) return;
    this.ensureTarget();
    if(seeker.path.length>0){
      const [nx,ny]=seeker.path[0], tx=nx+0.5, ty=ny+0.5; const dx=tx-seeker.x, dy=ty-seeker.y, m=Math.hypot(dx,dy);
      if(m<0.05){ seeker.x=tx; seeker.y=ty; seeker.path.shift(); } else { const ax=dx/m, ay=dy/m; moveEntity(seeker,ax,ay); }
    } else this.ensureTarget(true);
  }};

  /* ====== 업데이트/렌더 ====== */
  function drawSeeker(){ if(room!==0) return; const px=Math.round(seeker.x*TILE - TILE/2), py=Math.round(seeker.y*TILE - TILE/2);
    og.fillStyle=C.seekerBody; og.fillRect(px+3,py+6,10,6); og.fillStyle='#ffffff'; og.fillRect(px+2,py+4,12,6);
    og.fillStyle=C.seekerEye; og.fillRect(px+5,py+6,2,2); og.fillStyle=C.seekerEye; og.fillRect(px+9,py+6,2,2);
    og.fillStyle='#111'; og.fillRect(px+1,py+8,2,3); og.fillRect(px+13,py+8,2,3); }
  function drawPlayer(p){ const px=Math.round(p.x*TILE - TILE/2), py=Math.round(p.y*TILE - TILE/2);
    og.fillStyle=C.shadow; og.fillRect(px+2,py+TILE-2,TILE-4,2); og.fillStyle=C.player; og.fillRect(px+4,py+5,8,7);
    og.fillStyle=C.playerDark; og.fillRect(px+4,py+4,8,2); if(((p.anim*10)|0)%20<10){ og.fillStyle='#000'; og.fillRect(px+6,py+7,1,1); og.fillRect(px+9,py+7,1,1);} }

  function render(){
    og.clearRect(0,0,off.width,off.height);
    og.drawImage(room===0 ? layer0 : layer1, 0, 0);
    drawSeeker(); drawPlayer(player);

    // 화면 중앙에 꽉 채우기(정수 배율 유지)
    g.clearRect(0,0,canvas.width,canvas.height);
    const scale = Math.max(1, Math.floor(Math.min(canvas.clientWidth/off.width, canvas.clientHeight/off.height)));
    const dw = off.width*scale, dh = off.height*scale, dx = (canvas.clientWidth - dw)/2, dy = (canvas.clientHeight - dh)/2;
    // 실제 캔버스 크기에 맞춰 다시 그림
    g.save();
    // 캔버스 내부 CSS 크기와 실제 해상도 싱크
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.round(canvas.clientWidth * dpr);
    canvas.height = Math.round(canvas.clientHeight * dpr);
    g.imageSmoothingEnabled = false;
    g.setTransform(dpr,0,0,dpr,0,0);
    g.drawImage(off, dx, dy, dw, dh);
    g.restore();
  }

  function update(dt){
    let ax=0, ay=0;
    if(keys.has('a')||keys.has('arrowleft')) ax-=1; if(keys.has('d')||keys.has('arrowright')) ax+=1;
    if(keys.has('w')||keys.has('arrowup')) ay-=1; if(keys.has('s')||keys.has('arrowdown')) ay+=1;
    ax+=dpadState.ax; ay+=dpadState.ay; const m=Math.hypot(ax,ay)||1; ax/=m; ay/=m;

    const moving=Math.hypot(ax,ay)>0.1 && !inConvo;
    if(!inConvo) moveEntity(player,ax,ay);
    player.anim+=dt;
    if(moving){ player.stepTimer+=dt*1000; if(player.stepTimer>=180){ player.stepTimer=0; } } else player.stepTimer=0;

    seekerObj.step();

    // 하단 출구로 방 전환
    if((player.y|0)===MAP_H-1 && (player.x|0)>=6 && (player.x|0)<=9){
      room = room===0 ? 1 : 0;
      player.x=8.5; player.y=14.2; inConvo=false; dlg.style.display='none'; dgChoices.innerHTML='';
    }

    // 상호작용(E): 로봇/비석/전화
    let action=null;
    if(room===0){
      if(!inConvo && Math.hypot(player.x-seeker.x, player.y-seeker.y)<0.85){ action=()=> openRobotConvo(); }
      else{ const ng=nearestGrave(player.x,player.y);
        if(ng.grave && ng.dist<1.1){ action=()=>{ dgTitle.textContent='비석의 기록'; dgBody.textContent=graveText(ng.grave.x,ng.grave.y); dgChoices.innerHTML=''; dlg.style.display='flex'; }; } }
    }else{
      const np=nearestPhone(player.x,player.y);
      if(np.phone && np.dist<1.1){ action=()=>{ dgTitle.textContent='전화기의 방'; dgBody.textContent='...여보세요? (침묵 속의 목소리가 미세하게 울린다)'; dgChoices.innerHTML=''; dlg.style.display='flex'; }; }
    }
    pendingAction = action;
  }

  // 전역 E키로 상호작용
  let pendingAction=null, inConvo=false;
  addEventListener('keydown', e=>{ if(e.key==='e'||e.key==='E'){ if(pendingAction){ e.preventDefault(); pendingAction(); }}}, {passive:false});

  // 메인 루프
  let last=0;
  function loop(t){ requestAnimationFrame(loop); const dt=Math.min(32,(t-last)||16); last=t; update(dt/16); render(); }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
