<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Camera (B/W + Trails) + Cloudflare Stream Overlay</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
    /* 흑백은 CSS 필터로 확실히 적용 */
    #camCanvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      /* 흑백 + 약간 대비 */
      filter: grayscale(100%) contrast(110%);
    }
    /* 스트림은 오파시티/블렌드 제거 (Resolume에서 조절) */
    #cfStream {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      pointer-events: none;
    }
    @supports (height: 100svh) {
      #camCanvas, #cfStream { height: 100svh; }
    }
  </style>
</head>
<body>
  <!-- 카메라 처리용 캔버스 (흑백+잔상) -->
  <canvas id="camCanvas"></canvas>

  <!-- Cloudflare Stream (HLS/LL-HLS) 오버레이 -->
  <video id="cfStream" autoplay playsinline muted></video>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
  // ====== 설정 ======
  const HLS_URL = "https://customer-e1rhmg8edq32stcl.cloudflarestream.com/0561f69cdb850354620ce2f93cbb05ce/manifest/video.m3u8?protocol=llhlsbeta";
  const CAM_CONSTRAINTS = { video: { facingMode: { ideal: "environment" } }, audio: false };

  // 잔상 파라미터: 알파만 서서히 지우기(화면 전체 어두워지지 않음)
  // eraseAlpha: 한 프레임마다 지우는 알파 강도 (0.03~0.15 추천)
  // drawAlpha : 새 프레임을 덧그릴 알파 (0.2~0.5)
  const TRAIL = { eraseAlpha: 0.07, drawAlpha: 0.30 };

  const canvas = document.getElementById('camCanvas');
  const ctx = canvas.getContext('2d', { alpha: true }); // 알파 켬(잔상용)
  const camVideo = document.createElement('video');
  camVideo.playsInline = true;
  camVideo.muted = true;
  camVideo.autoplay = true;

  function fitCanvas() {
    const w = window.innerWidth || document.documentElement.clientWidth;
    const h = window.innerHeight || document.documentElement.clientHeight;
    canvas.width = w;
    canvas.height = h;
  }
  window.addEventListener('resize', fitCanvas, { passive: true });
  fitCanvas();

  function drawLoop() {
    const W = canvas.width, H = canvas.height;

    // 1) 이전 프레임을 "알파로 조금씩 지우는" 방식 → 실제 밝기는 유지, 잔상만 사라짐
    ctx.globalCompositeOperation = "destination-out";
    ctx.globalAlpha = TRAIL.eraseAlpha;
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0, 0, W, H);

    // 2) 현재 카메라 프레임 그리기 (알파로 덧그림)
    if (camVideo.readyState >= 2) {
      ctx.globalCompositeOperation = "source-over";
      ctx.globalAlpha = TRAIL.drawAlpha;

      const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
      if (vw && vh) {
        const canvasRatio = W / H;
        const videoRatio = vw / vh;
        let dw = W, dh = H, dx = 0, dy = 0;
        if (videoRatio > canvasRatio) {
          dh = H; dw = H * videoRatio; dx = (W - dw) / 2;
        } else {
          dw = W; dh = W / videoRatio; dy = (H - dh) / 2;
        }
        ctx.drawImage(camVideo, dx, dy, dw, dh);
      }
    }

    requestAnimationFrame(drawLoop);
  }

  // 카메라 시작
  navigator.mediaDevices.getUserMedia(CAM_CONSTRAINTS)
    .then(stream => {
      camVideo.srcObject = stream;
      camVideo.onloadedmetadata = () => {
        camVideo.play().catch(()=>{});
        drawLoop(); // 메타데이터 로드 후 시작
      };
    })
    .catch(err => {
      console.error("카메라 실패:", err);
      // 실패해도 루프는 돌려 캔버스가 투명 검정 상태로 유지
      drawLoop();
    });

  // Cloudflare HLS 붙이기 (블렌드/오파시티 없음)
  const streamEl = document.getElementById('cfStream');
  if (streamEl.canPlayType('application/vnd.apple.mpegURL')) {
    streamEl.src = HLS_URL; // iOS 사파리
  } else if (window.Hls && window.Hls.isSupported()) {
    const hls = new Hls({ lowLatencyMode: true });
    hls.loadSource(HLS_URL);
    hls.attachMedia(streamEl);
  } else {
    streamEl.src = HLS_URL; // 일부 브라우저 폴백
  }
  </script>
</body>
</html>
