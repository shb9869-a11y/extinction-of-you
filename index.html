<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>SLEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEP</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEEEEP">
<meta name="theme-color" content="#000000">

<style>
:root{
  --appH: 100svh;
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;

  --fs-body: clamp(14px, 2.6vmin, 18px);      /* ⬅ 인트로 본문 살짝 키움 */
  --fs-strong: clamp(18px, 3.2vmin, 24px);    /* ⬅ 강조 더 큼 */
  --fs-small: clamp(11px, 1.8vmin, 14px);
  --fs-name: clamp(18px,3.4vmin,24px);

  --fs-intro-big: clamp(32px, 14vmin, 140px); /* ⬅ 인트로 대제목 더 큼 */
  --fs-intro-live: clamp(16px, 2.8vmin, 20px);/* 흐르는 라이브 라인도 살짝 키움 */

  --pad-btn-y: clamp(6px, 1.1vmin, 10px);
  --pad-btn-x: clamp(10px, 1.8vmin, 20px);

  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);
}

html,body{margin:0;height:var(--appH);background:#000;overflow:hidden;touch-action:manipulation}
body{font-family:Impact,"Anton","Arial Black",system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans KR",sans-serif;}
.fade{opacity:0; transition:opacity 1800ms ease}
.fade.show{opacity:1}

#view{position:fixed;left:0;top:0;width:100%;height:var(--appH);display:block;z-index:0}

/* freezeLayer: 캡처 픽셀화용 캔버스 올리는 레이어 */
#freezeLayer{position:fixed;inset:0;z-index:500;display:none;background:transparent;pointer-events:none}

.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:2px solid rgba(255,255,255,.22); pointer-events:none; z-index:50;
}

/* 투명 버튼 (검정 박스 제거) */
.uiBtn{background:transparent;color:#fff;border:none;font-size:var(--fs-strong);
  padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",ui-monospace,monospace;white-space:nowrap;cursor:pointer;user-select:none}
.uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
.uiBtn.flat{border:none;background:transparent;text-decoration:none}
.uiBtn[disabled]{opacity:.35;pointer-events:none;filter:grayscale(1)}
.hide{display:none !important;}

.controls{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:400;display:flex;gap:6px;align-items:center; opacity:0; transition:opacity 400ms ease; /* ⬅ 렉 줄이려고 짧게 */
}
.controls.show{opacity:1}
.readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",ui-monospace,monospace;font-size:var(--fs-small);color:#ddd}

.btn-capture{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:450; opacity:0; transition:opacity 400ms ease; /* ⬅ 렉 줄임 */
}
.btn-capture.show{opacity:1}

#mapLauncher, #docLauncher, #audioToggle { display:none; }

#runTimer{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:460;
  font-family:"Courier New",ui-monospace,monospace;
  font-size:var(--fs-strong);
  color:#fff; opacity:.95;
  pointer-events:none; user-select:none;
  display:none;
}

.credits{ font-family:"Courier New",ui-monospace,monospace; letter-spacing:.08em; }

#rotateOverlay{
  position:fixed; inset:0; z-index:1000; display:none;
  align-items:center; justify-content:center; text-align:center;
  background:#000; color:#fff; padding:40px; font-family:"Courier New",ui-monospace,monospace;
}

/* Gate */
#overlay{position:fixed;inset:0;z-index:300;display:flex;align-items:center;justify-content:center;padding:calc(20px + var(--safe-t)) calc(20px + var(--safe-r)) calc(20px + var(--safe-b)) calc(20px + var(--safe-l));color:#fff;background:rgba(0,0,0,.85)}
#overlayContent{max-width:min(92vw, 72ch);font-family:"Courier New",ui-monospace,monospace;line-height:1.7;text-align:center}
.gateLine{display:inline-block;font-family:"Courier New",ui-monospace,monospace;font-size:var(--fs-strong);border:none;background:transparent;color:#fff;cursor:pointer;padding:6px 10px}
.gateHint{opacity:.7;margin-top:6px}

/* Name */
#nameOverlay{position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.85); color:#fff;}
#nameCard{ width:min(92vw,600px); text-align:center; font-family:"Courier New",ui-monospace,monospace; }
#nameCard h2{ margin:0 0 12px 0; letter-spacing:.08em; font-size:var(--fs-name); font-weight:400; }
#nick{ width:100%; padding:12px 14px; background:#000; border:1px solid #555; color:#fff; font-size:var(--fs-name); outline:none; }
#nameRow{ display:flex; gap:10px; margin-top:12px; justify-content:center; }
#nameRow .uiBtn{ padding:10px 14px; }
#nameRow .uiBtn.flat{ font-family:"Courier New",ui-monospace,monospace; font-size:var(--fs-name); font-weight:400; }

/* Preset */
#preset{position:fixed;inset:0;z-index:250;background:#000;display:none;cursor:pointer}
#presetCanvas{position:absolute;left:0;top:0;width:100%;height:100%}

/* Welcome */
#overlayWelcome{position:fixed;inset:0;z-index:220;display:none;align-items:center;justify-content:center;color:#fff;background:rgba(0,0,0,.55);padding:calc(20px + var(--safe-t)) 20px calc(20px + var(--safe-b)) 20px;}
#welcomeCard{ text-align:center; max-width:min(92vw, 900px); }
#welcomeCard .title{ font-size:clamp(32px, 12vmin, 120px); font-weight:900; letter-spacing:.04em; line-height:1.02; margin-bottom:8px; text-transform:uppercase; }
#welcomeCard .title + .title{ margin-top:0; }

/* Intro big title */
#introBig{ position:fixed; inset:0; z-index:231; display:none; align-items:center; justify-content:center; pointer-events:none; }
#introBigText{ color:#fff; font-weight:900; letter-spacing:.06em; font-size:var(--fs-intro-big); text-transform:uppercase; text-align:center; }

/* Intro body (두 줄 구조) */
#introOverlay{position:fixed; inset:0; z-index:230; display:none; align-items:center; justify-content:center; color:#fff; background:rgba(0,0,0,.35); padding:calc(24px + var(--safe-t)) calc(16px + var(--safe-r)) calc(20px + var(--safe-b)) calc(16px + var(--safe-l)); font-family:"Courier New",ui-monospace,monospace; overflow:hidden;}
#introBox{ width:min(92vw, 860px); margin:0 auto; visibility:hidden; height:0; overflow:hidden; }
#introBox p{font-size:var(--fs-body);}

#introPrev{
  position:absolute; left:calc(var(--frame) + var(--safe-l) + 6px);
  top:calc(var(--frame) + var(--safe-t) + 4px);
  max-width:min(92vw, 860px);
  font-size:var(--fs-intro-live); line-height:1.9; text-align:left;
  opacity:0; transition:opacity 400ms ease; /* ⬅ 가볍게 */
  text-shadow:0 1px 2px rgba(0,0,0,.6);
  white-space:nowrap;
}
#introPrev.show{ opacity:1; }

#introLive{
  display:inline-block;
  max-width:min(92vw, 900px);
  font-size:var(--fs-intro-live); line-height:1.9; text-align:center;
  text-shadow:0 1px 2px rgba(0,0,0,.6);
  white-space:nowrap;
}

/* First sleep 뒤 UI 깔끔히 등장시키기 위해 간단 페이드 */
.fadeFast{opacity:0;transition:opacity 240ms ease;}
.fadeFast.show{opacity:1;}
</style>
</head>
<body>
<canvas id="view"></canvas>
<canvas id="freezeLayer"></canvas>

<div class="frameBox"></div>

<!-- 간단한 컨트롤 (예: + - ) -->
<div id="controls" class="controls">
  <button id="btnMinus" class="uiBtn small">-</button>
  <span class="readout" id="readout">0</span>
  <button id="btnPlus" class="uiBtn small">+</button>
</div>
<button id="btnCapture" class="uiBtn btn-capture">CAPTURE</button>
<div id="runTimer"></div>

<!-- GATE -->
<div id="overlay" class="fade show" role="dialog" aria-modal="true">
  <div id="overlayContent">
    <button id="gateBtn" class="gateLine">안녕하세요?</button>
    <div class="gateHint">작게 대답해주세요.</div>
  </div>
</div>

<!-- NAME -->
<div id="nameOverlay">
  <div id="nameCard">
    <h2>TELL ME YOUR NAME</h2>
    <input id="nick" type="text" autocomplete="off" placeholder="____" />
    <div id="nameRow">
      <button id="nameGo" class="uiBtn flat">GO</button>
    </div>
  </div>
</div>

<!-- PRESET (탭) -->
<div id="preset"><canvas id="presetCanvas"></canvas></div>

<!-- WELCOME -->
<div id="overlayWelcome">
  <div id="welcomeCard">
    <div class="title">WELCOME</div>
    <div class="title">SLEEEEEP</div>
    <div style="margin-top:12px">
      <button id="goIntro" class="uiBtn">START INTRO</button>
    </div>
  </div>
</div>

<!-- INTRO -->
<div id="introBig"><div id="introBigText">THE FIRST SLEEP</div></div>
<div id="introOverlay">
  <div id="introBox">
    <div id="introPrev"></div>
    <div id="introLive"></div>
    <div id="introCount" style="text-align:center;margin-top:16px"></div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const overlay = $('#overlay');
  const nameOverlay = $('#nameOverlay');
  const overlayWelcome = $('#overlayWelcome');
  const introBig = $('#introBig');
  const introOverlay = $('#introOverlay');
  const introPrev = $('#introPrev');
  const introLive = $('#introLive');
  const introBox = $('#introBox');
  const introCount = $('#introCount');
  const controls = $('#controls');
  const btnCapture = $('#btnCapture');
  const readout = $('#readout');
  const view = $('#view');
  const freezeLayer = $('#freezeLayer');
  const gateBtn = $('#gateBtn');
  const nameGo = $('#nameGo');
  const nickInput = $('#nick');

  let displayName = '____';

  /* ========= 오디오 클릭 사운드 (간단 목업) ========= */
  const clickCtx = new (window.AudioContext||window.webkitAudioContext)();
  function ensureResumed(){ if (clickCtx.state !== 'running') return clickCtx.resume(); return Promise.resolve(); }
  function playWoongClick() {
    const o = clickCtx.createOscillator();
    const g = clickCtx.createGain();
    o.type='sine';
    o.frequency.value=440;
    g.gain.value=0.12;
    o.connect(g).connect(clickCtx.destination);
    o.start();
    setTimeout(()=>{o.stop()},80);
  }

  /* ========= 캔버스 초기 ========= */
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function fitCanvas(c){
    const w = c.width = Math.floor(innerWidth * dpr);
    const h = c.height = Math.floor((window.visualViewport?.height || innerHeight) * dpr);
    c.style.width = '100%';
    c.style.height = '100%';
    return {w,h,ctx:c.getContext('2d')};
  }
  const viewCtxObj = fitCanvas(view);
  window.addEventListener('resize', ()=>fitCanvas(view), {passive:true});

  /* ========= GATE → NAME ========= */
  gateBtn.addEventListener('click', async ()=>{
    await ensureResumed(); playWoongClick();
    overlay.classList.remove('show'); // fade out
    overlay.style.transition='opacity 300ms ease';
    requestAnimationFrame(()=> overlay.style.opacity = '0');
    setTimeout(()=>{
      overlay.style.display='none';
      nameOverlay.style.display='flex';
    },300);
  }, {passive:true});

  /* ========= NAME → WELCOME ========= */
  nameGo.addEventListener('click', async ()=>{
    await ensureResumed(); playWoongClick();
    const v = (nickInput.value||'').trim();
    if(v) displayName = v;
    nameOverlay.style.display='none';
    overlayWelcome.style.display='flex';
  }, {passive:true});

  /* ========= WELCOME → INTRO ========= */
  $('#goIntro').addEventListener('click', async ()=>{
    await ensureResumed(); playWoongClick();
    overlayWelcome.style.display='none';
    showIntroFlow();
  }, {passive:true});

  /* ========= INTRO 문단 =========
     — 문단 단위로 표시. 각 문단 사이에 짧은 정지.
     — ____ 자리에 displayName 주입.
  */
  const INTRO_LINES = [
`안녕하세요?
작게 대답해주세요.
안녕하세요?
대답을 해주셔야 프로그램이 진행될 수 있습니다.
안녕하세요?
감사합니다.`,

`지금 이 화면을 보고 있는 당신은 ${'____'}의 내면 세계를 탐험하는 탐험가입니다.
지금부터 우리는 주변의 소리에 귀를 기울이며
30분 간의 짧은 낮잠에 빠져볼 것입니다.
자, 천천히 공간을 거닐어보세요.
무릎을 들고, 발을 앞으로 뻗어보세요.
참 잘했어요.
맞아요. 그래 맞아요. 우리는 늘 그랬어요.`,

`우리는 언제나 타자와 함께 존재해 왔습니다.
가족, 친구, 교수님, 지나가는 그들, 그리고 당신과 처음 만나는 저도 우리는 늘 함께 존재해왔습니다
그러나 어느 순간 ‘너’로 불리던 그들은 ‘그것’으로 전락했습니다
이유는 아무도 몰라요. 그저 우리가 ‘너’들을 ‘그것’들로 부르기 시작한 것이죠.`,

`김춘추의 <꽃>이 떠오르네요.
(진지한 톤으로) 내가 그의 이름을 불러주기 전에는 그는 다만 하나의 몸짓에 지나지 않았다.
크으으으으으으....
네. 각설하고.`,

`이제 우리는 어느 곳에서도 ‘너’를 찾아볼 수 없습니다.
우리는 이제 ‘너’가 사라진 세상에 살아가고 있으니까요.
그런 특정했던 ‘너’는 서서히 희미해지고 퇴색되고 잊혀지고 잃어지고 앓아가고 있습니다`,

`마치 꿈 속에서 만난 누군가가
...
그게 누구였지?
...
하고 떠오르지 않는 것처럼`,

`이곳은 바로 ‘너’가 사라진 공간
‘너’가 제거된, 제거해버린
${'____'}의 내면 세계입니다
그리고 당신은 지금 이 순간 ${'____'}의 내면 세계로 발을 디딥니다`,

`두 번의 심호흡을 하기도 하면서,
후 --
하,
후 ....
하 ~ 
이제 눈으로 감고,
천천히 수면 아래로 내려갑니다.
귀를 기울여 ‘보세요’
내면의 미로를 탐험하여 사라진 ‘너’의 소리에
말이 길었습니다. 잠시 후에 만나요.`
];

  function linesWithName(arr){
    return arr.map(p => p.replaceAll('____', displayName));
  }

  function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

  /* ========= INTRO 표시 흐름 (렉 줄임) ========= */
  async function showIntroFlow(){
    // 대제목 먼저 짧게
    introBig.style.display='flex';
    introBig.classList.add('fadeFast');
    requestAnimationFrame(()=> introBig.classList.add('show'));
    await sleep(1000);
    introBig.classList.remove('show');
    await sleep(260);
    introBig.style.display='none';

    // 본문 표시
    introOverlay.style.display='flex';
    introBox.style.visibility='visible';
    introBox.style.height='auto';
    introPrev.textContent = '';
    introLive.textContent = '';
    introCount.textContent = '';

    const paras = linesWithName(INTRO_LINES);

    for (let i=0;i<paras.length;i++){
      // 이전 문단을 위(좌측)에 남기고, 현재 문단은 중앙 스트림
      introPrev.textContent = i>0 ? paras[i-1] : '';
      introPrev.classList.add('show');

      // 타자 효과 없이 문단 단위로 등장 (렉 최소화)
      introLive.textContent = paras[i];
      await sleep(1600);  // 문단 간 템포
    }

    // 카운트다운 10초만 노출
    let left = 10;
    introCount.textContent = `HAVE A NICE SLEEP IN ${left}s`;
    const timerId = setInterval(()=>{
      left = Math.max(0, left-1);
      introCount.textContent = `HAVE A NICE SLEEP IN ${left}s`;
      if(left<=0){
        clearInterval(timerId);
        startTransition();
      }
    },1000);
  }

  /* ========= INTRO → FIRST SLEEP 전환 (UI 렉 방지) ========= */
  function startTransition(){
    // 인트로 요소 먼저 깔끔히 숨김
    introOverlay.style.display='none';
    introBig.style.display='none';

    // 다음 프레임에서 UI 등장 (레이아웃 스레싱 회피)
    requestAnimationFrame(()=>{
      controls.classList.add('show');
      btnCapture.classList.add('show');
      $('#runTimer').style.display='block';
    });
  }

  /* ========= + / - 데모 ========= */
  let val = 0;
  $('#btnPlus').addEventListener('click', ()=>{ val++; readout.textContent = String(val); playWoongClick(); }, {passive:true});
  $('#btnMinus').addEventListener('click', ()=>{ val--; readout.textContent = String(val); playWoongClick(); }, {passive:true});

  /* ========= CAPTURE: 픽셀화 → 사라짐 (원본 재등장 X) ========= */
  btnCapture.addEventListener('click', async ()=>{
    await ensureResumed(); playWoongClick();
    await pixelateAndVanish();
  }, {passive:true});

  async function pixelateAndVanish(){
    // freezeLayer에 현재 화면 렌더(여기선 view 캔버스를 그대로 복사)
    const {w,h,ctx} = fitCanvas(freezeLayer);
    freezeLayer.style.display='block';

    // view를 이미지로 가져오기 (여기서는 데모라 검정 배경에 글자 가정)
    ctx.drawImage(view,0,0,w,h);

    // 픽셀화 애니메이션: 다운스케일 → 업스케일 반복으로 블럭화
    const steps = 10;
    for(let i=0;i<steps;i++){
      const scale = Math.max(0.08, 1 - i*(0.085)); // 점점 작게
      const sw = Math.max(1, Math.floor(w*scale));
      const sh = Math.max(1, Math.floor(h*scale));

      // 임시 캔버스에 축소 후 다시 확대
      const tmp = document.createElement('canvas');
      tmp.width = sw; tmp.height = sh;
      const tctx = tmp.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      tctx.drawImage(freezeLayer, 0,0,w,h, 0,0,sw,sh);

      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(tmp, 0,0,sw,sh, 0,0,w,h);

      await sleep(28);
    }

    // 검정으로 페이드아웃
    await fadeToBlack(ctx, w, h);

    // 완전히 종료: freezeLayer 숨기고 내용 클리어 (원본 재등장 방지)
    freezeLayer.style.display='none';
    const fctx = freezeLayer.getContext('2d');
    fctx && fctx.clearRect(0,0,freezeLayer.width,freezeLayer.height);
  }

  async function fadeToBlack(ctx, w, h){
    ctx.save();
    for(let a=0; a<=1.0; a+=0.12){
      ctx.fillStyle = `rgba(0,0,0,${a.toFixed(2)})`;
      ctx.fillRect(0,0,w,h);
      await sleep(24);
    }
    ctx.restore();
  }

  // 초기 값 표시
  readout.textContent = '0';
})();
</script>
</body>
</html>
