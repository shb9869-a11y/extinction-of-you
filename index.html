<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>SLEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEP</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEEEEP">
<meta name="theme-color" content="#000000">

<style>
  :root{
    --appH: 100svh;
    --frame: clamp(16px, 4vmin, 40px);
    --ui-gap: 8px;

    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --fs-name: clamp(16px,3.2vmin,22px);

    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);

    --safe-t: env(safe-area-inset-top, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);
  }

  html,body{margin:0;height:var(--appH);background:#000;overflow:hidden;touch-action:manipulation}
  body{font-family:Impact,"Anton","Arial Black",system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans KR",sans-serif;}
  .fade{opacity:0; transition:opacity 2000ms ease}
  .fade.show{opacity:1}

  #view{position:fixed;left:0;top:0;width:100%;height:var(--appH);display:block;z-index:0}
  #freezeLayer{position:fixed;inset:0;z-index:500;display:none}

  .frameBox{
    position:fixed;
    left:calc(var(--frame) + var(--safe-l));
    top:calc(var(--frame) + var(--safe-t));
    right:calc(var(--frame) + var(--safe-r));
    bottom:calc(var(--frame) + var(--safe-b));
    border:2px solid rgba(255,255,255,.22); pointer-events:none; z-index:50;
  }

  .uiBtn{background:#000;color:#fff;border:1px solid #444;font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",ui-monospace,monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
  .uiBtn.flat{border:none;background:transparent;text-decoration:none}
  .uiBtn[disabled]{opacity:.35;pointer-events:none;filter:grayscale(1)}
  .hide{display:none !important;}

  .controls{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:100;display:flex;gap:6px;align-items:center; opacity:0; transition:opacity 2000ms ease;}
  .controls.show{opacity:1}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",ui-monospace,monospace;font-size:var(--fs-small);color:#ddd}
  .btn-capture{
    position:fixed;
    left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:150; opacity:0; transition:opacity 2000ms ease;}
  .btn-capture.show{opacity:1}

  #mapLauncher, #docLauncher, #audioToggle { display:none; }

  #runTimer{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
    z-index:181;
    font-family:"Courier New",ui-monospace,monospace;
    font-size:var(--fs-strong);
    color:#fff; opacity:.95;
    pointer-events:none; user-select:none;
    display:none;
  }

  .credits{ font-family:"Courier New",ui-monospace,monospace; letter-spacing:.08em; }

  /* 세로(가로 금지) 안내 — 포인터 이벤트로 하위 차단 */
  #rotateOverlay{
    position:fixed;inset:0;z-index:1000;display:none;align-items:center;justify-content:center;
    background:#000;color:#fff;font-family:"Courier New",ui-monospace,monospace;text-align:center;padding:40px;
  }
  #rotateOverlay.blocking{display:flex; pointer-events:all;}
  body.portrait-block #overlay,
  body.portrait-block #nameOverlay,
  body.portrait-block #preset,
  body.portrait-block #overlayWelcome { pointer-events:none; }

  /* Gate */
  #overlay{position:fixed;inset:0;z-index:300;display:flex;align-items:center;justify-content:center;padding:calc(20px + var(--safe-t)) calc(20px + var(--safe-r)) calc(20px + var(--safe-b)) calc(20px + var(--safe-l));color:#fff;background:rgba(0,0,0,.85)}
  #overlayContent{max-width:min(92vw, 72ch);font-family:"Courier New",ui-monospace,monospace;line-height:1.7;text-align:center}
  .gateLine{display:inline-block;font-family:"Courier New",ui-monospace,monospace;font-size:var(--fs-strong);border:none;background:transparent;color:#fff;cursor:pointer;padding:6px 10px}
  .gateHint{opacity:.7;margin-top:6px}

  /* Name */
  #nameOverlay{position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.85); color:#fff;}
  #nameCard{ width:min(92vw,600px); text-align:center; font-family:"Courier New",ui-monospace,monospace; }
  #nameCard h2{ margin:0 0 12px 0; letter-spacing:.08em; font-size:var(--fs-name); font-weight:400; }
  #nick{ width:100%; padding:12px 14px; background:#000; border:1px solid #555; color:#fff; font-size:var(--fs-name); outline:none; }
  #nameRow{ display:flex; gap:10px; margin-top:12px; justify-content:center; }
  #nameRow .uiBtn{ padding:10px 14px; }
  #nameRow .uiBtn.flat{ font-family:"Courier New",ui-monospace,monospace; font-size:var(--fs-name); font-weight:400; }

  /* Preset */
  #preset{position:fixed;inset:0;z-index:250;background:#000;display:none;cursor:pointer}
  #presetCanvas{position:absolute;left:0;top:0;width:100%;height:100%}

  /* Welcome */
  #overlayWelcome{position:fixed;inset:0;z-index:220;display:none;align-items:center;justify-content:center;color:#fff;background:rgba(0,0,0,.55);padding:calc(20px + var(--safe-t)) 20px calc(20px + var(--safe-b)) 20px;}
  #welcomeCard{ text-align:center; max-width:min(92vw, 900px); }
  #welcomeCard .title{ font-size:clamp(32px, 12vmin, 120px); font-weight:900; letter-spacing:.04em; line-height:1.02; margin-bottom:8px; text-transform:uppercase; }
  #welcomeCard .title + .title{ margin-top:0; }

  /* Intro big title */
  #introBig{ position:fixed; inset:0; z-index:231; display:none; align-items:center; justify-content:center; pointer-events:none; }
  #introBigText{ color:#fff; font-weight:900; letter-spacing:.06em; font-size:clamp(28px, 11vmin, 110px); text-transform:uppercase; text-align:center; }

  /* Intro body */
  #introOverlay{position:fixed; inset:0; z-index:230; display:none; align-items:flex-start; justify-content:center; color:#fff; background:rgba(0,0,0,.35); padding:calc(24px + var(--safe-t)) calc(16px + var(--safe-r)) calc(20px + var(--safe-b)) calc(16px + var(--safe-l)); font-family:"Courier New",ui-monospace,monospace; overflow-y:auto; -webkit-overflow-scrolling:touch;}
  #introBox{ width:min(92vw, 860px); margin:0 auto; }
  #introBox h2{ display:none; }
  #introBox p{font-size:var(--fs-body); line-height:1.85; text-align:center; text-shadow:0 1px 2px rgba(0,0,0,.6);}
  #introBox ol{padding-left:1.2em; margin:.4em 0 1.2em 0; text-align:left;}
  #introBox li{font-size:var(--fs-body); line-height:1.85; text-shadow:0 1px 2px rgba(0,0,0,.6);}
  #introCount{ text-align:center; font-size:var(--fs-strong); margin-top:12px; display:none; }

  #titleScreen{ position:fixed; inset:0; z-index:240; display:none; align-items:center; justify-content:center; background:#000; color:#fff; text-align:center; }
  #titleText{font-weight:900; letter-spacing:.06em; line-height:1.05; font-size:clamp(24px, 10vmin, 96px); text-transform:uppercase;}

  #firstSleep{ position:fixed; inset:0; z-index:235; display:none; align-items:center; justify-content:center; pointer-events:none; }
  #firstSleepText{ color:#fff; font-weight:900; letter-spacing:.06em; font-size:clamp(28px, 11vmin, 110px); text-transform:uppercase; }

  #docOverlay, #mapOverlay { display:none; }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <canvas id="freezeLayer"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <button id="docLauncher" class="uiBtn small">DOCUMENT</button>
  <button id="mapLauncher" class="uiBtn small">MAP</button>
  <button id="audioToggle" class="uiBtn small">AUDIO</button>
  <div id="runTimer" aria-live="polite">08:00</div>

  <!-- 세로(가로 금지) 안내 -->
  <div id="rotateOverlay"><div>This content supports landscape mode only.<br/>Please rotate your device.</div></div>

  <!-- Gate -->
  <div id="overlay" class="fade show">
    <div id="overlayContent">
      <div class="credits" style="margin-bottom:10px;">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <button id="permGateBtn" class="gateLine" type="button">
        Tap anywhere to allow Camera, Microphone & Motion sensors
      </button>
      <div class="gateHint">After allowing, you'll move to the name screen.</div>
    </div>
  </div>

  <!-- Name -->
  <div id="nameOverlay" class="fade">
    <div id="nameCard">
      <h2>TELL ME YOUR NAME</h2>
      <input id="nick" type="text" maxlength="24" placeholder="Type your nickname" autocomplete="off" />
      <div id="nameRow">
        <button id="nameSubmit" class="uiBtn flat" type="button">GO</button>
      </div>
    </div>
  </div>

  <!-- Preset -->
  <div id="preset" class="fade" title="Tap to continue">
    <canvas id="presetCanvas"></canvas>
  </div>

  <!-- Welcome -->
  <div id="overlayWelcome" class="fade">
    <div id="welcomeCard">
      <div class="credits" style="margin-bottom:12px;">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <div class="title">SLEEEEEEEEEEEEEEEEEEEEEEEEEP,</div>
      <div class="title">SLEEEEEEEEEEEEEEEEEEEEEEEEEP</div>
      <button id="goIntro" class="uiBtn flat" type="button" style="margin-top:6px">PRESS HERE TO SLEEP</button>
    </div>
  </div>

  <!-- Intro big title -->
  <div id="introBig" class="fade"><div id="introBigText"></div></div>

  <!-- Intro body -->
  <div id="introOverlay" class="fade"><div id="introBox">
    <p>지금 이 화면을 보고 있는 당신,</p>
    <p>주변의 소리에 천천히 귀를 기울이며 공간을 거닐기 시작합니다.</p>
    <p>지금부터 당신은 약 30분 간, 짧은 단잠에 들게 됩니다.</p>
    <ol>
      <li>당신이 거닐고 있는 이곳의 세계관 설명입니다.</li>
      <li>우리는 언제나 타자와 함께 존재해왔습니다. 친구, 엄마, 누나, 아버지, 지나가는 저 사람과 같이 말이죠.</li>
      <li>그러나 어느 순간, ‘너’로 존재했던 그들은 ‘너’가 아닌 ‘그것’으로 전락하기 시작했습니다.</li>
      <li>이제는 그 어느곳에서도 ‘너’를 찾아볼 수는 없습니다.</li>
      <li>‘그것’으로 전락한 ‘너’들은 서서히 우리의 내면 속에서 희미해져 가고 있기 때문이죠.</li>
      <li>마치 꿈 속에서 분명 누군가를 만난 것 같은데, 그게 누구인지 떠오르지 않는 것처럼.</li>
      <li>네, 그렇습니다. 이곳은 바로, 그 ‘너’가 사라져버린, ‘너’를 제거해버린, 누군가의 내면 세계입니다.</li>
    </ol>
    <p>당신의 의식이 서서히 희미해져가는 지금, 두 번의 심호흡을 크게 한 후,</p>
    <p>이 내면의 미로를 거닐며, 천천히 눈을 감고,</p>
    <p>이 세상에서 사라져버린 ‘너’의 이야기에 귀를 기울입니다.</p>
    <div id="introCount" aria-live="polite"></div>
    <div style="height:12vh"></div>
  </div></div>

  <!-- Title transition -->
  <div id="titleScreen"><div id="titleText"></div></div>
  <div id="firstSleep"><div id="firstSleepText">THE FIRST SLEEP</div></div>

<script>
(() => {
  /* Manifest */
  (function injectManifest(){
    const manifest = {"name":"SLEEEEEP","short_name":"SLEEEEEP","display":"standalone","start_url":"./","background_color":"#000","theme_color":"#000","icons":[]};
    const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:"application/manifest+json"}));
    const link = document.createElement('link'); link.rel='manifest'; link.href=url; document.head.appendChild(link);
  })();

  /* Utils */
  function fadeShow(el, dur=2000, display='flex'){ el.style.display=display; el.style.opacity='0'; el.style.transition=`opacity ${dur}ms ease`; requestAnimationFrame(()=>el.style.opacity='1'); }
  function fadeHide(el, dur=2000){ el.style.transition=`opacity ${dur}ms ease`; el.style.opacity='0'; setTimeout(()=>{ el.style.display='none'; }, dur); }
  // 오버랩 페이드(동시에 from-out / to-in)
  function overlapFade(fromEl, toEl, dur=1600, displayTo='flex'){
    if(toEl){ toEl.style.display=displayTo; toEl.style.opacity='0'; toEl.style.transition=`opacity ${dur}ms ease`; requestAnimationFrame(()=>toEl.style.opacity='1'); }
    if(fromEl){ fromEl.style.transition=`opacity ${dur}ms ease`; fromEl.style.opacity='0'; setTimeout(()=>{ fromEl.style.display='none'; }, dur); }
  }

  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const map=(v,inMin,inMax,outMin,outMax)=>outMin+(outMax-outMin)*((v-inMin)/(inMax-inMin));
  const qs = s => document.querySelector(s);

  function setAppH(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH(); addEventListener('resize', setAppH, {passive:true});
  if (window.visualViewport){ visualViewport.addEventListener('resize', ()=>setTimeout(setAppH,50)); }

  /* === 가로 전용 처리 (세로 금지) === */
  const rotateOverlay = document.getElementById('rotateOverlay');
  function isPortraitStrict(){
    try{
      const vv = window.visualViewport;
      const w = (vv ? vv.width : window.innerWidth);
      const h = (vv ? vv.height : window.innerHeight);
      const so = (screen.orientation && screen.orientation.type) || '';
      const ang = (screen.orientation && typeof screen.orientation.angle==='number') ? screen.orientation.angle
                : (typeof window.orientation==='number' ? Math.abs(window.orientation) : 0);
      const logicalPortrait = h > w;
      const oriPortrait = /portrait/i.test(so) || ang===0 || ang===180;
      return logicalPortrait || oriPortrait;
    }catch(e){ return window.innerHeight > window.innerWidth; }
  }
  function applyOrientationGate(){
    const portrait = isPortraitStrict();
    if(portrait){
      document.body.classList.add('portrait-block');
      rotateOverlay.classList.add('blocking');
    }else{
      document.body.classList.remove('portrait-block');
      rotateOverlay.classList.remove('blocking');
      rotateOverlay.style.display='none';
    }
  }
  ['load','pageshow','resize','orientationchange','visibilitychange'].forEach(ev=>{
    addEventListener(ev, ()=>{ 
      const wasPortrait = document.body.classList.contains('portrait-block');
      applyOrientationGate();
      if(isPortraitStrict()){
        rotateOverlay.style.display='flex';
      }else if(wasPortrait){
        rotateOverlay.style.display='none';
      }
    }, {passive:true});
  });
  applyOrientationGate();

  /* Refs */
  const overlayEl = qs('#overlay');
  const permBtn = qs('#permGateBtn');
  const nameOverlay = qs('#nameOverlay');
  const nickInput = qs('#nick');
  const nameSubmit = qs('#nameSubmit');
  const preset = qs('#preset');
  const presetCanvas = qs('#presetCanvas');
  const welcome = qs('#overlayWelcome');
  const goIntroBtn = qs('#goIntro');
  const intro = qs('#introOverlay');
  const introCount = qs('#introCount');
  const introBig = qs('#introBig');
  const introBigText = qs('#introBigText');
  const titleScreen = qs('#titleScreen');
  const titleText = qs('#titleText');
  const firstSleep = qs('#firstSleep');
  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');
  const view = qs('#view');
  const freezeLayer = qs('#freezeLayer');
  const runTimer = qs('#runTimer');

  /* State */
  let camPermGranted = false;
  let camStream = null, camVideo = null, vctx = null, proc = null, pctx = null, ZOOM = 1.0;
  let animStarted = false, capturing = false;

  /* ===== Audio ===== */
  let audioCtx = null;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  async function ensureResumed(){ try{ ensureAudio(); if(audioCtx.state==='suspended') await audioCtx.resume(); }catch{} }

  function playWoongClick(){
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const o1 = audioCtx.createOscillator(), g1 = audioCtx.createGain(), f1 = audioCtx.createBiquadFilter();
      o1.type='sine'; o1.frequency.setValueAtTime(120, now); o1.frequency.exponentialRampToValueAtTime(70, now+0.28);
      g1.gain.value=0.0001; g1.gain.exponentialRampToValueAtTime(1.80, now+0.02); g1.gain.exponentialRampToValueAtTime(0.0001, now+0.40);
      f1.type='lowpass'; f1.frequency.value=1000; f1.Q.value=0.8;
      o1.connect(f1).connect(g1).connect(audioCtx.destination); o1.start(); o1.stop(now+0.42);

      const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
      o2.type='sine'; o2.frequency.setValueAtTime(60, now);
      g2.gain.value=0.0001; g2.gain.exponentialRampToValueAtTime(1.20, now+0.03); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.38);
      o2.connect(g2).connect(audioCtx.destination); o2.start(); o2.stop(now+0.40);
    }catch(e){}
  }

  // ↓↓↓ 인트로 타자 입력 사운드 — 톤/볼륨 낮춤 (클릭과 비슷한 느낌)
  function typeTick(){
    try{
      ensureAudio();
      const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
      o.type='square'; o.frequency.value=420;
      f.type='lowpass'; f.frequency.value=900;
      g.gain.value=0.0001;
      g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.10);
      o.connect(f).connect(g).connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime+0.12);
    }catch(e){}
  }
  function countdownTick(left){
    try{
      ensureAudio();
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      const last5 = left<=5;
      o.type='square'; o.frequency.value= last5 ? 820 : 630;
      g.gain.value=0.0001;
      g.gain.exponentialRampToValueAtTime(last5?0.30:0.18, audioCtx.currentTime+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.12);
      o.connect(g).connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime+0.14);
    }catch(e){}
  }

  const Ambient = (() => {
    let ctx, master, delay, fb, hp, lp, mix, busGain, running=false, loops=[];
    function midi(n){ return 440 * Math.pow(2, (n-69)/12); }
    function makeBus(){
      ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value = 0.0001;
      delay = ctx.createDelay(2.5); delay.delayTime.value = 0.35;
      fb = ctx.createGain(); fb.gain.value = 0.35; delay.connect(fb).connect(delay);
      hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=150;
      lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=4500;
      mix = ctx.createGain(); mix.gain.value=0.6; mix.connect(hp).connect(lp).connect(master);
      busGain = ctx.createGain(); busGain.gain.value=0.9; busGain.connect(master);
      master.connect(ctx.destination);
    }
    function connectDryWet(node){ node.connect(busGain); node.connect(delay); delay.connect(mix); }
    function slowPad(root){
      const out = ctx.createGain(); out.gain.value=0.35;
      const filt = ctx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=600; filt.Q.value=0.6;
      const lfo = ctx.createOscillator(); const lfoG = ctx.createGain();
      lfo.type='sine'; lfo.frequency.value=0.05; lfoG.gain.value=220; lfo.connect(lfoG); lfoG.connect(filt.frequency); lfo.start();
      [0,7,12].forEach((i,k)=>{ const o=ctx.createOscillator(); o.type='sawtooth'; o.frequency.value=midi(root+i); o.detune.value=(k-1)*6;
        const g=ctx.createGain(); g.gain.value=0.08; o.connect(g).connect(filt); o.start(); loops.push(()=>g.disconnect()); });
      filt.connect(out); connectDryWet(out); loops.push(()=>{ try{ out.disconnect(); }catch{} });
    }
    function airyNoise(){
      const b=ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate), d=b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.15;
      const s=ctx.createBufferSource(); s.buffer=b; s.loop=true;
      const g=ctx.createGain(); g.gain.value=0.02; const f=ctx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=800; f.Q.value=0.7;
      s.connect(f).connect(g); connectDryWet(g); s.start(); loops.push(()=>{ try{s.stop();}catch{} });
    }
    async function start(fadeIn=0.8, target=1.0){
      await ensureResumed(); if(running) return; makeBus(); running=true; airyNoise();
      const seq=[57,52,48,43]; let i=0; (function tick(){ if(!running) return; slowPad(seq[i%seq.length]); i++; setTimeout(tick,8000); })();
      const t=(ctx||audioCtx).currentTime;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.exponentialRampToValueAtTime(target, t+fadeIn);
    }
    function stop(fade=2.0){
      if(!running||!master) return;
      const t=(ctx||audioCtx).currentTime;
      master.gain.linearRampToValueAtTime(0.0001, t+fade);
      setTimeout(()=>{ loops.forEach(fn=>{try{fn();}catch{}}); loops=[]; running=false; }, fade*1000+120);
    }
    return { start, stop, isRunning:()=>running };
  })();

  const LongDrone = (() => {
    let o, g, lfo, running=false;
    async function start(){
      await ensureResumed();
      if(running) return;
      o = audioCtx.createOscillator(); g = audioCtx.createGain(); lfo = audioCtx.createOscillator();
      o.type='sawtooth'; o.frequency.value=70;
      g.gain.value=0.0001;
      lfo.type='sine'; lfo.frequency.value=0.7;
      const lfoG = audioCtx.createGain(); lfoG.gain.value=0.10; lfo.connect(lfoG); lfoG.connect(g.gain);
      o.connect(g).connect(audioCtx.destination);
      o.start(); lfo.start();
      g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.8);
      running=true;
    }
    function stop(fade=4.0){
      if(!running) return;
      const t=audioCtx.currentTime;
      g.gain.linearRampToValueAtTime(0.0001, t+fade);
      setTimeout(()=>{ try{o.stop();lfo.stop();}catch{} running=false; }, fade*1000+120);
    }
    return { start, stop, isRunning:()=>running };
  })();

  async function lowWoongSequence(){
    await ensureResumed();
    const base = audioCtx.currentTime;
    const reps = 5, gap = 0.6, dur = 0.5, freq = 105, gainVal = 0.70;
    for(let i=0;i<reps;i++){
      const t = base + i*gap;
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='triangle'; o.frequency.value=freq;
      g.gain.value=0.0001;
      o.connect(g).connect(audioCtx.destination);
      o.start(t);
      g.gain.linearRampToValueAtTime(gainVal, t + 0.08);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.stop(t + dur + 0.06);
    }
  }

  /* Mic FX (패닝/톤 감도 ↑) */
  let micStream=null, micSrc=null, panNode=null, lpf=null, lowshelf=null, highshelf=null, revConvolver=null, dryGain=null, wetGain=null, comp=null, micBus=null;
  function makeImpulse(ctx, seconds=5.0, decay=7.0){
    const rate=ctx.sampleRate, len=rate*seconds, ir=ctx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const data=ir.getChannelData(ch);
      for(let i=0;i<len;i++){ const t=i/len; data[i]=(Math.random()*2-1) * Math.pow(1-t, decay); }
    }
    return ir;
  }
  async function startMicFXFadeIn(fadeSec=3.0){
    try{
      await ensureResumed();

      // Ambient는 마이크 들어올 때 교차 페이드로 사라짐
      try{ Ambient.stop(fadeSec); }catch{}

      if(!micStream) micStream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}, video:false});
      if(!micSrc) micSrc = audioCtx.createMediaStreamSource(micStream);

      comp = audioCtx.createDynamicsCompressor();
      comp.threshold.value = -28; comp.knee.value=20; comp.ratio.value=3.5; comp.attack.value=0.004; comp.release.value=0.22;

      lpf = audioCtx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=2200; lpf.Q.value=0.9;
      lowshelf = audioCtx.createBiquadFilter(); lowshelf.type='lowshelf'; lowshelf.frequency.value=200; lowshelf.gain.value=0;
      highshelf = audioCtx.createBiquadFilter(); highshelf.type='highshelf'; highshelf.frequency.value=3800; highshelf.gain.value=0;

      panNode = audioCtx.createStereoPanner(); panNode.pan.value = 0.0;

      revConvolver = audioCtx.createConvolver(); revConvolver.buffer = makeImpulse(audioCtx, 5.0, 7.0);

      dryGain = audioCtx.createGain(); dryGain.gain.value=0.0;
      wetGain = audioCtx.createGain(); wetGain.gain.value=0.0;

      micBus = audioCtx.createGain(); micBus.gain.value=0.0;

      micSrc.connect(comp).connect(lowshelf).connect(highshelf).connect(lpf).connect(panNode);
      panNode.connect(dryGain);
      panNode.connect(revConvolver);
      revConvolver.connect(wetGain);

      const out = audioCtx.createGain(); out.gain.value=0.98;
      dryGain.connect(out); wetGain.connect(out);
      out.connect(micBus).connect(audioCtx.destination);

      window.addEventListener('deviceorientation', onTiltAudio, {passive:true});

      const t=audioCtx.currentTime;
      dryGain.gain.linearRampToValueAtTime(0.85, t+fadeSec);
      wetGain.gain.linearRampToValueAtTime(0.85, t+fadeSec);
      micBus.gain.linearRampToValueAtTime(0.98, t+fadeSec);
    }catch(e){ console.warn('startMicFX error', e); }
  }
  function onTiltAudio(e){
    if(!audioCtx) return;
    const gamma = clamp(e.gamma ?? 0, -60, 60);
    const beta  = clamp(e.beta ?? 0, -60, 60);

    let panVal = 0;
    if(gamma > 2) panVal = +1;
    else if(gamma < -2) panVal = -1;
    if(panNode) panNode.pan.value = panVal;

    const bassBoost = (beta>=0) ? map(beta, 0, 60, 0, 16) : map(beta, -60, 0, -4, 0);
    const trebleBoost = (beta<0) ? map(beta, -60, 0, 16, 0) : 0;
    if(lowshelf) lowshelf.gain.value = clamp(bassBoost, -8, 16);
    if(highshelf) highshelf.gain.value = clamp(trebleBoost, 0, 16);

    const cutoff = (beta>=0) ? map(beta, 0, 60, 2200, 500) : map(beta, -60, 0, 8500, 2600);
    if(lpf) lpf.frequency.value = clamp(cutoff, 250, 9000);

    const wet = (beta>=0) ? map(beta, 0, 60, 0.85, 0.55) : map(beta, -60, 0, 1.0, 0.75);
    if(wetGain) wetGain.gain.value = clamp(wet, 0.4, 1.0);
    if(dryGain) dryGain.gain.value = clamp(1.0 - wetGain.gain.value*0.45, 0.2, 1.0);
  }

  function updateZoomLabel(){ zoomVal.textContent = ZOOM.toFixed(1)+'×'; }
  updateZoomLabel();
  zoomIn.addEventListener('click', ()=>{ ZOOM=Math.min(3.0, ZOOM+0.05); updateZoomLabel(); playWoongClick(); }, {passive:true});
  zoomOut.addEventListener('click', ()=>{ ZOOM=Math.max(0.35, ZOOM-0.05); updateZoomLabel(); playWoongClick(); }, {passive:true});

  /* ---------- 권한 게이트: 어디를 눌러도 반드시 작동 ---------- */
  let bootstrapped = false;
  async function immediateGestureStart(e){
    if(bootstrapped) return;
    bootstrapped = true;
    if(e && typeof e.preventDefault==='function') e.preventDefault();

    // 세로 상태면 안내만 띄우고 종료 (회전 후 다시 탭)
    if(isPortraitStrict()){
      rotateOverlay.style.display='flex';
      document.body.classList.add('portrait-block');
      bootstrapped = false; // 회전 후 다시 누를 수 있게
      return;
    }

    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        await DeviceOrientationEvent.requestPermission().catch(()=>{});
      }
    }catch(_) {}

    try{ ensureAudio(); audioCtx.resume && await audioCtx.resume(); }catch(_){}
    playWoongClick();

    // 권한 확인(첫 탭 제스처 안에서)
    try{
      const tmp = await navigator.mediaDevices.getUserMedia({
        video:{facingMode:'environment', width:{ideal:1280}, height:{ideal:720}, aspectRatio:{ideal:16/9}},
        audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}
      });
      tmp.getTracks().forEach(t=>t.stop());
      camPermGranted = true;
    }catch(err){ console.warn('permission error:', err); }

    fadeHide(overlayEl, 300);
    Ambient.start(0.8, 1.0);
    fadeShow(nameOverlay, 400);
    setTimeout(()=>nickInput && nickInput.focus && nickInput.focus(), 60);
  }

  // 버튼/오버레이 직접
  permBtn.addEventListener('click', immediateGestureStart, {passive:false});
  overlayEl.addEventListener('click', immediateGestureStart, {passive:false});

  // 문서 전체 백업 리스너(캡처 단계에서 1회)
  ['pointerdown','touchend','click'].forEach(type=>{
    document.addEventListener(type, (e)=>{
      if(overlayEl.style.display!== 'none') immediateGestureStart(e);
    }, {once:false, capture:true, passive:false});
  });

  // 회전 시 다시 금지 오버레이 반영
  addEventListener('orientationchange', ()=>{
    if(isPortraitStrict()){
      rotateOverlay.style.display='flex';
      document.body.classList.add('portrait-block');
    }else{
      rotateOverlay.style.display='none';
      document.body.classList.remove('portrait-block');
    }
  }, {passive:true});

  /* Name */
  let displayName = 'YOU';
  async function acceptName(){
    const v = (nickInput.value||'').trim();
    if(v.length>0){ displayName = v; }
    await ensureResumed();
    playWoongClick();
    fadeHide(nameOverlay, 300);
    showPreset();
  }
  nameSubmit.addEventListener('click', acceptName, {passive:true});
  nickInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ acceptName(); }});

  /* Preset */
  let saverObjs = []; let saverMode = 'scatter'; let saverT0 = 0;
  function showPreset(){
    preset.style.display='block'; preset.classList.add('show');
    fadeShow(preset, 250);
    initSaver();
    startCameraFresh(true);
  }
  function initSaver(){
    const w = preset.clientWidth, h = preset.clientHeight;
    saverObjs = [];
    const letters = ['S','L','E','E','P'];
    for(let i=0;i<20;i++){
      saverObjs.push({
        ch: letters[i%5],
        x: Math.random()*w, y: Math.random()*h,
        vx: (Math.random()*1.2+0.3) * (Math.random()<.5?-1:1),
        vy: (Math.random()*1.2+0.3) * (Math.random()<.5?-1:1),
        phase: Math.random()*Math.PI*2,
        size: Math.floor(Math.random()*60)+90
      });
    }
    saverT0 = performance.now();
    requestAnimationFrame(saverLoop);
  }
  function saverTargetsForWord(){
    const w = preset.clientWidth, h = preset.clientHeight;
    const base = Math.min(w,h)*0.55;
    const cx = w/2, cy = h/2;
    const spacing = base/5;
    const left = cx - (spacing*2);
    return [{x:left,y:cy},{x:left+spacing,y:cy},{x:left+spacing*2,y:cy},{x:left+spacing*3,y:cy},{x:left+spacing*4,y:cy}];
  }
  function saverLoop(){
    if(preset.style.display==='none') return;
    const now = performance.now();
    const w = preset.clientWidth, h = preset.clientHeight, dpr = devicePixelRatio||1;
    presetCanvas.width = w*dpr; presetCanvas.height = h*dpr;
    const ctx = presetCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h); ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
    ctx.textAlign='center'; ctx.textBaseline='middle';

    const dt = (now - saverT0)/1000;
    if(dt>Math.random()*2+6){
      saverMode = (saverMode==='scatter' ? 'assemble' : 'scatter');
      saverT0 = now;
    }

    const targets = saverMode==='assemble' ? saverTargetsForWord() : null;

    for(let i=0;i<saverObjs.length;i++){
      const o = saverObjs[i];
      if(saverMode==='assemble'){
        const idx = ['S','L','E','E','P'].indexOf(o.ch);
        const goal = targets[idx];
        o.vx += (goal.x - o.x)*0.0006;
        o.vy += (goal.y - o.y)*0.0006;
      }
      o.x += o.vx; o.y += o.vy;
      if(o.x<0||o.x>w) o.vx*=-1;
      if(o.y<0||o.y>h) o.vy*=-1;

      const wob = Math.sin(now/500 + o.phase)*0.12 + 1;
      ctx.save();
      ctx.translate(o.x, o.y); ctx.scale(wob, 1/wob);
      ctx.font = `900 ${o.size}px Impact, Anton, "Arial Black", system-ui, sans-serif`;
      ctx.fillStyle='#fff';
      ctx.fillText(o.ch, 0, 0);
      ctx.restore();
    }
    requestAnimationFrame(saverLoop);
  }

  // 프리셋 → 웰컴 : 1.6s 오버랩
  preset.addEventListener('click', async ()=>{
    playWoongClick();
    await startCameraFresh(false);
    overlapFade(preset, welcome, 1600, 'flex');
  }, {passive:true});

  /* Intro: big → body → 타이머(15s) */
  function captureIntroTexts(){
    const els = Array.from(document.querySelectorAll('#introBox p, #introBox li'));
    els.forEach(el=>{ el.dataset.text = (el.textContent||'').trim(); el.textContent=''; });
    return els;
  }
  async function typeSentence(el, sentence, speed=38){
    for(let i=0;i<sentence.length;i++){
      el.textContent += sentence[i];
      if(/\S/.test(sentence[i])) typeTick();
      intro.scrollTop = intro.scrollHeight;
      await sleep(speed);
    }
    await sleep(1000);
  }
  function splitSentences(str){
    const re = /(.*?[\.\?\!…]|.*?다\.)\s*/g;
    const out=[]; let m; let last=0;
    while((m=re.exec(str))){ out.push(m[0].trim()); last=re.lastIndex; }
    if(last<str.length) out.push(str.slice(last).trim());
    return out.filter(Boolean);
  }
  async function typeElementBySentence(el, text){
    const sentences = splitSentences(text);
    for(const s of sentences){ await typeSentence(el, s); }
  }

  async function showIntroFlow(){
    introBigText.textContent='';
    // 웰컴 → 인트로 빅타이틀 오버랩
    overlapFade(welcome, introBig, 1600, 'flex');
    await sleep(200); // 약간의 지연으로 부드럽게
    await typeSentence(introBigText, 'INTRODUCTION', 45);
    await sleep(800);
    // 빅타이틀 → 인트로 본문 오버랩
    overlapFade(introBig, intro, 1600, 'flex');

    const els = captureIntroTexts();
    for(const el of els){
      await typeElementBySentence(el, el.dataset.text||'');
      await sleep(120);
    }

    // 인트로 타이머: 마지막 입력 후 15초만 표시
    let left = 15;
    introCount.style.display = 'block';
    introCount.textContent = `HAVE A NICE SLEEP IN ${left}s`;
    const iv = setInterval(()=>{
      left = Math.max(0, left-1);
      introCount.textContent = `HAVE A NICE SLEEP IN ${left}s`;
      countdownTick(left);
      if(left<=0){ clearInterval(iv); startTransition(); }
    },1000);
  }
  goIntroBtn.addEventListener('click', ()=>{ ensureResumed().then(()=>{ playWoongClick(); showIntroFlow(); }); }, {passive:true});

  /* 8-minute timer */
  let eightTimer = null, eightLeft = 8*60;
  function formatMMSS(s){ const m=Math.floor(s/60), ss=(s%60).toString().padStart(2,'0'); return `${m.toString().padStart(2,'0')}:${ss}`; }
  function startEightTimer(){
    eightLeft = 8*60;
    runTimer.textContent = formatMMSS(eightLeft);
    runTimer.style.display='block';
    if(eightTimer) clearInterval(eightTimer);
    eightTimer = setInterval(()=>{
      eightLeft = Math.max(0, eightLeft-1);
      runTimer.textContent = formatMMSS(eightLeft);
      if(eightLeft<=0){ clearInterval(eightTimer); }
    },1000);
  }

  /* Transition */
  async function startTransition(){
    // 인트로 본문 페이드아웃은 타이머 0에서 자연 소멸되도록
    fadeHide(intro, 320);

    titleText.textContent='GOOD NIGHT';
    titleScreen.style.display='flex';
    titleScreen.style.background='#000'; titleText.style.color='#fff';

    await lowWoongSequence();

    const until = performance.now()+3700;
    let flag=false;
    while(performance.now()<until){
      flag=!flag;
      titleText.textContent = flag ? 'GOOD NIGHT' : 'THE FIRST SLEEP';
      titleScreen.style.background='rgba(255,255,255,0.96)'; titleText.style.color='#000';
      await sleep(100);
      titleScreen.style.background='#000'; titleText.style.color='#fff';
      await sleep(140);
    }
    titleScreen.style.display='none';

    firstSleep.style.display='flex';
    firstSleep.style.opacity='1';
    await LongDrone.start(); // 부웅부웅

    startEightTimer();

    await sleep(1100);
    firstSleep.style.transition='opacity 8000ms ease';
    firstSleep.style.opacity='0';

    // 드론 먼저 사라짐
    LongDrone.stop(4.5);

    await sleep(8200);
    firstSleep.style.display='none';
    firstSleep.style.transition='';

    await sleep(400);

    // 여기서 마이크가 들어오면서 Ambient가 함께 페이드아웃
    await startMicFXFadeIn(2.8);

    controls.classList.add('show');
    captureBtn.classList.add('show');
    beginCharacter();
  }

  /* Camera — 자동 회전/커버 */
  let metaReady = false, warmupFrames=0;
  async function startCameraFresh(warmupOnly=false){
    try{
      if(!camPermGranted){
        await navigator.mediaDevices.getUserMedia({video:true, audio:true}).then(s=>{ s.getTracks().forEach(t=>t.stop()); camPermGranted=true; });
      }
      if(!camVideo){
        camVideo = document.createElement('video');
        camVideo.setAttribute('playsinline',''); camVideo.autoplay = true; camVideo.playsInline = true; camVideo.muted = true;
      }
      if(!camStream){
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{ facingMode:'environment', width:{ideal:1920}, height:{ideal:1080}, aspectRatio:{ideal:16/9} },
          audio:false
        });
        camVideo.srcObject = camStream;
      }

      await camVideo.play().catch(()=>{});
      if (camVideo.readyState < 1) await new Promise(res => camVideo.addEventListener('loadedmetadata', res, {once:true}));
      metaReady = true;
      resizeCam();
      warmupFrames = 30;

      if(!vctx){
        vctx = view.getContext('2d',{alpha:false});
        proc = document.createElement('canvas');
        pctx = proc.getContext('2d',{willReadFrequently:true});
        resizeCam();
      }
      if(!animStarted && !warmupOnly){ animStarted = true; loopCam(); }
      document.querySelectorAll('.uiBtn').forEach(b=>b.addEventListener('click', playWoongClick, {passive:true}));
    }catch(e){ console.warn('startCameraFresh error:', e); }
  }
  function resizeCam(){
    const dpr = window.devicePixelRatio||1;
    const w = window.innerWidth, h = window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; if(vctx) vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale = matchMedia('(orientation: landscape)').matches? 0.86 : 0.9;
    if(proc){ proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale); }
  }
  addEventListener('resize', ()=>{ setTimeout(resizeCam,30); warmupFrames=30; }, {passive:true});
  document.addEventListener('visibilitychange', async ()=>{
    if(document.visibilityState==='visible' && camVideo){
      try{
        if(camVideo.paused){ await camVideo.play(); }
        if(!camStream || camStream.getVideoTracks().every(t=>t.readyState!=='live')){
          await startCameraFresh();
        }
        warmupFrames=30;
      }catch{}
    }
  });

  function drawBestCover(ctx, video, W, H, PW, PH){
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(!vw||!vh) return;
    function coverScore(rot){
      let rw = rot? vh: vw, rh = rot? vw: vh;
      const s = Math.max(PW/rw, PH/rh)*ZOOM;
      const dw=rw*s, dh=rh*s;
      const letter = Math.max(0, (PW - dw)) + Math.max(0, (PH - dh));
      return {rot, s, dw, dh, letter};
    }
    const a = coverScore(false); const b = coverScore(true);
    const best = (b.letter < a.letter) ? b : a;

    ctx.save();
    if(best.rot){
      ctx.translate(PW/2, PH/2);
      ctx.rotate(Math.PI/2);
      ctx.globalAlpha = .7;
      ctx.drawImage(video, -best.dh/2, -best.dw/2, best.dh, best.dw);
    }else{
      const dx=(PW-best.dw)/2, dy=(PH-best.dh)/2;
      ctx.globalAlpha=.7;
      ctx.drawImage(video, dx, dy, best.dw, best.dh);
    }
    ctx.restore();
    ctx.globalAlpha=1;
  }

  /* Character path 'ㄹ' */
  let charActive = false;
  let charStartTime = 0;
  const CHAR_DURATION = 480000;
  const PATH_POINTS = [];
  const PIXEL_SPRITE = [
    "..XXXXXX....",".XXXXXXXX...",".XX.XX.XX...",".XXXXXXXX...",
    "..XXXXXX....",".XXXXXXXX...",".XXXXXXXX...",".XX.XX.XX...",
    ".XXXXXXXX...", "..XXXXXX....",".XX....XX...",".XX....XX...",
    ".XX....XX...", ".XX....XX...", "..XX..XX....","..XX..XX...."
  ];
  const COLOR_FILL = '#ff8a3c'; const COLOR_STROKE = '#000';

  function drawPixelHuman(ctx, cx, baselineY, name, W, hop=0){
    const cell = Math.max(2, Math.min(4, Math.floor(W * 0.0018)));
    const cols = PIXEL_SPRITE[0].length, rows = PIXEL_SPRITE.length;
    const width = cols * cell, height = rows * cell;
    const x0 = Math.round(cx - width/2), y0 = Math.round(baselineY - height - hop);

    ctx.fillStyle = COLOR_STROKE;
    for(let y=0; y<rows; y++){
      const row = PIXEL_SPRITE[y];
      for(let x=0; x<cols; x++){
        if(row[x]==='X'){
          ctx.fillRect(x0 + x*cell - 1, y0 + y*cell, cell, cell);
          ctx.fillRect(x0 + x*cell + 1, y0 + y*cell, cell, cell);
          ctx.fillRect(x0 + x*cell, y0 + y*cell - 1, cell, cell);
          ctx.fillRect(x0 + x*cell, y0 + y*cell + 1, cell, cell);
        }
      }
    }
    ctx.fillStyle = COLOR_FILL;
    for(let y=0; y<rows; y++){
      const row = PIXEL_SPRITE[y];
      for(let x=0; x<cols; x++){
        if(row[x]==='X'){ ctx.fillRect(x0 + x*cell, y0 + y*cell, cell, cell); }
      }
    }
    ctx.font = `700 ${Math.max(10, Math.min(18, Math.floor(W*0.014)))}px "Courier New", ui-monospace, monospace`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    const ny = Math.round(baselineY + Math.max(2, cell));
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillText(name, cx, ny-1); ctx.fillText(name, cx, ny+1);
    ctx.fillText(name, cx-1, ny); ctx.fillText(name, cx+1, ny);
    ctx.fillStyle = '#fff'; ctx.fillText(name, cx, ny);
  }

  function makeRElsePath(){
    const fr = document.querySelector('.frameBox').getBoundingClientRect();
    const L = fr.left + fr.width*0.08;
    const R = fr.right - fr.width*0.08;
    const T = fr.top + fr.height*0.10;
    const M = fr.top + fr.height*0.52;
    const B = fr.bottom - fr.height*0.10;
    return [
      {x:L, y:T}, {x:R, y:T},
      {x:R, y:M}, {x:L*0.65 + R*0.35, y:M},
      {x:L*0.75 + R*0.25, y:B}, {x:R, y:B}
    ];
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOut(t){ return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
  function posOnRElse(t01){
    const pts = makeRElsePath();
    const segs = pts.length - 1;
    const segT = 1 / segs;
    let idx = Math.min(segs-1, Math.floor(t01 / segT));
    const localT = (t01 - idx*segT) / segT;
    const t = easeInOut(localT);
    const wob = Math.sin(t01 * Math.PI * 6) * 6;
    const a = pts[idx], b = pts[idx+1];
    return { x: lerp(a.x, b.x, t) + wob, y: lerp(a.y, b.y, t) };
  }

  function beginCharacter(){
    PATH_POINTS.length = 0;
    charActive = true;
    charStartTime = performance.now();
    if(!animStarted){ animStarted = true; loopCam(); }
  }

  function drawPathSolid(ctx){
    if(PATH_POINTS.length<2) return;
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath();
    ctx.moveTo(PATH_POINTS[0].x, PATH_POINTS[0].y);
    for(let i=1;i<PATH_POINTS.length;i++){ ctx.lineTo(PATH_POINTS[i].x, PATH_POINTS[i].y); }
    ctx.stroke();
    ctx.restore();
  }

  function drawCharacter(W,H){
    const now = performance.now();
    const t01 = Math.min(1, (now - charStartTime)/CHAR_DURATION);
    const pos = posOnRElse(t01);
    const hop = Math.max(0, 10*Math.sin(t01* Math.PI*20));
    PATH_POINTS.push({x:pos.x, y:pos.y});
    drawPathSolid(vctx);
    drawPixelHuman(vctx, Math.round(pos.x), Math.round(pos.y), displayName, W, hop);
    if(t01>=1){ charActive=false; }
  }

  /* Main render loop */
  function loopCam(){
    requestAnimationFrame(loopCam);
    if(capturing) return;
    if(!vctx || !pctx) return;

    const W=view.width/(window.devicePixelRatio||1), H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;

    if(warmupFrames>0){ resizeCam(); warmupFrames--; }

    pctx.fillStyle='rgba(0,0,0,.14)'; pctx.fillRect(0,0,PW,PH);

    if(camVideo && camVideo.readyState>=2){
      drawBestCover(pctx, camVideo, W, H, PW, PH);
      const frame=pctx.getImageData(0,0,PW,PH),d=frame.data;
      for(let i=0;i<d.length;i+=4){const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;}
      pctx.putImageData(frame,0,0);
    }

    vctx.imageSmoothingEnabled = false;
    vctx.drawImage(proc,0,0,W,H);

    if(charActive){ drawCharacter(W,H); }
  }

  /* Capture — 픽셀화→소멸 */
  let captureAnimating = false;
  captureBtn.addEventListener('click', ()=>{
    if(captureAnimating) return;
    playWoongClick();
    captureAnimating = true;

    capturing = true;
    const cssW = view.clientWidth, cssH = view.clientHeight;
    freezeLayer.width = cssW;
    freezeLayer.height = cssH;
    const fx = freezeLayer.getContext('2d');
    fx.imageSmoothingEnabled = false;
    fx.drawImage(view, 0, 0, view.width, view.height, 0, 0, cssW, cssH);
    freezeLayer.style.display='block';
    freezeLayer.style.opacity='1';

    setTimeout(()=>{
      const W = cssW, H = cssH;
      let px = 1.0;
      const step = 1.015;
      const off = document.createElement('canvas');
      const oc = off.getContext('2d');
      const fx2 = freezeLayer.getContext('2d');

      function anim(){
        if(px > 420){
          freezeLayer.style.transition='opacity 2000ms ease';
          freezeLayer.style.opacity='0';
          setTimeout(()=>{
            freezeLayer.style.display='none';
            freezeLayer.style.transition='';
            capturing = false;
            captureAnimating = false;
          }, 2020);
          return;
        }
        const w = Math.max(1, Math.floor(W/px));
        const h = Math.max(1, Math.floor(H/px));
        off.width = w; off.height = h;
        oc.imageSmoothingEnabled=false;
        oc.drawImage(freezeLayer,0,0,W,H,0,0,w,h);
        fx2.clearRect(0,0,W,H);
        fx2.imageSmoothingEnabled=false;
        fx2.globalAlpha = 1.0;
        fx2.drawImage(off,0,0,w,h,0,0,W,H);
        px = px * step + 0.35;
        requestAnimationFrame(anim);
      }
      anim();
    }, 100);
  });

  /* Flow start on load — 사용자의 첫 제스처 대기 */
  window.addEventListener('load', ()=>{ /* wait for gesture */ });

})();
</script>
</body>
</html>
