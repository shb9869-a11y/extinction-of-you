<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Camera – Motion Pan/Vol + Mic Focus (App/WebView safe)</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root{
    --frame: 40px; --ui-gap: 8px;
    /* vmin 기준으로 고정 → 가로/세로 회전해도 비율 유지 */
    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --pad-line: clamp(4px, 0.9vmin, 8px);
    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #view{width:100%;height:100%;display:block;position:fixed;left:0;top:0;z-index:0}
  .frameBox{position:fixed;left:var(--frame);top:var(--frame);right:var(--frame);bottom:var(--frame);border:1px solid #000;pointer-events:none;z-index:50}
  .uiBtn{background:#000;color:#fff;border:1px solid #000;font-size:var(--fs-strong);padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
  .controls{position:fixed;right:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small)}
  .btn-capture{position:fixed;left:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:150}
  #overlay{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;padding:20px;font-family:"Courier New",monospace;color:#fff;pointer-events:none}
  #overlayContent{pointer-events:auto;line-height:1.7;font-size:var(--fs-body);max-width:min(72ch, calc(100vw - (var(--frame)*2)));max-height:calc(100vh - (var(--frame)*2));overflow:hidden;text-align:left}
  .line{display:inline;background:#000;color:#fff;padding:calc(var(--pad-line)*0.8) var(--pad-line);box-decoration-break:clone;-webkit-box-decoration-break:clone}
  .lineWrap{margin:6px 0}
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}
  #goodnight{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:250;display:none;text-align:center;font-family:"Courier New",monospace;font-size:var(--fs-strong);color:#fff;background:#000;padding:var(--pad-btn-y) var(--pad-btn-x);white-space:nowrap;transition:opacity .6s ease}
  #goodnight.show{display:block;opacity:1}
  #goodnight.fadeout{opacity:0}
  @media (orientation:landscape){ :root{ --frame: 32px; } }
  .tip{opacity:.7;font-size:var(--fs-small);margin-top:8px}

  /* 컷인(침묵)용 */
  #cutin{
    position:fixed; inset:0; z-index:260; display:none; align-items:center; justify-content:center;
    background:#000; color:#fff; font-family:"Courier New",monospace; text-align:center;
  }
  #cutin.show{display:flex; opacity:1; transition:opacity .45s ease}
  #cutin.fadeout{opacity:0}
  #cutinText{font-size:clamp(24px, 8vmin, 64px); letter-spacing:.02em; line-height:1.2; padding:0 .2em}
  /* INTRODUCTION도 동일 크기로 강제 */
  .introTitle{font-weight:400; letter-spacing:.02em}
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.2×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <div id="overlay" class="fade">
    <div id="overlayContent" class="fade">
      <!-- 1단계: 환영 버튼 -->
      <button id="welcomeBtn" class="uiBtn">Welcome to ‘Dialogue into Silence’</button>
      <div class="tip" id="sensorTip" style="display:none">센서 권한 필요: 시작을 누르면 허용 팝업이 뜹니다.</div>
    </div>
  </div>

  <!-- GOOD NIGHT 문구 -->
  <div id="goodnight">GOOD NIGHT, HAVE A NICE DREAM</div>

  <!-- 컷인(침묵) 화면 -->
  <div id="cutin"><div id="cutinText">FIRST SILENCE</div></div>

<script>
(async ()=>{
  /* ========= 카메라(흑백+잔상) ========= */
  const view=document.getElementById('view');
  const vctx=view.getContext('2d',{alpha:false});
  const PROC_SCALE=0.60, TRAIL_ALPHA=0.12, GLOBAL_ALPHA=0.7;
  let ZOOM=1.2, ZOOM_MIN=0.5, ZOOM_MAX=3.0, ZOOM_STEP=0.1;

  const zoomVal=document.getElementById('zoomVal');
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const updateZoom=()=>zoomVal.textContent=ZOOM.toFixed(1)+'×';
  document.getElementById('zoomIn').onclick=()=>{ZOOM=clamp(ZOOM+ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  document.getElementById('zoomOut').onclick=()=>{ZOOM=clamp(ZOOM-ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom(); playClick();};
  updateZoom();

  const camVideo=document.createElement('video'); camVideo.autoplay=true; camVideo.playsInline=true; camVideo.muted=true;
  const proc=document.createElement('canvas'); const pctx=proc.getContext('2d',{willReadFrequently:true});

  async function attachCamera(){
    try{
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
      camVideo.srcObject=s; await camVideo.play().catch(()=>{});
    }catch(e){console.warn("카메라 실패:", e);}
  }
  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth,h=window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale=(window.matchMedia('(orientation: landscape)').matches)? PROC_SCALE*0.9 : PROC_SCALE;
    proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale);
  }
  resizeAll(); addEventListener('resize',()=>setTimeout(resizeAll,50));

  function loop(){
    requestAnimationFrame(loop);
    const W=view.width/(window.devicePixelRatio||1);
    const H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;
    pctx.globalCompositeOperation="source-over";
    pctx.fillStyle=`rgba(0,0,0,${TRAIL_ALPHA})`; pctx.fillRect(0,0,PW,PH);
    if(camVideo.readyState>=2){
      const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
      if(vw && vh){
        const base=Math.max(PW/vw,PH/vh), sc=base*ZOOM;
        const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
        pctx.globalAlpha=GLOBAL_ALPHA; pctx.drawImage(camVideo,dx,dy,dw,dh);
        pctx.globalAlpha=1.0;
        const frame=pctx.getImageData(0,0,PW,PH); const d=frame.data;
        for(let i=0;i<d.length;i+=4){
          const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;
        }
        pctx.putImageData(frame,0,0);
      }
    }
    vctx.drawImage(proc,0,0,W,H);
  }
  await attachCamera(); loop();

  /* ========= 오디오: 스테레오 안전 + 80Hz 드론 + 마이크 + 모션 + SFX ========= */
  let audioCtx=null, masterGain=null, limiter=null;
  let motionGain=null;         // 전체 볼륨
  let bgOsc=null, bgGain=null; // 80Hz 드론
  let micStream=null;
  let dronePermanentlyStopped=false; // GOOD NIGHT 이후 재시작 금지

  // 파라미터
  const DRONE_FREQ=80, DRONE_BASE=0.08, DRONE_MAX_ADD=0.10;
  const VOL_BASE=0.20, VOL_MAX_ADD=0.55;
  const SMOOTH_TC=0.08, CTRL_SMOOTH_ALPHA=0.12;
  const DEADZONE_VOL_DEG=5, DEADZONE_PAN_DEG=3, VOL_TILT_LIMIT=60, PAN_LIMIT_DEG=45;

  // 마이크(바람 억제 + 크게)
  const MIC_HP=220, MIC_LOWSHELF_FREQ=200, MIC_LOWSHELF_GAIN=-12;
  const NOTCH_FREQ=300, NOTCH_Q=3.5;
  const COMP_THRESHOLD=-20, COMP_RATIO=3.5, COMP_ATTACK=0.006, COMP_RELEASE=0.12;
  const MAKEUP_GAIN=3.2;
  const MIC_WET=0.55, MIC_DRY=0.08;

  function initAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    // 목적지 스테레오 보장 시도
    try{
      const dest = audioCtx.destination;
      if (dest.maxChannelCount && dest.maxChannelCount >= 2) dest.channelCount = 2;
      if (dest.channelCountMode) dest.channelCountMode = 'explicit';
      if (dest.channelInterpretation) dest.channelInterpretation = 'discrete';
    }catch{}

    // 믹스 버스 & 패너(네이티브/커스텀)
    const mixBus = audioCtx.createGain(); window.__mixBus__ = mixBus;
    let panSetter=null, panOutNode=null;
    if (audioCtx.createStereoPanner) {
      const sp = audioCtx.createStereoPanner();
      panSetter = (val)=>{ try{ sp.pan.setTargetAtTime(val, audioCtx.currentTime, 0.08); }catch{ sp.pan.value=val; } };
      mixBus.connect(sp); panOutNode = sp;
    } else {
      const lGain=audioCtx.createGain(), rGain=audioCtx.createGain(), merger=audioCtx.createChannelMerger(2);
      mixBus.connect(lGain); mixBus.connect(rGain);
      lGain.connect(merger,0,0); rGain.connect(merger,0,1);
      panSetter = (pan)=>{
        const p=Math.max(-1,Math.min(1,pan||0));
        const th=(p+1)*0.25*Math.PI; // equal-power
        const gL=Math.cos(th), gR=Math.sin(th);
        try{ lGain.gain.setTargetAtTime(gL,audioCtx.currentTime,0.08); rGain.gain.setTargetAtTime(gR,audioCtx.currentTime,0.08); }
        catch{ lGain.gain.value=gL; rGain.gain.value=gR; }
      };
      panOutNode=merger;
    }
    window.__setPan__ = panSetter;

    // 모션 게인 → 리미터 → 메이크업 → 마스터 → 출력
    motionGain = audioCtx.createGain(); motionGain.gain.value = VOL_BASE;
    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value=-3; limiter.knee.value=0; limiter.ratio.value=20;
    limiter.attack.value=0.002; limiter.release.value=0.10;
    const outMakeup = audioCtx.createGain(); outMakeup.gain.value = 1.6; // 앱에서 출력 작은 문제 보정
    masterGain = audioCtx.createGain(); masterGain.gain.value=1.0;

    panOutNode.connect(motionGain);
    motionGain.connect(limiter);
    limiter.connect(outMakeup);
    outMakeup.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    // 효과음 버스
    const sfxBus = audioCtx.createGain(); sfxBus.gain.value = 0.6;
    sfxBus.connect(window.__mixBus__);
    window.__sfxBus__ = sfxBus;
  }

  // 클릭 효과음(짧은 톤)
  function playClick(){
    try{
      initAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type='square'; osc.frequency.setValueAtTime(880, t);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.5, t+0.005);
      gain.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      osc.connect(gain).connect(window.__sfxBus__); osc.start(t); osc.stop(t+0.14);
    }catch{}
  }

  // 전환 효과음(짧은 우쉬)
  function playFlip(){
    try{
      initAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filt = audioCtx.createBiquadFilter();
      osc.type='triangle';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(900, t+0.25);
      filt.type='bandpass'; filt.frequency.setValueAtTime(800, t);
      filt.Q.value=1.2;
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.6, t+0.04);
      gain.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
      osc.connect(filt).connect(gain).connect(window.__sfxBus__); osc.start(t); osc.stop(t+0.38);
    }catch{}
  }

  function startDrone(){
    if(!audioCtx || bgOsc || dronePermanentlyStopped) return;
    bgOsc=audioCtx.createOscillator(); bgGain=audioCtx.createGain();
    bgOsc.type='sine'; bgOsc.frequency.value=DRONE_FREQ;
    bgGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    bgGain.gain.setTargetAtTime(DRONE_BASE, audioCtx.currentTime, 0.25);
    bgOsc.connect(bgGain).connect(window.__mixBus__);
    bgOsc.start();
  }
  function fadeOutDronePermanently(){
    if(!audioCtx || !bgGain || !bgOsc) { dronePermanentlyStopped=true; return; }
    const now=audioCtx.currentTime;
    try{ bgGain.gain.setTargetAtTime(0.0001, now, 0.5); }
    catch{ bgGain.gain.cancelScheduledValues(now); bgGain.gain.linearRampToValueAtTime(0.0001, now+3.0); }
    setTimeout(()=>{ try{ bgOsc.stop(); }catch{} bgOsc=null; bgGain=null; dronePermanentlyStopped=true; }, 3200);
  }

  async function startMic(){
    if(micStream) return;
    if(!navigator.mediaDevices?.getUserMedia) return;
    const ctrl=new AbortController(); const to=setTimeout(()=>{try{ctrl.abort();}catch{}},3000);
    try{
      micStream=await navigator.mediaDevices.getUserMedia({
        audio:{ echoCancellation:false, noiseSuppression:true, autoGainControl:false },
        video:false, signal:ctrl.signal
      });
    }catch(e){ clearTimeout(to); console.warn('Mic denied/timeout', e); return; }
    clearTimeout(to);

    const src=audioCtx.createMediaStreamSource(micStream);
    const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=MIC_HP; hpf.Q.value=0.707;
    const lowshelf=audioCtx.createBiquadFilter(); lowshelf.type='lowshelf'; lowshelf.frequency.value=MIC_LOWSHELF_FREQ; lowshelf.gain.value=MIC_LOWSHELF_GAIN;
    const notch=audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=NOTCH_FREQ; notch.Q.value=NOTCH_Q;
    const comp=audioCtx.createDynamicsCompressor();
    comp.threshold.value=COMP_THRESHOLD; comp.ratio.value=COMP_RATIO;
    comp.attack.value=COMP_ATTACK; comp.release.value=COMP_RELEASE;

    const convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(2.6,2.4);
    const tapA=audioCtx.createDelay(); tapA.delayTime.value=0.11;
    const tapB=audioCtx.createDelay(); tapB.delayTime.value=0.19;
    const tapC=audioCtx.createDelay(); tapC.delayTime.value=0.27;
    const fbA=audioCtx.createGain(); fbA.gain.value=0.28; tapA.connect(fbA).connect(tapA);
    const fbB=audioCtx.createGain(); fbB.gain.value=0.22; tapB.connect(fbB).connect(tapB);
    const fbC=audioCtx.createGain(); fbC.gain.value=0.18; tapC.connect(fbC).connect(tapC);

    const dry=audioCtx.createGain(); dry.gain.value=MIC_DRY;
    const wet=audioCtx.createGain(); wet.gain.value=MIC_WET;

    const micSum=audioCtx.createGain();
    const makeup=audioCtx.createGain(); makeup.gain.value=MAKEUP_GAIN;

    // 게이트
    const analyser=audioCtx.createAnalyser(); analyser.fftSize=512;
    const gateGain=audioCtx.createGain(); gateGain.gain.value=0; gateLoop(analyser, gateGain);

    // 결선
    src.connect(hpf).connect(lowshelf).connect(notch).connect(comp);
    comp.connect(analyser);
    comp.connect(dry);
    const wetSplit=audioCtx.createGain();
    comp.connect(wetSplit);
    wetSplit.connect(convolver); wetSplit.connect(tapA); wetSplit.connect(tapB); wetSplit.connect(tapC);
    const wetSum=audioCtx.createGain();
    convolver.connect(wetSum); tapA.connect(wetSum); tapB.connect(wetSum); tapC.connect(wetSum);
    wetSum.connect(wet);

    dry.connect(micSum); wet.connect(micSum);
    micSum.connect(gateGain).connect(makeup).connect(window.__mixBus__);
  }

  function gateLoop(analyser, gate){
    const buf=new Uint8Array(analyser.fftSize);
    let open=false;
    const GATE_OPEN_DB=-50, GATE_CLOSE_DB=-58, ATT=0.06, REL=0.25;
    function step(){
      requestAnimationFrame(step);
      analyser.getByteTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
      const rms=Math.sqrt(sum/buf.length);
      const db=20*Math.log10(Math.max(1e-6,rms));
      const now=audioCtx?.currentTime ?? 0;
      const shouldOpen = db>GATE_OPEN_DB || (open && db>GATE_CLOSE_DB);
      if(shouldOpen!==open){
        open=shouldOpen;
        try{ gate.gain.setTargetAtTime(open?1:0, now, open?ATT:REL); }
        catch{ gate.gain.cancelScheduledValues(now); gate.gain.linearRampToValueAtTime(open?1:0, now + (open?ATT:REL)); }
      }
    }
    step();
  }

  function makeIR(seconds=2.6, decay=2.4){
    const rate=audioCtx.sampleRate, len=Math.floor(rate*seconds);
    const ir=audioCtx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const v=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len, env=Math.pow(1-t, decay);
        v[i]=(Math.random()*2-1)*env*0.55;
      }
    }
    return ir;
  }

  /* ========= 센서 권한/감지 ========= */
  let sensorsReady=false;
  const sensorTip=document.getElementById('sensorTip');

  async function requestMotionPermissions(){
    // iOS 13+ 전용 권한 요청
    try{
      if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
        const r=await DeviceOrientationEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }else{
        // 안드로이드/일반 브라우저는 별도 요청 없고 바로 가능
        sensorsReady=true;
      }
    }catch(e){ console.warn('Orientation permission error:', e); }
    // 추가로 DeviceMotion도 시도(일부 환경에서 따로 필요)
    try{
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        const r=await DeviceMotionEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }
    }catch(e){}

    sensorTip.style.display = sensorsReady? 'none':'block';
    return sensorsReady;
  }

  // 모션 매핑(권한 없으면 pan=0 / vol=기본치 유지)
  let latestOri={beta:0,gamma:0}, smVol=VOL_BASE, smPan=0;

  function getScreenAngle(){
    const o=(screen.orientation&&screen.orientation.angle)??window.orientation??0;
    return (typeof o==='number')?o:0;
  }
  function mapOrientation(beta,gamma){
    const ang=((getScreenAngle()%360)+360)%360;
    let volTilt=0, panTilt=0;
    if(ang===0){volTilt=beta; panTilt=gamma;}
    else if(ang===90){volTilt=-gamma; panTilt=beta;}
    else if(ang===180){volTilt=-beta; panTilt=-gamma;}
    else if(ang===270){volTilt=gamma; panTilt=-beta;}
    return {volTilt, panTilt};
  }
  function tiltToPan(panTilt){
    const t=Math.min(PAN_LIMIT_DEG, Math.max(-PAN_LIMIT_DEG, panTilt||0));
    if(Math.abs(t)<DEADZONE_PAN_DEG) return 0;
    return t/PAN_LIMIT_DEG;
  }
  function tiltToVol(volTilt){
    const t=Math.min(VOL_TILT_LIMIT, Math.max(-VOL_TILT_LIMIT, volTilt||0));
    const a=Math.max(0, Math.abs(t)-DEADZONE_VOL_DEG)/(VOL_TILT_LIMIT-DEADZONE_VOL_DEG);
    return VOL_BASE + VOL_MAX_ADD*a;
  }
  function smoothStep(t,c,a=CTRL_SMOOTH_ALPHA){ return c+(t-c)*a; }

  function applyPanVol(pan, vol){
    if(!audioCtx) return;
    const now=audioCtx.currentTime;
    if(window.__setPan__) window.__setPan__(pan);
    if(motionGain){
      try{ motionGain.gain.setTargetAtTime(vol, now, SMOOTH_TC); }
      catch{ motionGain.gain.cancelScheduledValues(now); motionGain.gain.linearRampToValueAtTime(vol, now+0.08); }
    }
    if(bgGain && !dronePermanentlyStopped){
      const droneVol = DRONE_BASE + DRONE_MAX_ADD * ((vol - VOL_BASE) / (VOL_MAX_ADD||1));
      try{ bgGain.gain.setTargetAtTime(droneVol, now, SMOOTH_TC); }
      catch{ bgGain.gain.cancelScheduledValues(now); bgGain.gain.linearRampToValueAtTime(droneVol, now+0.08); }
    }
  }

  // 센서 이벤트 구독
  function initOrientationListener(){
    if(typeof DeviceOrientationEvent==='undefined') return;
    window.addEventListener('deviceorientation',(e)=>{
      latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0;
    },{passive:true});
  }

  function controlLoop(){
    requestAnimationFrame(controlLoop);
    let pan=0, vol=VOL_BASE;
    if(sensorsReady){
      const {volTilt, panTilt}=mapOrientation(latestOri.beta, latestOri.gamma);
      vol=smoothStep(tiltToVol(volTilt), smVol);
      pan=smoothStep(tiltToPan(panTilt), smPan);
      smVol=vol; smPan=pan;
    }else{
      // 권한 없으면 고정값 유지
      vol=smoothStep(VOL_BASE, smVol); pan=smoothStep(0, smPan);
      smVol=vol; smPan=pan;
    }
    applyPanVol(pan, vol);
  }

  /* ========= 자동 시작/버튼/GOOD NIGHT/컷인 & 시퀀스 ========= */
  function autoStart(){
    try{
      initAudio();
      if(audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
      // 드론은 GOOD NIGHT 이후엔 다시 시작하지 않음
      if(!dronePermanentlyStopped) startDrone();
    }catch(e){ console.warn('autoStart err', e); }
  }
  autoStart();
  document.addEventListener('visibilitychange', autoStart);
  window.addEventListener('focus', autoStart);

  const overlay=document.getElementById('overlay');
  const overlayContent=document.getElementById('overlayContent');
  const goodnight=document.getElementById('goodnight');
  const captureBtn=document.getElementById('captureBtn');
  const cutin=document.getElementById('cutin');
  const cutinText=document.getElementById('cutinText');

  function crossfadeUpdate(html,nextAction){
    overlayContent.classList.add('hidden');
    setTimeout(()=>{ overlayContent.innerHTML=html; overlayContent.classList.remove('hidden'); nextAction&&nextAction(); },450);
    playFlip(); // 전환 효과음
  }

  function showGoodNight(next){
    goodnight.textContent='GOOD NIGHT, HAVE A NICE DREAM';
    goodnight.classList.add('show');
    fadeOutDronePermanently(); // GOOD NIGHT 이후 80Hz는 영구히 꺼짐
    // 15초 노출 후 페이드아웃(기존 유지)
    setTimeout(()=>{
      goodnight.classList.add('fadeout');
      setTimeout(()=>{
        goodnight.classList.remove('show','fadeout');
        goodnight.style.display='none';
        next && next();
      },600);
    },15000);
  }

  // 컷인: 풀스크린 텍스트 (transparent 옵션 추가)
  function showCutIn(text, holdMs=3000, after, transparent=false){
    cutinText.textContent=text;
    cutin.style.background = transparent ? 'transparent' : '#000'; // 첫 침묵 투명 처리
    if(transparent){
      // 투명 배경에서는 가독성 위해 약간의 텍스트 그림자
      cutinText.style.textShadow = '0 0 8px rgba(0,0,0,.6)';
    }else{
      cutinText.style.textShadow = 'none';
    }
    cutin.classList.remove('fadeout');
    cutin.classList.add('show');
    playFlip(); // 표시 순간 효과음
    setTimeout(()=>{
      cutin.classList.add('fadeout');
      setTimeout(()=>{
        cutin.classList.remove('show','fadeout');
        cutin.style.display='none';
        after && after();
      }, 3000); // 페이드아웃 3초
    }, holdMs);
  }

  // 한국어 시퀀스(5초 간격, 페이드 전환) ← 요구사항 반영
  const narrative = [
    '자욱한 안개가 너를 맞이했다. 거대한 비석을 너는 마주했다. 거대한 비석들의 웅얼거림을 너는 들을 수 있었다.',
    '어디선가 잔잔한 종소리가 들려온다. 어디선가 께름칙한 울음소리가 들려온다. 어디선가 아이들의 웃음소리가 들려온다.',
    '너는 비석 사이를 거닐고 있다. 너를 스쳐 지나가며 웅얼거리는 소리에 귀를 기울인다.',
    '비석마다 다른 목소리가 담겨 있다. 어떤 것은 꿈을 이야기하고, 어떤 것은 기억을 읊고, 또 어떤 것은 아직 말하지 못한 언어로 중얼거린다.',
    '너는 발걸음을 늦춘다. 너는 생각한다. 이곳엔 분명 누군가가 존재하고 있었다.',
    '그리고, 지금도 여전히 그들의 호흡은 돌 틈에 스며 있고, 그들의 그림자는 안개 속에 머물며, 그들의 말하지 못한 시간은 너의 귀끝을 잡아당긴다.',
    '너는 발걸음을 멈춘다. 왜인지 이곳에 머물러야 한다는 느낌을 받는다.',
    '너는 그곳으로 발을 옮긴다. 그곳엔, 이곳에 존재했던 누군가의 ‘목소리’가 있다.',
    '너는 비석에 등을 기대고 앉는다. 그리고 서서히, 그것의 진동을 느낀다.'
  ];

  function showNarrativeSequence(done){
    // 오버레이 보이게 만들고 한 줄씩 페이드 교체
    overlay.style.display='flex';
    overlay.classList.remove('hidden');
    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    let idx = 0;

    function next(){
      if(idx >= narrative.length){
        // 전부 끝나면 서서히 사라짐
        overlay.classList.add('hidden');
        setTimeout(()=>{ overlay.style.display='none'; done && done(); }, 600);
        return;
      }
      // 교체 페이드
      overlayContent.classList.add('hidden');
      setTimeout(()=>{
        overlayContent.innerHTML = line(narrative[idx++]);
        overlayContent.classList.remove('hidden');
        playFlip(); // 각 문장 전환 효과음
        setTimeout(next, 5000); // 5초 간격으로 전환
      }, 450);
    }
    next();
  }

  function firstSilenceFlow(){
    // 첫 번째 침묵: 검정 배경 없이(transparent=true)
    showCutIn('FIRST SILENCE', 3000, ()=>{
      showNarrativeSequence(()=>{
        // 1초 뒤 두 번째 침묵 컷인(검정 배경 유지), 3초 페이드아웃
        setTimeout(()=>{
          showCutIn('SECOND SILENCE', 3000, ()=>{ /* 이어지는 단계 연결 지점 */ }, false);
        }, 1000);
      });
    }, true);
  }

  // 웰컴 → SLEEP 버튼 → INTRO → 카운트다운
  function mountPressToSleep(){
    const html = `<button id="startBtn" class="uiBtn">PRESS HERE TO SLEEP</button>
                  <div class="tip" id="sensorTip2" style="display:none">센서 권한 필요: 시작을 누르면 허용 팝업이 뜹니다.</div>`;
    crossfadeUpdate(html, ()=>{
      const startBtn=document.getElementById('startBtn');
      startBtn.addEventListener('click', ()=>{ playClick(); onStartPressed(); });
    });
  }

  async function onStartPressed(){
    autoStart();
    try{ startMic().catch(()=>{}); }catch{}
    initOrientationListener();
    const ok=await requestMotionPermissions();
    const tipEl = document.getElementById('sensorTip2') || document.getElementById('sensorTip');
    if(tipEl) tipEl.style.display = ok? 'none':'block';

    const line = s => `<div class="lineWrap"><span class="line">${s}</span></div>`;
    const introHTML = `
      ${line('<span class="introTitle">INTRODUCTION</span>')}
      ${line('이곳은 이미 ‘너’가 죽어버린, ‘그것’들의 세계다.')}
      ${line('곧 당신은 30분간의 잠에 들며, 무의식 속 여정을 시작한다.')}
      ${line('그 여정 속에서 당신은 사라져간 ‘너’를 마주하게 된다.')}
      ${line('이제 당신에게는 네 단계의 미션이 주어진다.')}
      ${line('당신은 미션에 따라 헤드폰으로 들려오는 ‘너’들의 목소리에 귀 기울이며, 휴대폰을 통해 잃어버린 ‘너’를 포착할 수 있다.')}
      <div id="countdown" class="lineWrap">
        <span class="line">THE DOOR WILL CLOSE IN <span id="countNum">60</span> SECONDS.</span>
      </div>
      <div class="tip" ${ok?'style="display:none"':''}>패닝이 안 들리면, 센서 권한을 허용해 주세요.</div>
    `;
    crossfadeUpdate(introHTML, ()=>{
      let count=60; const numEl=document.getElementById('countNum');
      const timer=setInterval(()=>{
        count--;
        if(count>=0){ numEl.textContent=count; }
        if(count<=0){
          clearInterval(timer);
          overlay.classList.add('hidden');
          setTimeout(()=>{
            overlay.style.display='none';
            showGoodNight(firstSilenceFlow); // GOOD NIGHT 후 첫 번째 침묵 플로우
          },450);
        }
      },1000);
    });

    controlLoop(); // 모션 제어 시작
  }

  // 환영 버튼 핸들
  const welcomeBtn = document.getElementById('welcomeBtn');
  welcomeBtn.addEventListener('click', ()=>{ playClick(); mountPressToSleep(); });

  // 캡처
  document.getElementById('captureBtn').addEventListener('click',()=>{
    playClick();
    try{ const a=document.createElement('a'); a.download=`capture_${Date.now()}.png`; a.href=view.toDataURL('image/png'); a.click(); }
    catch(e){ console.warn('CAPTURE 실패', e); }
  });
})();
</script>
</body>
</html>
