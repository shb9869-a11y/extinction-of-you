<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>SLEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEP</title>

<!-- 픽셀 게임 폰트 -->
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEEEEP">
<meta name="theme-color" content="#000000">

<style>
  :root{
    --appH: 100svh;
    --frame: clamp(16px, 4vmin, 40px);
    --ui-gap: 8px;

    --fs-body: clamp(12px, 2.2vmin, 16px);
    --fs-strong: clamp(14px, 2.8vmin, 20px);
    --fs-small: clamp(11px, 1.8vmin, 14px);
    --fs-name: clamp(14px,2.8vmin,20px);

    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);

    --safe-t: env(safe-area-inset-top, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);

    --dialogue-offset-vh: 8vh;
    --char-offset-vh: 16vh;

    /* 전체 톤을 흑백 계열로 */
    --accent: #e0e0e0;
  }

  html,body{
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    background:#000;
    overflow:hidden;
    touch-action:manipulation;
  }

  body{
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans KR",sans-serif;
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
    color:var(--accent);
  }

  *{
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    box-sizing:border-box;
  }
  input, textarea{
    -webkit-user-select:text;
    user-select:text;
  }

  .fade{opacity:0; transition:opacity 1800ms ease}
  .fade.show{opacity:1}

  #view{
    position:fixed;
    left:0;
    top:0;
    width:100vw;
    height:100vh;
    display:block;
    z-index:0;
    /* 카메라를 포함한 뒤 배경은 항상 흑백 */
    filter:grayscale(1);
  }
  #fg{
    position:fixed;
    left:0;
    top:0;
    width:100vw;
    height:100vh;
    display:block;
    z-index:880;
    pointer-events:none;
  }

  #freezeLayer{
    position:fixed;
    inset:0;
    z-index:500;
    display:none;
  }

  .frameBox{
    position:fixed;
    left:calc(var(--frame) + var(--safe-l));
    top:calc(var(--frame) + var(--safe-t));
    right:calc(var(--frame) + var(--safe-r));
    bottom:calc(var(--frame) + var(--safe-b));
    border:2px solid rgba(224,224,224,.75);
    pointer-events:none;
    z-index:50;
  }

  .uiBtn{
    background:transparent;
    color:var(--accent);
    border:none;
    font-size:var(--fs-strong);
    padding:var(--pad-btn-y) var(--pad-btn-x);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    white-space:nowrap;
    cursor:pointer;
    user-select:none;
  }
  .uiBtn.small{
    font-size:var(--fs-small);
    padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6);
  }
  .uiBtn.flat{
    border:none;
    background:transparent;
    text-decoration:none;
  }
  .uiBtn[disabled]{
    opacity:.35;
    pointer-events:none;
    filter:grayscale(1);
  }
  .hide{display:none !important;}

  .controls{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:400;
    display:flex;
    gap:6px;
    align-items:center;
    opacity:0;
    transition:opacity 1800ms ease;
  }
  .controls.show{opacity:1}

  .readout{
    min-width:48px;
    text-align:center;
    opacity:.9;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:var(--fs-small);
    color:var(--accent);
  }

  .btn-capture{
    position:fixed;
    left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
    z-index:450;
    opacity:0;
    transition:opacity 1800ms ease;
  }
  .btn-capture.show{opacity:1}

  /* SKIP 버튼 (모든 장에서 좌측 상단) */
  .skip-btn{
    position:fixed;
    left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
    z-index:1001;
    display:none;
  }

  #mapLauncher, #docLauncher, #audioToggle { display:none; }

  #runTimer{
    position:fixed;
    right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
    top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
    z-index:460;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:var(--fs-strong);
    color:var(--accent);
    opacity:.95;
    pointer-events:none;
    user-select:none;
    display:none;
  }

  .credits{
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    letter-spacing:.08em;
    font-size:clamp(9px,1.4vmin,11px);
    margin:0;
    color:var(--accent);
  }

  #rotateOverlay{
    position:fixed;
    inset:0;
    z-index:1000;
    display:none;
    align-items:center;
    justify-content:center;
    text-align:center;
    background:#000;
    color:var(--accent);
    padding:40px;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    pointer-events:auto;
  }

  /* Gate */
  #overlay{
    position:fixed;
    inset:0;
    z-index:300;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:calc(20px + var(--safe-t)) calc(20px + var(--safe-r)) calc(20px + var(--safe-b)) calc(20px + var(--safe-l));
    color:var(--accent);
    background:rgba(0,0,0,.85);
  }
  #overlayContent{
    max-width:min(92vw, 72ch);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    line-height:1.7;
    text-align:center;
  }
  .gateLine{
    display:inline-block;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:var(--fs-small);
    border:none;
    background:transparent;
    color:var(--accent);
    cursor:pointer;
    padding:6px 10px;
    width:100%;
    line-height:1.6;
  }
  .gateHint{
    opacity:.7;
    margin-top:6px;
    font-size:clamp(9px,1.6vmin,11px);
  }

  /* Name */
  #nameOverlay{
    position:fixed;
    inset:0;
    z-index:260;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.9);
    color:var(--accent);
    overflow:hidden;
  }
  #nameCity{
    position:absolute;
    inset:0;
    z-index:0;
  }
  #nameCard{
    position:relative;
    z-index:1;
    width:min(92vw,600px);
    text-align:center;
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  }
  #nameCard h2{
    margin:0 0 12px 0;
    letter-spacing:.12em;
    font-size:var(--fs-name);
    font-weight:400;
    text-shadow:0 0 12px rgba(0,0,0,.9);
    color:var(--accent);
  }
  #nick{
    width:100%;
    padding:14px 14px;
    background:rgba(0,0,0,.88);
    border:1px solid #777;
    color:var(--accent);
    font-size:var(--fs-name);
    outline:none;
    box-shadow:0 0 12px rgba(0,0,0,.8);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  }
  #nick::placeholder{
    color:rgba(224,224,224,0.25);
  }
  #nameRow{
    display:flex;
    gap:10px;
    margin-top:16px;
    justify-content:center;
  }
  #nameRow .uiBtn{
    padding:10px 18px;
  }

  /* Preset */
  #preset{
    position:fixed;
    inset:0;
    z-index:250;
    background:#000;
    display:none;
    cursor:pointer;
  }
  #presetCanvas{
    position:absolute;
    left:0;top:0;width:100%;height:100%;
  }

  /* Welcome */
  #overlayWelcome{
    position:fixed;
    inset:0;
    z-index:220;
    display:none;
    place-items:center;
    color:var(--accent);
    background:rgba(0,0,0,.55);
    padding:0;
  }
  #welcomeCard{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    width:100%;
    max-width:min(92vw, 820px);
    margin:0 auto;
    text-align:center;
    padding:calc(20px + var(--safe-t)) 20px calc(20px + var(--safe-b)) 20px;
    gap:18px;
  }
  #welcomeCard .title{
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    font-size:clamp(28px, 8vmin, 72px);
    font-weight:400;
    letter-spacing:.12em;
    line-height:1.15;
    margin:0;
    text-transform:uppercase;
    color:var(--accent);
    white-space:nowrap;
  }
  #goIntro{
    margin-top:0;
    font-size:var(--fs-small);
  }

  /* INTRO big title (박스 제거) */
  #introBig{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    z-index:210;
  }
  #introBigText{
    color:var(--accent);
    font-weight:400;
    letter-spacing:.16em;
    font-size:clamp(32px, 12vmin, 160px);
    text-transform:uppercase;
    text-align:center;
    white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    background:transparent;
    border:none;
    padding:0;
  }

  /* INTRO 텍스트 박스 */
  #introDialogue{
    position:fixed;
    right:calc(var(--frame) + var(--safe-r) + 12px);
    bottom:calc(var(--frame) + var(--safe-b) + 12px);
    max-width:min(420px, 60vw);
    padding:12px 14px 10px;
    border:1px solid rgba(224,224,224,0.9);
    background:#000;
    font-family:"Courier New",ui-monospace,monospace;
    font-size:clamp(11px,2.1vmin,15px);
    line-height:1.7;
    color:var(--accent);
    display:none;
    z-index:900;
  }
  #introText{
    margin-bottom:8px;
    text-align:left;
    white-space:pre-line;
  }
  #introNext{
    display:inline-block;
    margin-left:auto;
  }

  /* THE FIRST SLEEP title (박스 제거) */
  #firstSleep{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    z-index:850;
  }
  #firstSleepText{
    color:var(--accent);
    font-weight:400;
    letter-spacing:.16em;
    font-size:clamp(32px, 12vmin, 160px);
    text-transform:uppercase;
    text-align:center;
    white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85), 0 2px 4px rgba(0,0,0,.7);
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    background:transparent;
    border:none;
    padding:0;
  }

  /* NOTICE Popup (FIRST SLEEP) */
  #noticePopup{
    position:fixed;
    inset:0;
    z-index:900;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.72);
  }
  #noticeCard{
    width:min(92vw, 640px);
    background:#0b0b0b;
    color:var(--accent);
    border:1px solid #333;
    padding:18px;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    font-family:"Courier New",ui-monospace,monospace;
    line-height:1.7;
  }
  #noticeCard h3{
    margin:0 0 6px 0;
    letter-spacing:.06em;
    font-weight:700;
    font-size:clamp(15px,3vmin,20px);
    color:var(--accent);
  }
  #noticeCard p{
    margin:4px 0;
    font-size:clamp(12px,2.4vmin,16px);
  }
  #noticeActions{
    margin-top:10px;
    text-align:right;
  }

  /* FIRST SLEEP: 중앙 문장 오버레이 */
  #chapterOverlay{
    position:fixed;
    inset:0;
    z-index:930;
    display:none;
    align-items:center;
    justify-content:center;
    background:transparent;
    color:var(--accent);
    padding:24px;
    pointer-events:none;
  }
  #chapterCenter{
    max-width:min(900px, 92vw);
    max-height:80vh;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    overflow:hidden;
  }
  #chapterBox{
    display:inline-block;
    font-family:"Courier New",ui-monospace,monospace;
    line-height:1.8;
    font-size:clamp(11px,2.0vmin,15px);
    text-align:center;
    color:var(--accent);
    padding:0;
    background:transparent;
    border:none;
    box-shadow:none;
  }

  /* 1장 텍스트 글자 박스 – 노란 테두리 제거 */
  .charBox{
    display:inline-block;
    background:#000;
    color:var(--accent);
    padding:3px 2px;
    margin:1px 0;
    border-radius:0;
    border:none;
    box-sizing:border-box;
  }

  /* INTRO → FIRST SLEEP: SLEEEEEEEEP + THE FIRST SLEEP (두 줄 타이핑) */
  #firstTransition{
    position:fixed;
    inset:0;
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    background:#000;
    color:var(--accent);
    z-index:940;
    pointer-events:none;
  }
  .sleepLine{
    font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
    letter-spacing:.14em;
    font-size:clamp(24px, 7vmin, 72px);
    text-transform:uppercase;
    white-space:nowrap;
    text-shadow:0 0 8px rgba(0,0,0,.85);
    margin:6px 0;
    padding:8px 16px;
    background:transparent;
    border:none;
    display:inline-block;
  }
  #firstTransWord{
    margin-bottom:10px;
  }
  #firstTransTitle{
    margin-top:10px;
  }

  /* BETWEEN FIRST & SECOND SLEEP */
  #sleepTransition{
    position:fixed;
    inset:0;
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    background:#000;
    color:var(--accent);
    z-index:940;
    pointer-events:none;
  }
  #sleepSecondTitle{
    margin-top:14px;
    font-size:clamp(18px,5vmin,48px);
  }

  /* SECOND NOTICE */
  #noticePopup2{
    position:fixed;
    inset:0;
    z-index:960;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.8);
  }
  #noticeCard2{
    width:min(92vw, 640px);
    background:#0b0b0b;
    color:var(--accent);
    border:1px solid #444;
    padding:18px;
    box-shadow:0 10px 30px rgba(0,0,0,.8);
    font-family:"Courier New",ui-monospace,monospace;
    line-height:1.7;
  }
  #noticeCard2 h3{
    margin:0 0 6px 0;
    letter-spacing:.06em;
    font-weight:700;
    font-size:clamp(15px,3vmin,20px);
    color:var(--accent);
  }
  #noticeCard2 p{
    margin:4px 0;
    font-size:clamp(12px,2.4vmin,16px);
  }
  #noticeActions2{
    margin-top:10px;
    text-align:right;
  }

  /* MAP OVERLAY – 2장 직사각형 지도 */
  #mapOverlay{
    position:fixed;
    inset:0;
    z-index:950;
    display:none;
    align-items:center;
    justify-content:center;
    background:#000;
    overflow:hidden;
  }
  #mapCanvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
  }

  .map-popup{
    position:fixed;
    inset:0;
    z-index:970;
    display:none;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .map-popup-inner{
    pointer-events:auto;
    width:min(92vw, 520px);
    background:#050505;
    border:1px solid #333;
    box-shadow:0 10px 30px rgba(0,0,0,.85);
    padding:18px 18px 14px;
    color:var(--accent);
    font-family:"Courier New",ui-monospace,monospace;
    position:relative;
    line-height:1.7;
  }
  .map-pop-close{
    position:absolute;
    top:8px;
    right:10px;
  }
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <canvas id="fg"></canvas>

  <canvas id="freezeLayer"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>
  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <!-- 공통 SKIP 버튼 -->
  <button id="skipBtn" class="uiBtn small skip-btn" type="button">SKIP</button>

  <button id="docLauncher" class="uiBtn small">DOCUMENT</button>
  <button id="mapLauncher" class="uiBtn small">MAP</button>
  <button id="audioToggle" class="uiBtn small">AUDIO</button>
  <div id="runTimer" aria-live="polite">04:00</div>

  <div id="rotateOverlay" aria-live="polite">
    <div>
      <b>Landscape mode required</b><br/>
      Please rotate your device to landscape to continue.<br/>
      If the screen doesn’t rotate, unlock orientation in your device settings.
    </div>
  </div>

  <!-- Permission Gate -->
  <div id="overlay" class="fade show">
    <div id="overlayContent">
      <div class="credits">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <button id="permGateBtn" class="gateLine" type="button">
        Tap anywhere to allow Camera, Microphone & Motion sensors
      </button>
      <div class="gateHint">After allowing, you'll move to the name screen.</div>
    </div>
  </div>

  <!-- Name -->
  <div id="nameOverlay" class="fade">
    <canvas id="nameCity"></canvas>
    <div id="nameCard">
      <h2>TELL ME YOUR NAME</h2>
      <input id="nick" type="text" maxlength="24" placeholder="" autocomplete="off" />
      <div id="nameRow">
        <button id="nameSubmit" class="uiBtn flat" type="button">GO</button>
      </div>
    </div>
  </div>

  <!-- Preset -->
  <div id="preset" class="fade" title="Tap to continue">
    <canvas id="presetCanvas"></canvas>
  </div>

  <!-- Welcome -->
  <div id="overlayWelcome" class="fade">
    <div id="welcomeCard">
      <div class="credits">SHB, KHJ, JYS, KTK, KCW, KJS, JMJ, PHY</div>
      <div class="title">SLEEEEEEEEP</div>
      <div class="title">SLEEEEEEEEP</div>
      <div class="title">SLEEEEEEEEP</div>
      <div class="title">SLEEEEEEEEP</div>
      <button id="goIntro" class="uiBtn flat" type="button">PRESS HERE TO SLEEP</button>
    </div>
  </div>

  <!-- INTRODUCTION title -->
  <div id="introBig" class="fade"><div id="introBigText">INTRODUCTION</div></div>

  <!-- INTRODUCTION sentences -->
  <div id="introDialogue">
    <div id="introText"></div>
    <button id="introNext" class="uiBtn small" type="button">NEXT</button>
  </div>

  <!-- THE FIRST SLEEP title (지금은 사용 X) -->
  <div id="firstSleep"><div id="firstSleepText">THE FIRST SLEEP</div></div>

  <!-- NOTICE Popup (FIRST SLEEP) -->
  <div id="noticePopup" class="fade" role="dialog" aria-modal="true" aria-labelledby="noticeTitle">
    <div id="noticeCard">
      <h3 id="noticeTitle">NOTICE</h3>
      <p>※ “THE FIRST SLEEP”은 눈으로 인식하던 타자를 귀로 인식해 나가는 챕터입니다.</p>
      <p>※ 앞으로 당신의 태블릿 위로 타자와 몇가지 흔적들이 텍스트로 제시될 것입니다.</p>
      <p>※ 당신은 내면 세계의 탐험가로써 그 흔적들을 화면 아래 ‘CAPTURE’와 ‘+’, ‘-’버튼을 눌러 포착하세요.</p>
      <p>※ 확인하셨다면, 아래 ‘OK’버튼을 눌러주세요</p>
      <div id="noticeActions">
        <button id="noticeOk" class="uiBtn flat" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- FIRST SLEEP: 중앙 문장 -->
  <div id="chapterOverlay" class="fade">
    <div id="chapterCenter">
      <div id="chapterBox"></div>
    </div>
  </div>

  <!-- INTRO → FIRST SLEEP: SLEEEEEEEEP + THE FIRST SLEEP -->
  <div id="firstTransition" class="fade">
    <div id="firstTransWord" class="sleepLine"></div>
    <div id="firstTransTitle" class="sleepLine"></div>
  </div>

  <!-- BETWEEN FIRST & SECOND SLEEP -->
  <div id="sleepTransition" class="fade">
    <div id="sleepLine1" class="sleepLine"></div>
    <div id="sleepLine2" class="sleepLine"></div>
    <div id="sleepSecondTitle" class="sleepLine"></div>
  </div>

  <!-- SECOND NOTICE (지도 전) -->
  <div id="noticePopup2" class="fade" role="dialog" aria-modal="true" aria-labelledby="noticeTitle2">
    <div id="noticeCard2">
      <h3 id="noticeTitle2">NOTICE</h3>
      <p>※ 이제 두 번째 수면으로 진입하기 전, 내면의 지도 위에서 여덟 개의 지점을 탐험하게 됩니다.</p>
      <p>※ 지도 중앙의 육각형을 중심으로 1번부터 8번까지의 사각형을 클릭하여 각 구역의 목소리를 불러오세요.</p>
      <p>※ 준비가 되었다면 아래 ‘OK’를 눌러 지도로 이동합니다.</p>
      <div id="noticeActions2">
        <button id="noticeOk2" class="uiBtn flat" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- MAP OVERLAY -->
  <div id="mapOverlay">
    <canvas id="mapCanvas"></canvas>
  </div>

  <!-- MAP POPUP -->
  <div id="mapPop" class="map-popup">
    <div class="map-popup-inner">
      <button id="mapPopClose" class="uiBtn small map-pop-close" type="button">CLOSE</button>
      <div id="mapPopBody"></div>
    </div>
  </div>

<script>
(() => {
  (function injectManifest(){
    const manifest = {
      "name":"SLEEEEEP",
      "short_name":"SLEEEEEP",
      "display":"fullscreen",
      "start_url":"./",
      "background_color":"#000",
      "theme_color":"#000",
      "icons":[]
    };
    const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:"application/manifest+json"}));
    const link = document.createElement('link');
    link.rel='manifest';
    link.href=url;
    document.head.appendChild(link);
  })();

  async function enterFullscreen(){
    try{
      const el = document.documentElement;
      if (!document.fullscreenElement) {
        if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      }
    }catch(e){}
    try{
      if (screen.orientation && screen.orientation.lock) {
        await screen.orientation.lock('landscape').catch(()=>{});
      }
    }catch(e){}
  }
  let wakeLock = null;
  async function keepAwake(){
    try{
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', ()=>{});
      }
    }catch(e){}
  }
  function claimImmersive(){ enterFullscreen(); keepAwake(); }
  document.addEventListener('visibilitychange', async ()=>{
    if (document.visibilityState === 'visible' && wakeLock) {
      try{ wakeLock = await navigator.wakeLock.request('screen'); }catch(e){}
    }
  });

  const FADE = 1800;
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const nextFrame = () => new Promise(resolve=>requestAnimationFrame(()=>resolve()));
  const qs = s => document.querySelector(s);

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  function fadeShow(el, dur=FADE, display='flex'){
    el.style.display=display;
    el.style.opacity='0';
    el.style.transition=`opacity ${dur}ms ease`;
    requestAnimationFrame(()=> el.style.opacity='1');
  }
  function fadeHide(el, dur=FADE){
    el.style.transition=`opacity ${dur}ms ease`;
    el.style.opacity='0';
    setTimeout(()=>{ el.style.display='none'; }, dur);
  }

  function setAppH(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH();
  addEventListener('resize', setAppH, {passive:true});
  if (window.visualViewport){
    visualViewport.addEventListener('resize', ()=>setTimeout(setAppH,50));
  }

  const rotateOverlay = qs('#rotateOverlay');
  function isPortrait(){
    const vv=window.visualViewport;
    const w=vv?vv.width:innerWidth, h=vv?vv.height:innerHeight;
    return h>w;
  }
  function updateRotateOverlay(){
    rotateOverlay.style.display = isPortrait() ? 'flex' : 'none';
  }
  ['load','pageshow','resize','orientationchange','visibilitychange'].forEach(ev=>{
    addEventListener(ev, updateRotateOverlay, {passive:true});
  });
  updateRotateOverlay();

  const overlay = qs('#overlay');
  const permBtn = qs('#permGateBtn');
  const nameOverlay = qs('#nameOverlay');
  const nameCityCanvas = qs('#nameCity');
  const nickInput = qs('#nick');
  const nameSubmit = qs('#nameSubmit');
  const preset = qs('#preset');
  const presetCanvas = qs('#presetCanvas');
  const welcome = qs('#overlayWelcome');

  const introBig = qs('#introBig');
  const introBigText = qs('#introBigText');

  const introDialogue = qs('#introDialogue');
  const introTextEl = qs('#introText');
  const introNextBtn = qs('#introNext');

  const firstSleep = qs('#firstSleep');
  const firstSleepText = qs('#firstSleepText');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');
  const view = qs('#view');
  const fg = qs('#fg');
  const freezeLayer = qs('#freezeLayer');
  const runTimer = qs('#runTimer');

  const noticePopup = qs('#noticePopup');
  const noticeOk = qs('#noticeOk');

  const chapterOverlay = qs('#chapterOverlay');
  const chapterBox = qs('#chapterBox');

  const firstTransition = qs('#firstTransition');
  const firstTransWord = qs('#firstTransWord');
  const firstTransTitle = qs('#firstTransTitle');

  const sleepTransition = qs('#sleepTransition');
  const sleepLine1 = qs('#sleepLine1');
  const sleepLine2 = qs('#sleepLine2');
  const sleepSecondTitle = qs('#sleepSecondTitle');

  const noticePopup2 = qs('#noticePopup2');
  const noticeOk2 = qs('#noticeOk2');

  const mapOverlay = qs('#mapOverlay');
  const mapCanvas = qs('#mapCanvas');
  const mapPop = qs('#mapPop');
  const mapPopBody = qs('#mapPopBody');
  const mapPopClose = qs('#mapPopClose');

  const skipBtn = qs('#skipBtn');

  let vctx=null, fgctx=null;

  let camPermGranted=false;
  let camStream=null, camVideo=null, ZOOM=1.0;
  let animStarted=false, capturing=false, warmupFrames=0;

  let showIntroLayer=false;
  let fgAlpha=1.0;
  let showCamera=false;
  let camFadeAlpha=0;

  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  async function ensureResumed(){
    try{
      ensureAudio();
      if(audioCtx.state==='suspended') await audioCtx.resume();
    }catch{}
  }

  /* 현재 챕터 상태 */
  let stage = 'gate';

  const Ambient = (() => {
    let ctx, master, delay, fb, hp, lp, mix, busGain, running=false, killers=[];
    function midi(n){ return 440 * Math.pow(2, (n-69)/12); }
    function setup(){
      ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value=0.0001;
      delay = ctx.createDelay(2.5); delay.delayTime.value=0.35;
      fb = ctx.createGain(); fb.gain.value=0.35; delay.connect(fb).connect(delay);
      hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=150;
      lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=4500;
      mix = ctx.createGain(); mix.gain.value = 0.6; mix.connect(hp).connect(lp).connect(master);
      busGain = ctx.createGain(); busGain.gain.value=0.9; busGain.connect(master);
      master.connect(ctx.destination);
    }
    function connectDW(node){ node.connect(busGain); node.connect(delay); delay.connect(mix); }
    function airy(){
      const b=audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
      const d=b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.15;
      const s=audioCtx.createBufferSource();
      s.buffer=b; s.loop=true;
      const g=audioCtx.createGain(); g.gain.value=0.02;
      const f=audioCtx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=800; f.Q.value=0.7;
      s.connect(f).connect(g);
      connectDW(g);
      s.start();
      killers.push(()=>{ try{s.stop();}catch{} });
    }
    function pad(root){
      const out = audioCtx.createGain(); out.gain.value=0.35;
      const filt=audioCtx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=600; filt.Q.value=0.6;
      const lfo=audioCtx.createOscillator(); const lfoG=audioCtx.createGain();
      lfo.type='sine'; lfo.frequency.value=0.05; lfoG.gain.value=220;
      lfo.connect(lfoG).connect(filt.frequency); lfo.start();
      [0,7,12].forEach((i,k)=>{
        const o=audioCtx.createOscillator();
        o.type='sawtooth';
        o.frequency.value=midi(root+i);
        o.detune.value=(k-1)*6;
        const g=audioCtx.createGain(); g.gain.value=0.08;
        o.connect(g).connect(filt);
        o.start();
        killers.push(()=>g.disconnect());
      });
      filt.connect(out);
      connectDW(out);
      killers.push(()=>{ try{ out.disconnect(); }catch{} });
    }
    async function start(fadeIn=0.8, target=1.0){
      await ensureResumed();
      if(running) return;
      setup();
      running=true;
      airy();
      const seq=[57,52,48,43];
      let i=0;
      (function tick(){
        if(!running) return;
        pad(seq[i%seq.length]);
        i++;
        setTimeout(tick,8000);
      })();
      const t=(audioCtx||ctx).currentTime;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.exponentialRampToValueAtTime(target, t+fadeIn);
    }
    function stop(fade=2.0){
      if(!running||!master) return;
      const t=(audioCtx||ctx).currentTime;
      master.gain.linearRampToValueAtTime(0.0001, t+fade);
      setTimeout(()=>{
        killers.forEach(fn=>{try{fn();}catch{}});
        killers=[];
        running=false;
      }, fade*1000+120);
    }
    function isRunning(){ return running; }
    return { start, stop, isRunning };
  })();

  async function playWoongClick(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type='sine';
      o.frequency.setValueAtTime(180, now);
      o.frequency.exponentialRampToValueAtTime(70, now+0.32);
      f.type='lowpass';
      f.frequency.setValueAtTime(1400, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.8, now+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.55);
      o.connect(f).connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(now+0.58);
    }catch(e){}
  }
  async function playTduung(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o1.type='sine'; o2.type='sine';
      o1.frequency.value=90; o2.frequency.value=45;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(1.0, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
      o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
      o1.start(); o2.start();
      o1.stop(now+0.62); o2.stop(now+0.62);
    }catch(e){}
  }
  async function playBellChime(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc1.type='sine'; osc2.type='sine';
      osc1.frequency.setValueAtTime(1200, now);
      osc2.frequency.setValueAtTime(1800, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.9, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+1.4);
      osc1.connect(g); osc2.connect(g); g.connect(audioCtx.destination);
      osc1.start(now); osc2.start(now);
      osc1.stop(now+1.5); osc2.stop(now+1.5);
    }catch(e){}
  }

  /* 2장용: 작은 짤랑 짤랑 종소리 루프 */
  let secondBellInterval = null;
  let secondBellRunning = false;

  async function playSoftBellChime(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g  = audioCtx.createGain();
      o1.type='sine';
      o2.type='sine';
      o1.frequency.setValueAtTime(880, now);
      o2.frequency.setValueAtTime(1320, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.35, now+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, now+2.4);
      o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
      o1.start(now); o2.start(now);
      o1.stop(now+2.5); o2.stop(now+2.5);
    }catch(e){}
  }

  function startSecondBell(){
    if(secondBellRunning) return;
    secondBellRunning = true;
    playSoftBellChime();
    secondBellInterval = setInterval(()=>{ playSoftBellChime(); }, 12000);
  }

  function stopSecondBell(){
    if(secondBellInterval) clearInterval(secondBellInterval);
    secondBellInterval = null;
    secondBellRunning = false;
  }

  function typeTick(){
    try{
      ensureAudio();
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='square'; o.frequency.value=900;
      g.gain.value=0.0001;
      g.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.10);
      o.connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime+0.12);
    }catch(e){}
  }

  function updateZoomLabel(){
    zoomVal.textContent = ZOOM.toFixed(1)+'×';
  }
  updateZoomLabel();
  zoomIn.addEventListener('click', async ()=>{
    ZOOM=Math.min(3.0, ZOOM+0.05);
    updateZoomLabel();
    await playWoongClick();
  }, {passive:true});
  zoomOut.addEventListener('click', async ()=>{
    ZOOM=1.0;
    updateZoomLabel();
    await playWoongClick();
  }, {passive:true});

  async function immediateGestureStart(e){
    e && e.preventDefault && e.preventDefault();

    claimImmersive();
    await ensureResumed();

    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(()=>{ claimImmersive(); })
          .catch(()=>{});
      }
    }catch(_){}

    navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:'environment'},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}
    })
    .then(async (s)=>{
      await ensureResumed();
      if(!Ambient.isRunning()) Ambient.start(0.8, 1.0);
      claimImmersive();
      s.getTracks().forEach(t=>t.stop());
      camPermGranted = true;
    })
    .catch(err=>{
      console.warn('permission error:', err);
    })
    .finally(()=>{
      fadeHide(overlay, FADE);
      fadeShow(nameOverlay, FADE);
      startNameCity();
      stage = 'name';
      setTimeout(()=>nickInput && nickInput.focus && nickInput.focus(), 60);
    });
  }

  ['click','touchstart','pointerdown'].forEach(type=>{
    permBtn.addEventListener(type, immediateGestureStart, {passive:false});
    overlay.addEventListener(type, immediateGestureStart, {passive:false});
    window.addEventListener(type, (ev)=>{
      if(getComputedStyle(overlay).display !== 'none'){
        immediateGestureStart(ev);
      }
    }, {passive:false});
  });

  let displayName = '_____';
  async function acceptName(){
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.2, 1.0);
    const v = (nickInput.value||'').trim();
    if(v.length>0){ displayName = v; }
    await playWoongClick();
    stopNameCity();
    fadeHide(nameOverlay, FADE);
    showPreset();
    stage = 'preset';
    skipBtn.style.display='block';
  }
  nameSubmit.addEventListener('click', acceptName, {passive:true});
  nickInput.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){ acceptName(); }
  });

  let saverObjs=[], saverMode='scatter', saverT0=0;
  function showPreset(){
    preset.style.display='block';
    preset.classList.add('show');
    fadeShow(preset, FADE);
    initSaver();
    startCameraFresh(true);
  }
  function initSaver(){
    const w=preset.clientWidth, h=preset.clientHeight;
    saverObjs=[];
    const letters=['S','L','E','E','E','E','E','E','E','E','P'];
    for(let i=0;i<20;i++){
      saverObjs.push({
        ch:letters[i%letters.length],
        x:Math.random()*w,
        y:Math.random()*h,
        vx:(Math.random()*1.2+0.3)*(Math.random()<.5?-1:1),
        vy:(Math.random()*1.2+0.3)*(Math.random()<.5?-1:1),
        phase:Math.random()*Math.PI*2,
        size:(Math.floor(Math.random()*60)+90)*2
      });
    }
    saverT0=performance.now();
    requestAnimationFrame(saverLoop);
  }
  function saverTargetsForWord(){
    const w=preset.clientWidth, h=preset.clientHeight;
    const base=Math.min(w,h)*0.55;
    const cx=w/2, cy=h/2;
    const spacing=base/5;
    const left=cx-(spacing*2);
    return [
      {x:left,y:cy},
      {x:left+spacing,y:cy},
      {x:left+spacing*2,y:cy},
      {x:left+spacing*3,y:cy},
      {x:left+spacing*4,y:cy}
    ];
  }
  function saverLoop(){
    if(preset.style.display==='none') return;
    const now=performance.now();
    const w=preset.clientWidth, h=preset.clientHeight;
    const dpr=devicePixelRatio||1;
    presetCanvas.width=w*dpr;
    presetCanvas.height=h*dpr;
    const ctx=presetCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,w,h);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    const dt=(now-saverT0)/1000;
    if(dt>Math.random()*2+6){
      saverMode=(saverMode==='scatter'?'assemble':'scatter');
      saverT0=now;
    }
    const targets=saverMode==='assemble'?saverTargetsForWord():null;
    for(const o of saverObjs){
      if(saverMode==='assemble'){
        const g=targets[0];
        o.vx += (g.x-o.x)*0.0006;
        o.vy += (g.y-o.y)*0.0006;
      }
      o.x+=o.vx;
      o.y+=o.vy;
      if(o.x<0||o.x>w) o.vx*=-1;
      if(o.y<0||o.y>h) o.vy*=-1;
      const wob=Math.sin(now/500+o.phase)*0.12+1;
      ctx.save();
      ctx.translate(o.x,o.y);
      ctx.scale(wob,1/wob);
      ctx.font=`900 ${o.size}px "Press Start 2P", system-ui, sans-serif`;
      ctx.fillStyle='#e0e0e0';
      ctx.fillText(o.ch,0,0);
      ctx.restore();
    }
    requestAnimationFrame(saverLoop);
  }

  preset.addEventListener('click', async ()=>{
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.2, 1.0);
    await playWoongClick();
    fadeHide(preset, FADE);
    await startCameraFresh(false);
    fadeShow(welcome, FADE);
    fitWelcomeTitles();
    stage = 'welcome';
  }, {passive:true});

  const INTRO_LINES = [
    '안녕하세요?',
    '작게 대답해주세요.',
    '안녕하세요?',
    '대답을 해주셔야 프로그램이 진행될 수 있습니다.',
    '안녕하세요?',
    '감사합니다.',
    '아실지 모르겠지만, 저는 이 공간의 안내자,',
    '당신의 내면 세계에 존재하는 무의식입니다.',
    '지금부터 우리는 _____의 내면 세계를 탐험하는 탐험가가 될 것입니다.',
    '주변의 소리에 귀를 기울이며,',
    '30분 간의 짧은 낮잠을 통해서 말이죠.',
    '자, 그럼 천천히 공간을 거닐어보세요.',
    '무릎을 들고, 발을 앞으로 뻗어보세요.',
    '하셨나요?',
    '참 잘했어요.',
    '맞아요. 그래 맞아요. 우리는 늘 그랬어요.',
    '우리는 언제나 타자와 함께 존재해 왔습니다.',
    '가족, 친구, 교수님, 지나가는 그들,',
    '그리고 당신과 처음 만나는 저도 우리는 늘 함께 존재해왔습니다',
    "그러나 어느 순간 '너'로 불리던 그들은 '그것'으로 전락하기 시작했습니다.",
    '이유는 아무도 몰라요.',
    "그저 우리가 '너'들을 '그것'들로 부르기 시작한 것일까요?",
    '이유는 아무도 모르죠.',
    '아...',
    '갑자기 김춘추의 <꽃>이 떠오르네요.',
    '(진지한 톤으로) 내가 그의 이름을 불러주기 전에는 그는 다만 하나의 몸짓에 지나지 않았다.',
    '크으으으으으으....',
    '네. 각설하고.',
    "말씀드린 것처럼, 이제 우리는 어느 곳에서도 '너'를 찾아볼 수 없습니다.",
    "우리는 이제 '너'가 사라진 세상에 살아가고 있으니까요.",
    "그런 특정했던 '너'는 서서히 희미해지고 퇴색되고 잊혀지고 잃어지고 앓아가고 있습니다",
    '마치 꿈 속에서 만난 누군가가',
    '...',
    '그게 누구였지?',
    '...',
    '하고 떠오르지 않는 것처럼',
    " '너'가 사라진 공간",
    " '너'가 제거된 공간",
    " '너'를 제거해버린 공간",
    '_____의 내면 세계',
    '이제 곧 _____의 내면 세계로 발을 디딥니다',
    '두 번의 심호흡을 하기도 하면서,',
    '후 --',
    '하- ,',
    '후 ....',
    '하 ~',
    '이제 눈으로 감고,',
    '천천히 수면 아래로 내려갑니다.',
    "귀를 기울여 '보세요'",
    "내면의 미로를 탐험하여 사라진 '너'의 소리에",
    '말이 길었습니다.',
    '잠시 후에 만나요.',
    '수면으로',
    '내려갑니다.'
  ];

  const FIRST_SLEEP_LINES = [
    '당신은 공간을 거닐고 있다.',
    '마침내 당신은 도시의 어둠, 그리고 스산한 안개 속으로 천천히 발을 내딛었다.',
    '지금은 새벽 4시. 당신은 축축하고 푹신한 수면 위로 걷는 느낌을 느낀다.',
    '뒤꿈치부터 발바닥을 거쳐 발가락까지 차례로 내리눌러보기도 하며, 당신이 서 있는 곳이 당신을 타고 올라오게 천천히 내버려둔다.',
    '당신은 어디선가 잔잔한 종 소리를 듣는다.',
    '당신은 잠시 후, 또 다시 어디선가 들려오는 아이들의 웃음 소리를 듣는다.',
    '당신은 지금 내면의 바다를 듣고 있다.',
    '갑자기 프란츠 카프카의 <학술원에 보내는 보고서>라는 소설이 떠올랐다.',
    '소설은 아프리카 해안 어느 숲 속에서 무한한 자유를 누리며 원숭이답게 살아가는 빨간 피터라는 원숭이의 이야기를 다루고 있다.',
    '그러던 어느날 피터의 앞으로 백인들은 그를 잡아가 우리에 가둔다.',
    '난생 처음 우리에 가둔 피터는 처음으로 고민에 빠진다.',
    '탈출을 할 것인가? 혹은 그대로 있을 것인가?',
    '그러던 중 피터가 마지막으로 한 선택은 인간들처럼 되기 위한 선택을 내린다.',
    '침을 뱉고, 술을 마시고, 악수를 하고, 담배를 태우며 서서히 인간 세계의 일원이 되어가는 것이다.',
    '사람들을 흉내 내는 일은 전혀 어렵지 않았습니다.',
    '침 뱉기는 며칠만에 거뜬히 배웠죠. 파이프 담배도 곧 영감처럼 피웠어요.',
    '가장 어려웠던 것은 술병이었습니다.',
    '냄새가 지독했거든요.',
    '저는 그동안 배운 대로 코르크 마개를 빼고 술병을 입에 갖다 댔죠.',
    '그러곤 전혀 망설임 없이 표정 하나 변하지 않고 술을 들이켰어요.',
    '진짜 술꾼처럼 눈동자도 데굴데굴 굴리고, 꿀꺽꿀꺽 소리도 내면서 그야말로 남김없이 술병을 비워버린 겁니다.',
    '참을 수 없는 충동에 정신이 멍해져서 "헬로!"하고 짤막하게 외쳤습니다.',
    '인간의 소리를 내뱉은 거였죠.',
    '이 한마디의 외침으로 저는 인간세계에 뛰어들었고, 거기엔 반향이 뒤따랐습니다.',
    '"들어 봐, 저놈이 말을 해!"',
    '그 반향은 땀방울이 뚝뚝 떨어지는 제 온몸에 쏟아지는 입맞춤 같았답니다.'
  ];

  function getFrameRect(){
    return document.querySelector('.frameBox').getBoundingClientRect();
  }

  function fitTitleLine(el){
    if(!el) return;
    const fr=getFrameRect();
    const maxW=Math.min(window.innerWidth*0.96, fr.width*0.90);
    const cs=getComputedStyle(el);
    let size=parseFloat(cs.fontSize)||48;
    el.style.whiteSpace='nowrap';
    while(el.scrollWidth>maxW && size>16){
      size*=0.94;
      el.style.fontSize=size+'px';
    }
  }
  function fitTitleLineSafe(){
    fitTitleLine(introBigText);
    fitTitleLine(firstSleepText);
  }
  window.addEventListener('load', fitTitleLineSafe);

  function fitWelcomeTitles(){
    const titles = document.querySelectorAll('#welcomeCard .title');
    const card = document.getElementById('welcomeCard');
    if(!titles.length || !card) return;
    const maxW = card.clientWidth * 0.95;
    titles.forEach(el=>{
      el.style.whiteSpace='nowrap';
      let size = parseFloat(getComputedStyle(el).fontSize) || 40;
      while(el.scrollWidth>maxW && size>14){
        size *= 0.94;
        el.style.fontSize = size+'px';
      }
    });
  }
  window.addEventListener('resize', ()=>fitWelcomeTitles(), {passive:true});

  const PIXEL_SPRITE=[
    "..XXXXXX....",
    ".XXXXXXXX...",
    ".XX.XX.XX...",
    ".XXXXXXXX...",
    "..XXXXXX....",
    ".XXXXXXXX...",
    ".XXXXXXXX...",
    ".XX.XX.XX...",
    ".XXXXXXXX...",
    "..XXXXXX....",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    "..XX..XX....",
    "..XX..XX...."
  ];
  const COLOR_FILL='#e0e0e0';
  const COLOR_STROKE='#000';

  function drawPixelHuman(ctx, cx, baselineY, W, hop=0, alpha=1){
    const cell=Math.max(2, Math.min(4, Math.floor(W*0.0018)));
    const cols=PIXEL_SPRITE[0].length;
    const rows=PIXEL_SPRITE.length;
    const width=cols*cell;
    const height=rows*cell;
    const x0=Math.round(cx-width/2);
    const y0=Math.round(baselineY-height-hop);

    ctx.globalAlpha=alpha;
    ctx.fillStyle=COLOR_STROKE;
    for(let y=0;y<rows;y++){
      const row=PIXEL_SPRITE[y];
      for(let x=0;x<cols;x++){
        if(row[x]==='X'){
          ctx.fillRect(x0+x*cell-1,y0+y*cell,cell,cell);
          ctx.fillRect(x0+x*cell+1,y0+y*cell,cell,cell);
          ctx.fillRect(x0+x*cell,y0+y*cell-1,cell,cell);
          ctx.fillRect(x0+x*cell,y0+y*cell+1,cell,cell);
        }
      }
    }
    ctx.fillStyle=COLOR_FILL;
    for(let y=0;y<rows;y++){
      const row=PIXEL_SPRITE[y];
      for(let x=0;x<cols;x++){
        if(row[x]==='X'){
          ctx.fillRect(x0+x*cell,y0+y*cell,cell,cell);
        }
      }
    }
    ctx.globalAlpha=1;
  }

  function getProsceniumRect(){
    const r=getFrameRect();
    return {x:r.left,y:r.top,w:r.width,h:r.height};
  }

  function spiralPos(t01){
    const pr=getProsceniumRect();
    const baselineY=Math.round(
      pr.y+pr.h*0.60-(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--char-offset-vh'))/100)*pr.h
    );
    const R=pr.x+pr.w*0.92;
    const cx=pr.x+pr.w*0.46;
    const cy=baselineY-pr.h*0.06;
    const turns=2.2;
    const theta=turns*Math.PI*2*t01;
    const r0=pr.w*0.22;
    const r1=pr.w*0.02;
    const r=r0+(r1-r0)*t01;
    let sx=cx+r*Math.cos(theta);
    let sy=cy+r*Math.sin(theta);
    const pull=t01*t01;
    sx=sx*(1-pull)+R*pull;
    sy=sy*(1-pull)+baselineY*pull;
    return {x:sx,y:sy,baselineY};
  }

  function drawBubble(ctx, x, y, text){
    const pad=6, r=6;
    ctx.font='12px "Courier New", monospace';
    const m=ctx.measureText(text);
    const w=Math.max(28,m.width+pad*2);
    const h=18+pad*2;
    const bx=Math.round(x-w/2);
    const by=Math.round(y-h-18);
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.9)';
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(bx+r,by);
    ctx.arcTo(bx+w,by,bx+w,by+h,r);
    ctx.arcTo(bx+w,by+h,bx,by+h,r);
    ctx.arcTo(bx,by+h,bx,by,r);
    ctx.arcTo(bx,by,bx+w,by,r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x-6,by+h-1);
    ctx.lineTo(x,by+h+6);
    ctx.lineTo(x+6,by+h-1);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle='#fff';
    ctx.fillText(text,bx+pad,by+pad+12);
    ctx.restore();
  }

  let nameCityCtx = null;
  let nameBuildings = [];
  let nameCityRunning = false;
  let lastFlicker = 0;

  /* 인트로덕션용 건물 배열 (닉네임 도시 스타일 복붙) */
  let introBuildings = [];

  function generateIntroBuildings(){
    const pr = getProsceniumRect();
    introBuildings = [];

    const areaLeft  = pr.x + pr.w * 0.02;
    const areaRight = pr.x + pr.w * 0.60;
    const top = pr.y;
    const maxWidth = areaRight - areaLeft;
    let x = areaLeft;

    while(x < areaRight){
      const bw = Math.max(24, Math.random()* (maxWidth*0.08) + (maxWidth*0.03));
      const bh = Math.random() * (pr.h*0.30) + (pr.h*0.22);

      const col = `hsl(0, 0%, ${20+Math.random()*10}%)`;

      const winW = bw * 0.16;
      const winH = winW * 1.1;
      const hGap = winW * 0.4;
      const vGap = winH * 0.5;
      const cols = Math.max(1, Math.floor((bw - winW*0.4) / (winW + hGap)));
      const rows = Math.max(2, Math.floor((bh - winH*1.5) / (winH + vGap)));

      const windows = [];
      for(let iy=0; iy<rows; iy++){
        for(let ix=0; ix<cols; ix++){
          const wx = (bw - (cols*winW + (cols-1)*hGap))/2 + ix*(winW+hGap);
          const wy =  bh - winH*1.2 - iy*(winH+vGap);
          const onInit = Math.random() < 0.25;
          windows.push({
            dx: wx,
            dy: wy,
            w: winW,
            h: winH,
            value: onInit ? 1.0 : 0.0,
            target: onInit ? 1.0 : 0.0
          });
        }
      }

      introBuildings.push({
        x,
        top,
        width: bw,
        height: bh,
        color: col,
        windows
      });

      x += bw * (0.4 + Math.random()*0.4);
    }
  }

  function drawIntroBuildings(ctx){
    if(!introBuildings.length) return;
    ctx.save();
    ctx.globalAlpha = 0.98;
    introBuildings.forEach(b=>{
      const x = b.x;
      const top = b.top;
      const w = b.width;
      const h = b.height;

      ctx.fillStyle = b.color;
      ctx.fillRect(x, top, w, h);

      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(x, top-3, w, 3);

      b.windows.forEach(wv=>{
        const speed = 0.04;
        wv.value += (wv.target - wv.value)*speed;
        const v = Math.max(0, Math.min(1, wv.value));

        const off = { r:20, g:20, b:20 };
        const on  = { r:220, g:220, b:220 };
        const r = off.r + (on.r - off.r) * v;
        const g = off.g + (on.g - off.g) * v;
        const bcol = off.b + (on.b - off.b) * v;
        ctx.fillStyle = `rgba(${r|0},${g|0},${bcol|0},0.95)`;
        ctx.fillRect(x+wv.dx, top + (h - wv.dy), wv.w, wv.h);
      });
    });
    ctx.restore();
  }

  let introWalking=false;
  let introStartTime=0;
  const INTRO_WALK_DURATION=60_000;
  const bubbleSeq=[
    "HELLO","…","HI","…","HELLO!","…",
    "…헤헤","기억나?","여기 있어.","…쉿","보고 있어",
    "꿈이야?","아냐","…조금 더 가까이","같이 갈래?",
    "손… 잡을래?","…응","괜찮아","거기 있어",
    "작게 불러","내 이름"
  ];
  let introWalkers=[];

  function initIntroWalkers(){
    const now = performance.now();
    introWalkers = [];
    for(let i=0;i<5;i++){
      introWalkers.push({
        tOffset: (i*0.16)%(1),
        bubbleIndex: i % bubbleSeq.length,
        bubbleTimer: now + i*450
      });
    }
  }

  let mainTimer=null, mainLeft=4*60, timerFinished=false;
  function formatMMSS(s){
    const m=Math.floor(s/60);
    const ss=(s%60).toString().padStart(2,'0');
    return `${m.toString().padStart(2,'0')}:${ss}`;
  }
  function startMainTimer(){
    mainLeft=4*60;     /* 1장: 4분 */
    timerFinished=false;
    runTimer.textContent=formatMMSS(mainLeft);
    runTimer.style.display='block';
    if(mainTimer) clearInterval(mainTimer);
    mainTimer=setInterval(()=>{
      mainLeft=Math.max(0,mainLeft-1);
      runTimer.textContent=formatMMSS(mainLeft);
      if(mainLeft<=0){
        clearInterval(mainTimer);
        mainTimer=null;
        if(!timerFinished){
          timerFinished=true;
          onFirstSleepTimerEnd();
        }
      }
    },1000);
  }

  /* sleep-city.html로 이동하는 공통 함수 */
  function goToSleepCity(){
    try{
      stopSecondBell();
      if(secondTimer){
        clearInterval(secondTimer);
        secondTimer = null;
      }
      if(mainTimer){
        clearInterval(mainTimer);
        mainTimer = null;
      }
      if(Ambient && Ambient.isRunning && Ambient.isRunning()){
        Ambient.stop(2.5);
      }
      stopMicFXFadeOut(1.5);
      if(camStream){
        camStream.getTracks().forEach(tr=>tr.stop());
        camStream = null;
      }
      if(micStream){
        micStream.getTracks().forEach(tr=>tr.stop());
        micStream = null;
      }
    }catch(e){}
    runTimer.style.display = 'none';
    document.body.style.transition = 'opacity 1000ms ease';
    document.body.style.opacity = '0';
    setTimeout(()=>{ window.location.href = 'sleep-city.html'; }, 1000);
  }

  /* 2장: 8분 타이머 */
  let secondTimer = null;
  let secondLeft  = 0;

  function startSecondTimer(){
    secondLeft = 8*60;    // 8분
    runTimer.textContent = formatMMSS(secondLeft);
    runTimer.style.display = 'block';
    if(secondTimer) clearInterval(secondTimer);
    secondTimer = setInterval(()=>{
      secondLeft = Math.max(0, secondLeft-1);
      runTimer.textContent = formatMMSS(secondLeft);
      if(secondLeft<=0){
        clearInterval(secondTimer);
        secondTimer=null;
        stopSecondBell();
        runTimer.style.display='none';
        goToSleepCity();     // 2장 타이머 끝나면 sleep-city.html로 이동
      }
    },1000);
  }

  let micStream=null, micSrc=null, panNode=null, lpf=null, lowshelf=null, highshelf=null, revConvolver=null, dryGain=null, wetGain=null, micPreGain=null;
  function makeImpulse(ctx, seconds=6.0, decay=8.0){
    const rate=ctx.sampleRate;
    const len=rate*seconds;
    const ir=ctx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const data=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len;
        data[i]=(Math.random()*2-1)*Math.pow(1-t,decay);
      }
    }
    return ir;
  }

  async function startMicFXFadeIn(fadeSec=2.5){
    try{
      await ensureResumed();
      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({
          audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false},
          video:false
        });
      }
      if(!micSrc){
        micSrc = audioCtx.createMediaStreamSource(micStream);
      }

      micPreGain = audioCtx.createGain();
      micPreGain.gain.value = 1.8;

      lowshelf = audioCtx.createBiquadFilter();
      highshelf = audioCtx.createBiquadFilter();
      lpf = audioCtx.createBiquadFilter();
      panNode = audioCtx.createStereoPanner();

      lpf.type='lowpass';
      lpf.frequency.value=2800;
      lpf.Q.value=0.3;

      lowshelf.type='lowshelf';
      lowshelf.frequency.value=350;
      lowshelf.gain.value=0;

      highshelf.type='highshelf';
      highshelf.frequency.value=3500;
      highshelf.gain.value=0;

      revConvolver = audioCtx.createConvolver();
      revConvolver.buffer = makeImpulse(audioCtx, 6.0, 8.0);

      dryGain = audioCtx.createGain();
      wetGain = audioCtx.createGain();
      dryGain.gain.value = 0.0;
      wetGain.gain.value = 0.0;

      const out = audioCtx.createGain();
      out.gain.value = 0.92;

      micSrc.connect(micPreGain);
      micPreGain.connect(lowshelf)
               .connect(highshelf)
               .connect(lpf)
               .connect(panNode);

      panNode.connect(dryGain);
      panNode.connect(revConvolver);
      revConvolver.connect(wetGain);

      dryGain.connect(out);
      wetGain.connect(out);
      out.connect(audioCtx.destination);

      window.addEventListener('deviceorientation', onTiltAudio, {passive:true});

      const t = audioCtx.currentTime;
      dryGain.gain.linearRampToValueAtTime(0.72, t+fadeSec);
      wetGain.gain.linearRampToValueAtTime(0.58, t+fadeSec);
    }catch(e){
      console.warn('startMicFX error', e);
    }
  }

  function stopMicFXFadeOut(sec=2.5){
    try{
      if(!audioCtx) return;
      const t = audioCtx.currentTime;
      if(dryGain) dryGain.gain.linearRampToValueAtTime(0.0001, t+sec);
      if(wetGain) wetGain.gain.linearRampToValueAtTime(0.0001, t+sec);
      if(micPreGain) micPreGain.gain.linearRampToValueAtTime(0.0001, t+sec);
      setTimeout(()=>{
        try{
          if(micStream){
            micStream.getTracks().forEach(tr=>tr.stop());
          }
        }catch(e){}
        micStream=null;
        micSrc=null;
        panNode=null;
        lpf=null;
        lowshelf=null;
        highshelf=null;
        revConvolver=null;
        dryGain=null;
        wetGain=null;
        micPreGain=null;
        window.removeEventListener('deviceorientation', onTiltAudio);
      }, sec*1000+200);
    }catch(e){}
  }

  function onTiltAudio(e){
    if(!audioCtx || !panNode) return;

    const gamma = clamp(e.gamma ?? 0, -90, 90);
    panNode.pan.value = gamma / 90;

    const beta = clamp(e.beta ?? 0, -90, 90);

    if(lowshelf) {
      lowshelf.gain.value = (beta < 0) ? (beta / 90) * 10 : 0;
    }

    if(highshelf) {
      highshelf.gain.value = (beta > 0) ? (beta / 90) * 10 : 0;
    }

    if(lpf) {
      let cutoff;
      if(beta >= 0) {
        cutoff = 2800 + (beta / 90) * (4500 - 2800);
      } else {
        cutoff = 2800 + (beta / 90) * (2800 - 900);
      }
      lpf.frequency.value = clamp(cutoff, 900, 4500);
      lpf.Q.value = 0.2 + (Math.abs(beta) / 90) * 0.3;
    }

    if(wetGain && dryGain) {
      const tilt = Math.abs(beta) / 90;
      const wetBase = 0.42;
      const wetAmount = wetBase + tilt * 0.25;
      wetGain.gain.value = clamp(wetAmount, 0.35, 0.67);
      dryGain.gain.value = clamp(1.0 - wetGain.gain.value * 0.5, 0.5, 0.85);
    }
  }

  let metaReady=false;
  async function startCameraFresh(warmupOnly=false){
    try{
      if(!camPermGranted){
        await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}, audio:true})
          .then(s=>{
            s.getTracks().forEach(t=>t.stop());
            camPermGranted=true;
          });
      }
      if(!camVideo){
        camVideo=document.createElement('video');
        camVideo.setAttribute('playsinline','');
        camVideo.autoplay=true;
        camVideo.playsInline=true;
        camVideo.muted=true;
      }
      if(!camStream){
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:{ideal:'environment'},
            width:{min:1280,ideal:1920},
            height:{min:720,ideal:1080},
            aspectRatio:{ideal:16/9}
          },
          audio:false
        });
        camVideo.srcObject=camStream;
      }
      await camVideo.play().catch(()=>{});
      if (camVideo.readyState < 1){
        await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
      }
      metaReady=true;
      resizeAll();
      warmupFrames=0;

      if(!vctx){
        vctx=view.getContext('2d',{alpha:false});
      }
      if(!fgctx){
        fgctx=fg.getContext('2d',{alpha:true});
      }
      resizeAll();
      if(!animStarted && !warmupOnly){
        animStarted=true;
        loop();
      }
      document.querySelectorAll('.uiBtn').forEach(b=>{
        b.addEventListener('click', ()=>{
          ensureResumed().then(playWoongClick);
        }, {passive:true});
      });
    }catch(e){
      console.warn('startCameraFresh error:', e);
    }
  }

  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    if(vctx) vctx.setTransform(dpr,0,0,dpr,0,0);
    fg.width=w*dpr;
    fg.height=h*dpr;
    if(fgctx) fgctx.setTransform(dpr,0,0,dpr,0,0);
    if(nameCityRunning) initNameCity(true);
    if(showIntroLayer) generateIntroBuildings();
    if(mapOverlay.style.display!=='none') drawMap();
  }
  addEventListener('resize', ()=>{
    setTimeout(resizeAll,30);
    warmupFrames=30;
  }, {passive:true});

  function drawBestCover(ctx, video, W, H, PW, PH){
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(!vw||!vh) return;
    function coverScore(rot){
      let rw=rot?vh:vw, rh=rot?vw:vh;
      const s=Math.max(PW/rw, PH/rh)*ZOOM;
      const dw=rw*s, dh=rh*s;
      const letter=Math.max(0,(PW-dw))+Math.max(0,(PH-dh));
      return {rot,s,dw,dh,letter};
    }
    const a=coverScore(false), b=coverScore(true);
    let best=(b.letter<a.letter)?b:a;
    ctx.save();
    if(best.rot){
      ctx.translate(PW/2,PH/2);
      ctx.rotate(Math.PI/2);
      ctx.drawImage(video,-best.dh/2,-best.dw/2,best.dh,best.dw);
    }else{
      const dx=(PW-best.dw)/2;
      const dy=(PH-best.dh)/2;
      ctx.drawImage(video,dx,dy,best.dw,best.dh);
    }
    ctx.restore();
  }

  function loop(){
    requestAnimationFrame(loop);
    if(capturing) return;
    if(!vctx || !fgctx) return;

    const W=view.width/(devicePixelRatio||1);
    const H=view.height/(devicePixelRatio||1);
    if(warmupFrames>0){
      resizeAll();
      warmupFrames--;
    }

    vctx.clearRect(0,0,W,H);
    vctx.imageSmoothingEnabled=true;

    /* 카메라: 항상 흑백 (CSS + JS 이중 안전장치) */
    if (showCamera && camVideo && camVideo.readyState>=2){
      vctx.save();
      vctx.filter='grayscale(1)';
      drawBestCover(vctx, camVideo, W, H, W, H);
      vctx.restore();
      vctx.filter='none';
    } else {
      vctx.fillStyle='#000000';
      vctx.fillRect(0,0,W,H);
    }

    const pr=getProsceniumRect();
    fgctx.clearRect(0,0,W,H);
    if(showIntroLayer && fgAlpha>0.001){
      fgctx.save();
      fgctx.globalAlpha=fgAlpha;
      fgctx.beginPath();
      fgctx.rect(pr.x,pr.y,pr.w,pr.h);
      fgctx.clip();

      /* 인트로덕션 건물: 닉네임 도시 스타일 복붙 (흑백) */
      drawIntroBuildings(fgctx);

      if(introWalking && introWalkers.length){
        const now=performance.now();
        const tGlobal=(now-introStartTime)/INTRO_WALK_DURATION;
        introWalkers.forEach(w=>{
          const t = ((tGlobal + w.tOffset)%1+1)%1;
          const pos = spiralPos(t);
          const hop = Math.max(0,10*Math.sin(t*Math.PI*20));
          drawPixelHuman(fgctx, Math.round(pos.x), Math.round(pos.baselineY), W, hop, 1);

          if(now-w.bubbleTimer>700+Math.random()*500){
            w.bubbleIndex=(w.bubbleIndex+1)%bubbleSeq.length;
            w.bubbleTimer=now;
          }
          drawBubble(fgctx, Math.round(pos.x), Math.round(pos.baselineY)-28, bubbleSeq[w.bubbleIndex]);
        });
      }

      fgctx.restore();
    }

    if (camFadeAlpha > 0){
      vctx.save();
      vctx.fillStyle = `rgba(0,0,0,${camFadeAlpha})`;
      vctx.fillRect(0,0,W,H);
      vctx.restore();
    }
  }

  function fadeInCamera(ms=2500){
    showCamera = true;
    camFadeAlpha = 1;
    const t0 = performance.now();
    function step(){
      const k = Math.min(1, (performance.now()-t0)/ms);
      camFadeAlpha = 1-k;
      if(k<1){
        requestAnimationFrame(step);
      }else{
        camFadeAlpha = 0;
      }
    }
    step();
  }

  function fadeOutCamera(ms=2500){
    showCamera = true;
    camFadeAlpha = 0;
    const t0 = performance.now();
    function step(){
      const k = Math.min(1, (performance.now()-t0)/ms);
      camFadeAlpha = k;
      if(k<1){
        requestAnimationFrame(step);
      }else{
        camFadeAlpha = 1;
        showCamera = false;
      }
    }
    step();
  }

  let captureAnimating=false;
  captureBtn.addEventListener('click', async ()=>{
    claimImmersive();
    if(captureAnimating) return;
    await ensureResumed();
    await playWoongClick();
    captureAnimating=true;
    capturing=true;
    const cssW=view.clientWidth;
    const cssH=view.clientHeight;
    freezeLayer.width=cssW;
    freezeLayer.height=cssH;
    const displayCtx=freezeLayer.getContext('2d');
    displayCtx.imageSmoothingEnabled=false;
    freezeLayer.style.transition='';
    freezeLayer.style.opacity='0';
    freezeLayer.style.display='block';

    const snapshot=document.createElement('canvas');
    snapshot.width=cssW;
    snapshot.height=cssH;
    const snapCtx=snapshot.getContext('2d');
    snapCtx.imageSmoothingEnabled=false;
    snapCtx.drawImage(view,0,0,view.width,view.height,0,0,cssW,cssH);
    snapCtx.drawImage(fg,0,0,fg.width,fg.height,0,0,cssW,cssH);

    const off=document.createElement('canvas');
    const oc=off.getContext('2d');
    let px=2.4;
    const step=1.015;
    let revealed=false;
    function anim(){
      if(px>420){
        freezeLayer.style.transition='opacity 2000ms ease';
        freezeLayer.style.opacity='0';
        setTimeout(()=>{
          freezeLayer.style.display='none';
          freezeLayer.style.transition='';
          capturing=false;
          captureAnimating=false;
        },2020);
        return;
      }
      const w=Math.max(1,Math.floor(cssW/px));
      const h=Math.max(1,Math.floor(cssH/px));
      off.width=w;
      off.height=h;
      oc.imageSmoothingEnabled=false;
      oc.clearRect(0,0,w,h);
      oc.drawImage(snapshot,0,0,cssW,cssH,0,0,w,h);
      displayCtx.clearRect(0,0,cssW,cssH);
      displayCtx.imageSmoothingEnabled=false;
      displayCtx.globalAlpha=1.0;
      displayCtx.drawImage(off,0,0,w,h,0,0,cssW,cssH);
      if(!revealed){
        freezeLayer.style.opacity='1';
        revealed=true;
      }
      px=px*step+0.35;
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  });

  let introIndex=0;
  function resolveIntroLine(i){
    let line = INTRO_LINES[i] || '';
    return line.replace(/_____/g, displayName);
  }

  async function typeIntroLine(idx){
    introTextEl.textContent='';
    const text = resolveIntroLine(idx);
    for(let i=0;i<text.length;i++){
      introTextEl.textContent += text[i];
      typeTick();
      await sleep(24);
    }
  }

  introNextBtn.addEventListener('click', async ()=>{
    await ensureResumed();
    await playWoongClick();
    introIndex++;
    if(introIndex >= INTRO_LINES.length){
      fadeHide(introDialogue, 300);
      await sleep(350);
      await playTduung();
      startIntroToFirstSleepSequence();
    }else{
      typeIntroLine(introIndex);
    }
  }, {passive:true});

  function fadeIntroLayerOut(ms=4500){
    const t0=performance.now();
    const startAlpha=fgAlpha;
    function step(){
      const k=Math.min(1,(performance.now()-t0)/ms);
      fgAlpha=startAlpha*(1-k);
      if(k<1){
        requestAnimationFrame(step);
      }else{
        fgAlpha=0;
        showIntroLayer=false;
        introWalking=false;
        if(fgctx){
          const W=view.width/(devicePixelRatio||1);
          const H=view.height/(devicePixelRatio||1);
          fgctx.clearRect(0,0,W,H);
        }
      }
    }
    step();
  }

  async function runFirstSleepTitleSequence(){
    firstTransWord.textContent='';
    firstTransTitle.textContent='';

    firstTransition.style.display='flex';
    firstTransition.style.opacity='0';
    firstTransition.style.transition='opacity 1600ms ease';
    await nextFrame();
    firstTransition.style.opacity='1';

    const word = 'SLEEEEEEEEP';
    for(let i=0;i<word.length;i++){
      firstTransWord.textContent += word[i];
      typeTick();
      await sleep(45);
    }

    await sleep(900);
    firstTransTitle.textContent = 'THE FIRST SLEEP';

    await sleep(2600);

    firstTransition.style.transition='opacity 2000ms ease';
    firstTransition.style.opacity='0';
    await sleep(2100);
    firstTransition.style.display='none';
    firstTransition.style.transition='';
  }

  async function startIntroToFirstSleepSequence(){
    Ambient.stop(4.0);
    claimImmersive();
    await ensureResumed();

    introWalking=true;
    fadeIntroLayerOut(4500);

    await sleep(1000);
    await runFirstSleepTitleSequence();

    showNoticePopup();
  }

  function showNoticePopup(){
    function bgTrap(e){
      if(!e.target.closest('#noticeCard')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup.addEventListener(ev, bgTrap, {passive:false});
    });
    fadeShow(noticePopup, 280, 'flex');
    setTimeout(()=>{
      noticeOk && noticeOk.focus && noticeOk.focus();
    }, 50);
    noticeOk.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      await playWoongClick();
      fadeHide(noticePopup, 250);
      await sleep(260);

      fadeInCamera(2500);
      startMicFXFadeIn(2.5);

      controls.classList.add('show');
      captureBtn.classList.add('show');

      stage = 'first';
      startMainTimer();
      startFirstSleepStory();
    };
  }

  async function typeFirstSleepLine(text){
    chapterBox.innerHTML='';
    for(let i=0;i<text.length;i++){
      const ch = text[i];
      if(ch === '\n'){
        chapterBox.appendChild(document.createElement('br'));
        continue;
      }
      const span = document.createElement('span');
      span.className = 'charBox';
      span.textContent = ch;
      chapterBox.appendChild(span);
      typeTick();
      await sleep(26);
    }
  }

  async function startFirstSleepStory(){
    claimImmersive();
    await ensureResumed();
    fadeShow(chapterOverlay, 400, 'flex');
    await sleep(420);

    for(const line of FIRST_SLEEP_LINES){
      await typeFirstSleepLine(line);
      await sleep(4000);
    }

    fadeHide(chapterOverlay, 800);
  }

  async function runSecondSleepTitleSequence(){
    sleepLine1.textContent = '';
    sleepLine2.textContent = '';
    sleepSecondTitle.textContent = '';
    sleepTransition.style.display='flex';
    sleepTransition.style.opacity='0';
    sleepTransition.style.transition='opacity 1600ms ease';
    await nextFrame();
    sleepTransition.style.opacity='1';

    const line1 = 'SLEEEEEEP';
    const line2 = 'SLEEEEEEEEP';

    for(let i=0;i<line1.length;i++){
      sleepLine1.textContent += line1[i];
      typeTick();
      await sleep(45);
    }
    await sleep(350);
    for(let i=0;i<line2.length;i++){
      sleepLine2.textContent += line2[i];
      typeTick();
      await sleep(45);
    }

    await sleep(900);
    sleepSecondTitle.textContent = 'THE SECOND SLEEP';

    await sleep(2600);

    sleepTransition.style.transition='opacity 2000ms ease';
    sleepTransition.style.opacity='0';
    await sleep(2100);
    sleepTransition.style.display='none';
    sleepTransition.style.transition='';
  }

  async function onFirstSleepTimerEnd(){
    claimImmersive();
    await ensureResumed();

    controls.classList.remove('show');
    captureBtn.classList.remove('show');
    runTimer.style.display='none';

    fadeHide(chapterOverlay, 800);

    fadeOutCamera(2500);
    stopMicFXFadeOut(2.5);

    await sleep(400);
    await runSecondSleepTitleSequence();

    stage = 'secondIntro';
    showSecondNoticePopup();
  }

  function showSecondNoticePopup(){
    function bgTrap2(e){
      if(!e.target.closest('#noticeCard2')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup2.addEventListener(ev, bgTrap2, {passive:false});
    });
    fadeShow(noticePopup2, 280, 'flex');
    setTimeout(()=>{
      noticeOk2 && noticeOk2.focus && noticeOk2.focus();
    }, 50);

    noticeOk2.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      await playWoongClick();
      fadeHide(noticePopup2, 260);
      await sleep(280);
      await playBellChime();   // 진입 종
      showMapOverlay();
    };
  }

  async function showIntroFlow(){
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.2, 1.0);

    showCamera = false;
    camFadeAlpha = 0;

    introBig.style.display='flex';
    introBig.style.opacity='0';
    await nextFrame();
    fitTitleLine(introBigText);
    introBig.style.transition='opacity 1600ms ease';
    introBig.style.opacity='1';
    await sleep(2200);
    introBig.style.opacity='0';
    await sleep(1600);
    introBig.style.display='none';

    generateIntroBuildings();

    introWalking=true;
    introStartTime=performance.now();
    showIntroLayer=true;
    fgAlpha=1.0;
    initIntroWalkers();

    introIndex = 0;
    fadeShow(introDialogue, 300, 'block');
    typeIntroLine(introIndex);
  }

  document.getElementById('goIntro').addEventListener('click', ()=>{
    ensureResumed().then(async ()=>{
      claimImmersive();
      if(!Ambient.isRunning()) Ambient.start(0.2,1.0);
      await playWoongClick();
      fadeHide(welcome, FADE);
      stage = 'intro';
      showIntroFlow();
    });
  }, {passive:true});

  function initNameCity(keepRunning=false){
    if(!nameCityCanvas) return;
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;
    nameCityCanvas.width = w * dpr;
    nameCityCanvas.height = h * dpr;
    nameCityCtx = nameCityCanvas.getContext('2d');
    nameCityCtx.setTransform(dpr,0,0,dpr,0,0);

    nameBuildings = [];
    const baseGround = h * 0.82;

    const layers = [
      { depth:0, offsetY: h * 0.16, heightMul:0.45, shade:-8 },
      { depth:1, offsetY: h * 0.08, heightMul:0.65, shade:0 },
      { depth:2, offsetY: 0,       heightMul:0.85, shade:+5 }
    ];

    for(const layer of layers){
      let groundY = baseGround - layer.offsetY;
      const totalW = w;
      let x = -totalW * 0.1;
      const maxX = w + totalW * 0.1;

      while(x < maxX){
        const bw = Math.random()* (w * 0.035) + (w * 0.015);
        let bh = (Math.random()* (h * 0.3) + (h * 0.25)) * layer.heightMul;
        let bTop = groundY - bh;

        const minTop = h * 0.10;
        const maxBottom = h * 0.92;

        if(groundY > maxBottom) groundY = maxBottom;
        bTop = groundY - bh;
        if(bTop < minTop){
          bTop = minTop;
          bh = groundY - bTop;
        }

        const baseLight = 18 + layer.shade;
        const col = `hsl(0, 0%, ${baseLight+Math.random()*8}%)`;

        const winW = bw * 0.16;
        const winH = winW * 1.1;
        const hGap = winW * 0.4;
        const vGap = winH * 0.5;
        const cols = Math.max(1, Math.floor((bw - winW*0.4) / (winW + hGap)));
        const rows = Math.max(2, Math.floor((bh - winH*1.5) / (winH + vGap)));

        const windows = [];
        for(let iy=0; iy<rows; iy++){
          for(let ix=0; ix<cols; ix++){
            const wx = x + (bw - (cols*winW + (cols-1)*hGap))/2 + ix*(winW+hGap);
            const wy = groundY - winH*1.2 - iy*(winH+vGap);
            const onInit = Math.random() < 0.2;
            windows.push({
              x: wx,
              y: wy,
              w: winW,
              h: winH,
              value: onInit ? 1.0 : 0.0,
              target: onInit ? 1.0 : 0.0
            });
          }
        }

        nameBuildings.push({
          x,
          width: bw,
          top: bTop,
          bottom: groundY,
          color: col,
          depth: layer.depth,
          windows
        });

        x += bw * (0.08 + Math.random()*0.18);
      }
    }
  }

  function drawNameCity(timestamp){
    if(!nameCityCtx) return;
    const w = window.innerWidth;
    const h = window.innerHeight;

    nameCityCtx.clearRect(0,0,w,h);
    nameCityCtx.fillStyle = '#000';
    nameCityCtx.fillRect(0,0,w,h);

    const grad = nameCityCtx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#050509');
    grad.addColorStop(1, '#050505');
    nameCityCtx.fillStyle = grad;
    nameCityCtx.fillRect(0,0,w,h);

    const sorted = [...nameBuildings].sort((a,b)=>a.bottom - b.bottom);

    for(const b of sorted){
      nameCityCtx.fillStyle = b.color;
      nameCityCtx.fillRect(b.x, b.top, b.width, b.bottom - b.top);

      nameCityCtx.fillStyle = 'rgba(0,0,0,0.6)';
      nameCityCtx.fillRect(b.x, b.top - 3, b.width, 3);

      for(const wv of b.windows){
        const speed = 0.02;
        wv.value += (wv.target - wv.value) * speed;

        const v = clamp(wv.value, 0, 1);
        const off = { r:20, g:20, b:20 };
        const on  = { r:220, g:220, b:220 };
        const r = off.r + (on.r - off.r) * v;
        const g = off.g + (on.g - off.g) * v;
        const bcol = off.b + (on.b - off.b) * v;
        nameCityCtx.fillStyle = `rgba(${r|0},${g|0},${bcol|0},0.95)`;
        nameCityCtx.fillRect(wv.x, wv.y, wv.w, wv.h);
      }
    }

    if(timestamp - lastFlicker > 2800){
      lastFlicker = timestamp;
      for(const b of nameBuildings){
        for(const wv of b.windows){
          if(Math.random() < 0.08){
            wv.target = (wv.target > 0.5) ? 0.0 : 1.0;
          }
        }
      }
    }
  }

  function stepNameCity(ts){
    if(!nameCityRunning) return;
    drawNameCity(ts);
    requestAnimationFrame(stepNameCity);
  }

  function startNameCity(){
    nameCityRunning = true;
    initNameCity();
    requestAnimationFrame(stepNameCity);
  }

  function stopNameCity(){
    nameCityRunning = false;
  }

  let mapMarkers = [];

  function drawMap(){
    if(!mapOverlay || mapOverlay.style.display==='none') return;
    const rect = mapOverlay.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const dpr = window.devicePixelRatio || 1;
    mapCanvas.width = w*dpr;
    mapCanvas.height = h*dpr;
    const ctx = mapCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,w,h);

    const cx = w*0.5;
    const cy = h*0.5;

    /* 2장 지도: 직각 사각형 프레임 안에 구조 */
    const mw = w*0.7;
    const mh = h*0.6;
    const left = cx - mw/2;
    const top  = cy - mh/2;

    ctx.fillStyle = '#000';
    ctx.fillRect(left, top, mw, mh);
    ctx.strokeStyle='rgba(224,224,224,0.85)';
    ctx.lineWidth=2;
    ctx.strokeRect(left, top, mw, mh);

    const r = Math.min(mw,mh)*0.16;
    ctx.fillStyle='#555555';
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const ang = Math.PI/2 + i*Math.PI/3;
      const x = cx + r*Math.cos(ang);
      const y = cy + r*Math.sin(ang);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    mapMarkers=[];
    const rectW = r*0.9;
    const rectH = r*0.5;
    const offsets = [
      {id:1, dx:0,       dy:-r*1.7},
      {id:2, dx:r*1.45,  dy:-r*1.05},
      {id:3, dx:r*1.9,   dy:0},
      {id:4, dx:r*1.45,  dy:r*1.05},
      {id:5, dx:0,       dy:r*1.7},
      {id:6, dx:-r*1.45, dy:r*1.05},
      {id:7, dx:-r*1.9,  dy:0},
      {id:8, dx:-r*1.45, dy:-r*1.05}
    ];

    ctx.font='14px "Press Start 2P","Courier New",monospace';
    ctx.textAlign='center';
    ctx.textBaseline='middle';

    offsets.forEach(o=>{
      const cxRect = cx + o.dx;
      const cyRect = cy + o.dy;
      const x = cxRect - rectW/2;
      const y = cyRect - rectH/2;

      mapMarkers.push({id:o.id, x, y, w:rectW, h:rectH});

      ctx.fillStyle='rgba(0,0,0,0.85)';
      ctx.fillRect(x,y,rectW,rectH);
      ctx.strokeStyle='rgba(224,224,224,0.9)';
      ctx.strokeRect(x,y,rectW,rectH);
      ctx.fillStyle='rgba(224,224,224,0.96)';
      ctx.fillText(String(o.id), x+rectW/2, y+rectH/2+1);
    });
  }

  function showMapOverlay(){
    fadeShow(mapOverlay, 600, 'flex');
    setTimeout(drawMap, 80);
    stage = 'second';
    startSecondTimer();   // 2장: 8분 타이머 시작
    startSecondBell();    // 2장: 짤랑 짤랑 종소리 루프 시작
    runTimer.style.display='block';
  }

  function openMarkerPopup(id){
    mapPopBody.textContent = `ZONE ${id}`;
    mapPop.style.display='flex';
  }

  mapPopClose.addEventListener('click', (e)=>{
    e.stopPropagation();
    mapPop.style.display='none';
  }, {passive:true});

  mapCanvas.addEventListener('pointerdown', (e)=>{
    const rect = mapCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    for(const m of mapMarkers){
      if(x>=m.x && x<=m.x+m.w && y>=m.y && y<=m.y+m.h){
        openMarkerPopup(m.id);
        break;
      }
    }
  });

  function setAppH2(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH2();
  addEventListener('resize', setAppH2, {passive:true});
  if (window.visualViewport){
    visualViewport.addEventListener('resize', ()=>setTimeout(setAppH2,50));
  }

  /* SKIP 버튼 – 현재 챕터에 맞춰 건너뛰기 */
  skipBtn.addEventListener('click', async ()=>{
    await ensureResumed();
    await playWoongClick();

    if(stage === 'intro'){
      fadeHide(introDialogue, 300);
      introWalking=false;
      showIntroLayer=false;
      await sleep(350);
      await playTduung();
      startIntroToFirstSleepSequence();
    }else if(stage === 'first'){
      if(mainTimer){
        clearInterval(mainTimer);
        mainTimer=null;
      }
      timerFinished = true;
      await onFirstSleepTimerEnd();
    }else if(stage === 'second'){
      stopSecondBell();
      if(secondTimer){
        clearInterval(secondTimer);
        secondTimer=null;
      }
      runTimer.style.display='none';
      goToSleepCity();      // 2장 진행 중 SKIP → sleep-city.html
    }else{
      // 그 외 상태에서는 2장 시퀀스로 강제 진입
      if(mainTimer){
        clearInterval(mainTimer);
        mainTimer=null;
      }
      timerFinished = true;
      await onFirstSleepTimerEnd();
    }
  }, {passive:true});

  startCameraFresh(true);
  if(!animStarted){
    animStarted=true;
    loop();
  }
})();
</script>
</body>
</html>
