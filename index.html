<script>
(() => {
  (function injectManifest(){
    const manifest = {
      "name":"SLEEEEEP",
      "short_name":"SLEEEEEP",
      "display":"fullscreen",
      "start_url":"./",
      "background_color":"#000",
      "theme_color":"#000",
      "icons":[]
    };
    const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:"application/manifest+json"}));
    const link = document.createElement('link');
    link.rel='manifest';
    link.href=url;
    document.head.appendChild(link);
  })();

  async function enterFullscreen(){
    try{
      const el = document.documentElement;
      if (!document.fullscreenElement) {
        if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      }
    }catch(e){}
    try{
      if (screen.orientation && screen.orientation.lock) {
        await screen.orientation.lock('landscape').catch(()=>{});
      }
    }catch(e){}
  }
  let wakeLock = null;
  async function keepAwake(){
    try{
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', ()=>{});
      }
    }catch(e){}
  }
  function claimImmersive(){ enterFullscreen(); keepAwake(); }
  document.addEventListener('visibilitychange', async ()=>{
    if (document.visibilityState === 'visible' && wakeLock) {
      try{ wakeLock = await navigator.wakeLock.request('screen'); }catch(e){}
    }
  });

  const FADE = 1800;
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const nextFrame = () => new Promise(resolve=>requestAnimationFrame(()=>resolve()));
  const qs = s => document.querySelector(s);

  /* ====== 오디오 / TTS 공통 ====== */
  let audioCtx = null;
  let audioPrimed = false;

  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  async function primeAudio(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
    audioPrimed = true;
  }

  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }

  /* === TTS 설정 === */
  let ttsReady   = 'speechSynthesis' in window;
  let ttsVoice   = null;
  let ttsEnabled = false;

  function selectKoreanVoice(voices){
    // 갤럭시 / 삼성인터넷에서 ko-KR 우선 찾기
    let v = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('ko'));
    if(!v) v = voices.find(v => /korean/i.test(v.name||'')) || voices[0];
    return v || null;
  }

  function initTts(){
    if(!ttsReady) return;
    const voices = window.speechSynthesis.getVoices() || [];
    if(!voices.length){
      // 안드로이드에서 늦게 뜰 수 있음
      setTimeout(initTts, 400);
      return;
    }
    ttsVoice = selectKoreanVoice(voices);
    ttsEnabled = !!ttsVoice;
  }

  if(ttsReady){
    initTts();
    window.speechSynthesis.onvoiceschanged = initTts;
  }

  function speakText(text){
    if(!ttsReady || !text) return;
    try{
      // 우선 이전 발화 정리
      window.speechSynthesis.cancel();

      const u = new SpeechSynthesisUtterance(text);
      if(ttsVoice) u.voice = ttsVoice;
      u.lang  = (ttsVoice && ttsVoice.lang) ? ttsVoice.lang : 'ko-KR';
      u.pitch = 1.0;
      u.rate  = 0.9;
      u.volume= 1.0;

      window.speechSynthesis.speak(u);
    }catch(e){
      // 브라우저가 speechSynthesis를 막으면 조용히 실패
    }
  }

  const MASTER_BGM_GAIN = 0.4;
  const MASTER_SFX_GAIN = 0.45;

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  function fadeShow(el, dur=FADE, display='flex'){
    el.style.display=display;
    el.style.opacity='0';
    el.style.transition=`opacity ${dur}ms ease`;
    requestAnimationFrame(()=> el.style.opacity='1');
  }
  function fadeHide(el, dur=FADE){
    el.style.transition=`opacity ${dur}ms ease`;
    el.style.opacity='0';
    setTimeout(()=>{ el.style.display='none'; }, dur);
  }

  function setAppH(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH();
  addEventListener('resize', setAppH, {passive:true});
  if (window.visualViewport){
    visualViewport.addEventListener('resize', ()=>setTimeout(setAppH,50));
  }

  const rotateOverlay = qs('#rotateOverlay');
  function isPortrait(){
    const vv=window.visualViewport;
    const w=vv?vv.width:innerWidth, h=vv?vv.height:innerHeight;
    return h>w;
  }
  function updateRotateOverlay(){
    rotateOverlay.style.display = isPortrait() ? 'flex' : 'none';
  }
  ['load','pageshow','resize','orientationchange','visibilitychange'].forEach(ev=>{
    addEventListener(ev, updateRotateOverlay, {passive:true});
  });
  updateRotateOverlay();

  const overlay = qs('#overlay');
  const permBtn = qs('#permGateBtn');
  const nameOverlay = qs('#nameOverlay');
  const nickInput = qs('#nick');
  const nameSubmit = qs('#nameSubmit');
  const preset = qs('#preset');
  const presetCanvas = qs('#presetCanvas');
  const welcome = qs('#overlayWelcome');

  const introBig = qs('#introBig');
  const introBigText = qs('#introBigText');

  const introDialogue = qs('#introDialogue');
  const introTextEl = qs('#introText');
  const introNextBtn = qs('#introNext');

  const firstSleep = qs('#firstSleep');
  const firstSleepText = qs('#firstSleepText');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');
  const view = qs('#view');
  const fg = qs('#fg');
  const freezeLayer = qs('#freezeLayer');
  const runTimer = qs('#runTimer');

  const noticePopup = qs('#noticePopup');
  const noticeOk = qs('#noticeOk');

  const chapterOverlay = qs('#chapterOverlay');
  const chapterBox = qs('#chapterBox');

  const firstTransition = qs('#firstTransition');
  const firstTransWord = qs('#firstTransWord');
  const firstTransTitle = qs('#firstTransTitle');

  const sleepTransition = qs('#sleepTransition');
  const sleepLine1 = qs('#sleepLine1');
  const sleepLine2 = qs('#sleepLine2');
  const sleepSecondTitle = qs('#sleepSecondTitle');

  const thirdTransition = qs('#thirdTransition');
  const thirdSleepLine1 = qs('#thirdSleepLine1');
  const thirdSleepLine2 = qs('#thirdSleepLine2');
  const thirdSleepLine3 = qs('#thirdSleepLine3');
  const thirdTitle = qs('#thirdTitle');

  const fourthTransition = qs('#fourthTransition');
  const fourthSleepLine1 = qs('#fourthSleepLine1');
  const fourthSleepLine2 = qs('#fourthSleepLine2');
  const fourthSleepLine3 = qs('#fourthSleepLine3');
  const fourthSleepLine4 = qs('#fourthSleepLine4');
  const fourthTitle = qs('#fourthTitle');

  const noticePopup2 = qs('#noticePopup2');
  const noticeOk2 = qs('#noticeOk2');

  const noticePopup3 = qs('#noticePopup3');
  const noticeOk3 = qs('#noticeOk3');

  const mapOverlay = qs('#mapOverlay');
  const mapCanvas = qs('#mapCanvas');
  const mapPop = qs('#mapPop');
  const mapPopBody = qs('#mapPopBody');
  const mapPopClose = qs('#mapPopClose');

  const skipBtn = qs('#skipBtn');

  const endOverlay = qs('#endOverlay');
  const endSilence = qs('#endSilence');
  const endTheEnd  = qs('#endTheEnd');
  const endReturn  = qs('#endReturn');

  let vctx=null, fgctx=null;

  let camPermGranted=false;
  let camStream=null, camVideo=null, ZOOM=1.0;
  let animStarted=false, capturing=false, warmupFrames=0;

  let showIntroLayer=false;
  let fgAlpha=1.0;
  let showCamera=false;
  let camFadeAlpha=0;

  /* --------- 입력/타이핑 공용 사운드 (버벅임 줄인 버전) --------- */
  let typeBuffer = null;
  let lastTypeSoundTime = 0;

  function buildTypeBuffer(ctx){
    const duration   = 0.05; // 더 짧게
    const sampleRate = ctx.sampleRate;
    const length     = Math.floor(sampleRate * duration);
    const buffer     = ctx.createBuffer(1, length, sampleRate);
    const data       = buffer.getChannelData(0);
    const freq       = 1500;

    for(let i=0;i<length;i++){
      const t   = i / sampleRate;
      const env = Math.exp(-t * 14);
      const phase = 2 * Math.PI * freq * t;
      data[i] = Math.sin(phase) * env;
    }
    return buffer;
  }

  function playGameInputSound(){
    try{
      ensureAudio();
      const ctx = audioCtx;
      const now = ctx.currentTime || 0;

      // 더 천천히 (약 15fps 수준)
      if(now - lastTypeSoundTime < 0.06) return;
      lastTypeSoundTime = now;

      if(!typeBuffer) typeBuffer = buildTypeBuffer(ctx);

      const src = ctx.createBufferSource();
      src.buffer = typeBuffer;
      const g = ctx.createGain();
      g.gain.value = MASTER_SFX_GAIN;

      src.connect(g).connect(ctx.destination);
      src.start();
    }catch(e){}
  }

  function typeTick(){
    playGameInputSound();
  }

  function updateZoomLabel(){
    zoomVal.textContent = ZOOM.toFixed(1)+'×';
  }
  updateZoomLabel();
  zoomIn.addEventListener('click', ()=>{
    ZOOM=Math.min(3.0, ZOOM+0.05);
    updateZoomLabel();
    playWoongClick(); // await 제거해서 UI 딜레이 줄임
  }, {passive:true});
  zoomOut.addEventListener('click', ()=>{
    ZOOM=1.0;
    updateZoomLabel();
    playWoongClick();
  }, {passive:true});

  async function immediateGestureStart(e){
    e && e.preventDefault && e.preventDefault();

    claimImmersive();
    await primeAudio();       // 첫 제스처에서 오디오/tts 한 번에 깨우기
    initTts();                // 가능한 빨리 voice 로딩

    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().catch(()=>{});
      }
    }catch(_){}

    navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:'environment'},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false}
    })
    .then((s)=>{
      s.getTracks().forEach(t=>t.stop());
      camPermGranted = true;
    })
    .catch(err=>{
      console.warn('permission error:', err);
    })
    .finally(()=>{
      fadeHide(overlay, FADE);

      // 프리셋 + 이름 바로
      showPreset();
      fadeShow(nameOverlay, FADE);
      stage = 'name';
      setTimeout(()=>nickInput && nickInput.focus && nickInput.focus(), 60);
    });
  }

  ['click','touchstart','pointerdown'].forEach(type=>{
    permBtn.addEventListener(type, immediateGestureStart, {passive:false});
    overlay.addEventListener(type, immediateGestureStart, {passive:false});
    window.addEventListener(type, (ev)=>{
      if(getComputedStyle(overlay).display !== 'none'){
        immediateGestureStart(ev);
      }
    }, {passive:false});
  });

  let displayName = '_____';
  async function acceptName(){
    claimImmersive();
    await ensureResumed();
    const v = (nickInput.value||'').trim();
    if(v.length>0){ displayName = v; }
    playWoongClick();
    fadeHide(nameOverlay, FADE);
    stage = 'preset';
    skipBtn.style.display='block';
  }
  nameSubmit.addEventListener('click', acceptName, {passive:true});
  nickInput.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){ acceptName(); }
  });

  /* ===== 프리셋 세이버 ===== */
  let saverObjs = [];
  let saverT0 = 0;
  let lastSaverTime = null;

  function showPreset(){
    if(preset.style.display!=='block'){
      preset.style.display='block';
      preset.classList.add('show');
      fadeShow(preset, FADE);
      initSaver();
      startCameraFresh(true);
    }
  }

  function initSaver(){
    const w = preset.clientWidth;
    const h = preset.clientHeight;
    saverObjs = [];
    const letters = ['S','L','E','E','E','E','E','E','E','E','P'];

    for(let i=0;i<20;i++){
      saverObjs.push({
        ch: letters[i % letters.length],
        x: Math.random() * w,
        y: Math.random() * h,
        vx: (Math.random()*0.2 + 0.08) * (Math.random() < 0.5 ? -1 : 1),
        vy: (Math.random()*0.2 + 0.08) * (Math.random() < 0.5 ? -1 : 1),
        phase: Math.random() * Math.PI * 2,
        size: (Math.floor(Math.random()*60)+90)*2
      });
    }
    saverT0 = performance.now();
    lastSaverTime = null;
    requestAnimationFrame(saverLoop);
  }

  function saverLoop(){
    if(preset.style.display==='none') {
      lastSaverTime = null;
      return;
    }
    const now = performance.now();
    const w = preset.clientWidth;
    const h = preset.clientHeight;
    const dpr = devicePixelRatio || 1;

    if(lastSaverTime == null) lastSaverTime = now;
    const dt = (now - lastSaverTime) / 1000;
    lastSaverTime = now;

    presetCanvas.width = w * dpr;
    presetCanvas.height = h * dpr;
    const ctx = presetCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,w,h);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for(const o of saverObjs){
      o.x += o.vx * dt * 60;
      o.y += o.vy * dt * 60;

      if(o.x < 0 || o.x > w){
        o.vx *= -1;
        o.x = Math.max(0, Math.min(w, o.x));
      }
      if(o.y < 0 || o.y > h){
        o.vy *= -1;
        o.y = Math.max(0, Math.min(h, o.y));
      }

      o.phase += dt * 0.6;
      const wob = Math.sin(o.phase)*0.08 + 1;

      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.scale(wob, 1 / wob);
      ctx.font = `900 ${o.size}px "Press Start 2P", system-ui, sans-serif`;
      ctx.fillStyle = '#d0d0d0';
      ctx.fillText(o.ch, 0, 0);
      ctx.restore();
    }

    requestAnimationFrame(saverLoop);
  }

  preset.addEventListener('click', ()=>{
    claimImmersive();
    ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.5,1.0);
    playWoongClick();
    fadeHide(preset, FADE);
    startCameraFresh(false);
    fadeShow(welcome, FADE);
    fitWelcomeTitles();
    stage = 'welcome';
  }, {passive:true});

  const INTRO_LINES = [
    '멘트를 입력하세요',
    '멘트를 입력하세요',
    '멘트를 입력하세요'
  ];

  const FIRST_SLEEP_LINES = [
    '멘트를 입력하세요',
    '멘트를 입력하세요',
    '멘트를 입력하세요'
  ];

  function getFrameRect(){
    return document.querySelector('.frameBox').getBoundingClientRect();
  }

  function fitTitleLine(el){
    if(!el) return;
    const fr=getFrameRect();
    const maxW=Math.min(window.innerWidth*0.96, fr.width*0.96);
    const cs=getComputedStyle(el);
    let size=parseFloat(cs.fontSize)||48;
    el.style.whiteSpace='nowrap';
    while(el.scrollWidth>maxW && size>16){
      size*=0.94;
      el.style.fontSize=size+'px';
    }
  }
  function fitTitleLineSafe(){
    fitTitleLine(introBigText);
    fitTitleLine(firstSleepText);
    fitTitleLine(thirdTitle);
    fitTitleLine(fourthTitle);
  }
  window.addEventListener('load', fitTitleLineSafe);

  function fitWelcomeTitles(){
    const titles = document.querySelectorAll('#welcomeCard .title');
    const card = document.getElementById('welcomeCard');
    if(!titles.length || !card) return;
    const maxW = card.clientWidth * 0.95;
    titles.forEach(el=>{
      el.style.whiteSpace='nowrap';
      let size = parseFloat(getComputedStyle(el).fontSize) || 40;
      while(el.scrollWidth>maxW && size>14){
        size *= 0.94;
        el.style.fontSize = size+'px';
      }
    });
  }
  window.addEventListener('resize', ()=>fitWelcomeTitles(), {passive:true});

  const PIXEL_SPRITE=[
    "..XXXXXX....",
    ".XXXXXXXX...",
    ".XX.XX.XX...",
    ".XXXXXXXX...",
    "..XXXXXX....",
    ".XXXXXXXX...",
    ".XXXXXXXX...",
    ".XXXXXXXX...",
    ".XXXXXXXX...",
    ".XXXXXXXX...",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX...",
    ".XX....XX..."
  ];
  const COLOR_FILL='#d0d0d0';
  const COLOR_STROKE='#000';

  function drawPixelHuman(ctx, cx, baselineY, W, hop=0, alpha=1, angleRad=0){
    const cell=Math.max(2, Math.min(4, Math.floor(W*0.0018)));
    const cols=PIXEL_SPRITE[0].length;
    const rows=PIXEL_SPRITE.length;
    const width=cols*cell;
    const height=rows*cell;

    const x0 = -width/2;
    const y0 = -height - hop;

    ctx.save();
    ctx.translate(cx,baselineY);
    ctx.rotate(angleRad);
    ctx.globalAlpha=alpha;

    ctx.fillStyle=COLOR_STROKE;
    for(let y=0;y<rows;y++){
      const row=PIXEL_SPRITE[y];
      for(let x=0;x<cols;x++){
        if(row[x]==='X'){
          ctx.fillRect(x0+x*cell-1,y0+y*cell,cell,cell);
          ctx.fillRect(x0+x*cell+1,y0+y*cell,cell,cell);
          ctx.fillRect(x0+x*cell,y0+y*cell-1,cell,cell);
          ctx.fillRect(x0+x*cell,y0+y*cell+1,cell,cell);
        }
      }
    }
    ctx.fillStyle=COLOR_FILL;
    for(let y=0;y<rows;y++){
      const row=PIXEL_SPRITE[y];
      for(let x=0;x<cols;x++){
        if(row[x]==='X'){
          ctx.fillRect(x0+x*cell,y0+y*cell,cell,cell);
        }
      }
    }
    ctx.globalAlpha=1;
    ctx.restore();
  }

  function getProsceniumRect(){
    const r=getFrameRect();
    return {x:r.left,y:r.top,w:r.width,h:r.height};
  }

  function prosceniumWalkPos(t01){
    const pr = getProsceniumRect();
    const margin = Math.min(pr.w, pr.h) * 0.06;
    const left   = pr.x + margin;
    const right  = pr.x + pr.w - margin;
    const top    = pr.y + margin;
    const bottom = pr.y + pr.h - margin;
    const per = (right-left)*2 + (bottom-top)*2;
    let d = ((t01%1)+1)%1 * per;

    let x,y,edge;
    if(d <= (right-left)){
      x = left + d;
      y = bottom;
      edge = 'bottom';
    }else if(d <= (right-left)+(bottom-top)){
      d -= (right-left);
      x = right;
      y = bottom - d;
      edge = 'right';
    }else if(d <= (right-left)*2 + (bottom-top)){
      d -= (right-left + (bottom-top));
      x = right - d;
      y = top;
      edge = 'top';
    }else{
      d -= (right-left)*2 + (bottom-top);
      x = left;
      y = top + d;
      edge = 'left';
    }
    return { x, y, baselineY:y, edge };
  }

  function drawBubble(ctx, x, y, text){
    const pad=6, r=6;
    ctx.font='12px "Courier New", monospace';
    const m=ctx.measureText(text);
    const w=Math.max(28,m.width+pad*2);
    const h=18+pad*2;
    const bx=Math.round(x-w/2);
    const by=Math.round(y-h-18);
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.9)';
    ctx.strokeStyle='rgba(208,208,208,0.35)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(bx+r,by);
    ctx.arcTo(bx+w,by,bx+w,by+h,r);
    ctx.arcTo(bx+w,by+h,bx,by+h,r);
    ctx.arcTo(bx,by+h,bx,by,r);
    ctx.arcTo(bx,by,bx+w,by,r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x-6,by+h-1);
    ctx.lineTo(x,by+h+6);
    ctx.lineTo(x+6,by+h-1);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle='#d0d0d0';
    ctx.fillText(text,bx+pad,by+pad+12);
    ctx.restore();
  }

  let introWalking=false;
  let introStartTime=0;
  const INTRO_WALK_DURATION=60_000;
  const bubbleSeq=[
    "HELLO","…","HI","…","HELLO!","…",
    "…헤헤","기억나?","여기 있어.","…쉿","보고 있어",
    "꿈이야?","아냐","…조금 더 가까이","같이 갈래?",
    "손… 잡을래?","…응","괜찮아","거기 있어",
    "작게 불러","내 이름"
  ];
  let introWalkers=[];

  function initIntroWalkers(){
    const now = performance.now();
    introWalkers = [];
    introWalkers.push({
      tOffset: 0,
      bubbleIndex: 0,
      bubbleTimer: now + 500
    });
  }

  /* ============= 타이머/사운드들 ============= */

  /* BGM */
  const Ambient = (() => {
    let ctx, master, delay, fb, hp, lp, mix, busGain, running=false, killers=[];
    function midi(n){ return 440 * Math.pow(2, (n-69)/12); }
    function setup(){
      ensureAudio();
      ctx = audioCtx;
      master = ctx.createGain();
      master.gain.value = 0.0001;
      delay = ctx.createDelay(2.5);
      delay.delayTime.value = 0.45;
      fb = ctx.createGain();
      fb.gain.value = 0.32;
      delay.connect(fb).connect(delay);
      hp = ctx.createBiquadFilter();
      hp.type='highpass';
      hp.frequency.value=150;
      lp = ctx.createBiquadFilter();
      lp.type='lowpass';
      lp.frequency.value=4200;
      mix = ctx.createGain();
      mix.gain.value = 0.7;
      mix.connect(hp).connect(lp).connect(master);
      busGain = ctx.createGain();
      busGain.gain.value = 0.6;
      busGain.connect(master);
      master.connect(ctx.destination);
    }
    function connectDW(node){
      node.connect(busGain);
      node.connect(delay);
      delay.connect(mix);
    }
    function airy(){
      const b=ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
      const d=b.getChannelData(0);
      for(let i=0;i<d.length;i++){
        d[i]=(Math.random()*2-1)*0.06;
      }
      const s=ctx.createBufferSource();
      s.buffer=b; s.loop=true;
      const g=ctx.createGain();
      g.gain.value=0.015;
      const f=ctx.createBiquadFilter();
      f.type='bandpass';
      f.frequency.value=1100;
      f.Q.value=0.9;
      s.connect(f).connect(g);
      connectDW(g);
      s.start();
      killers.push(()=>{ try{s.stop();}catch{} });
    }
    function pad(root){
      const out = ctx.createGain();
      out.gain.value=0.24;
      const filt=ctx.createBiquadFilter();
      filt.type='lowpass';
      filt.frequency.value=1200;
      filt.Q.value=0.7;
      const lfo=ctx.createOscillator();
      const lfoG=ctx.createGain();
      lfo.type='sine';
      lfo.frequency.value=0.04;
      lfoG.gain.value=260;
      lfo.connect(lfoG).connect(filt.frequency);
      lfo.start();
      [0,7,12].forEach((i,k)=>{
        const o=ctx.createOscillator();
        o.type='triangle';
        o.frequency.value=midi(root+i);
        o.detune.value=(k-1)*4;
        const g=ctx.createGain();
        g.gain.value=0.05;
        o.connect(g).connect(filt);
        o.start();
        killers.push(()=>{ try{g.disconnect();}catch{} });
      });
      filt.connect(out);
      connectDW(out);
      killers.push(()=>{ try{ out.disconnect(); }catch{} });
    }
    function plucked(root){
      const now = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();
      const steps = [0,7,12,14];
      const pick = steps[Math.floor(Math.random()*steps.length)];
      o.type='sine';
      o.frequency.value = midi(root+pick);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN*0.6, now+0.04);
      g.gain.exponentialRampToValueAtTime(0.0001, now+1.9);
      f.type='bandpass';
      f.frequency.value = o.frequency.value*2;
      f.Q.value=4;
      o.connect(f).connect(g);
      connectDW(g);
      o.start(now);
      o.stop(now+2.1);
      killers.push(()=>{ try{g.disconnect();}catch{} });
    }
    async function start(fadeIn=1.0, target=1.0){
      await ensureResumed();
      if(running) return;
      setup();
      running=true;
      airy();
      const seq=[57,52,48,43];
      let i=0;
      (function tick(){
        if(!running) return;
        const root = seq[i%seq.length];
        pad(root);
        if(Math.random()<0.7) plucked(root);
        i++;
        setTimeout(tick,9000);
      })();
      const t=ctx.currentTime;
      const targetGain = MASTER_BGM_GAIN * target;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(0.0001, t);
      master.gain.linearRampToValueAtTime(targetGain, t+fadeIn);
    }
    function stop(fade=2.0){
      if(!running||!master) return;
      const t=ctx.currentTime;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.linearRampToValueAtTime(0.0001, t+fade);
      setTimeout(()=>{
        killers.forEach(fn=>{try{fn();}catch{}});
        killers=[];
        running=false;
      }, fade*1000+200);
    }
    function isRunning(){ return running; }
    return { start, stop, isRunning };
  })();

  async function playWoongClick(){
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(110, now+0.24);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.35);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now+0.4);
    }catch(e){}
  }
  async function playTduung(){
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o1.type='sine'; o2.type='sine';
      o1.frequency.value=90; o2.frequency.value=45;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN*1.1, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
      o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
      o1.start(); o2.start();
      o1.stop(now+0.62); o2.stop(now+0.62);
    }catch(e){}
  }
  async function playBellChime(){
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc1.type='sine'; osc2.type='sine';
      osc1.frequency.setValueAtTime(1200, now);
      osc2.frequency.setValueAtTime(1800, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+1.4);
      osc1.connect(g); osc2.connect(g); g.connect(audioCtx.destination);
      osc1.start(now); osc2.start(now);
      osc1.stop(now+1.5); osc2.stop(now+1.5);
    }catch(e){}
  }

  async function playDreamWoong(){
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.setValueAtTime(90, now);
      o.frequency.exponentialRampToValueAtTime(55, now+2.0);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.15);
      g.gain.exponentialRampToValueAtTime(0.0001, now+2.0);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now+2.05);
    }catch(e){}
  }

  let secondBellInterval = null;
  let secondBellRunning = false;

  async function playSoftBellChime(){
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g  = audioCtx.createGain();
      o1.type='sine';
      o2.type='sine';
      o1.frequency.setValueAtTime(880, now);
      o2.frequency.setValueAtTime(1320, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN*0.8, now+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, now+2.4);
      o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
      o1.start(now); o2.start(now);
      o1.stop(now+2.5); o2.stop(now+2.5);
    }catch(e){}
  }

  function startSecondBell(){
    if(secondBellRunning) return;
    secondBellRunning = true;
    playSoftBellChime();
    secondBellInterval = setInterval(()=>{ playSoftBellChime(); }, 12000);
  }

  function stopSecondBell(){
    if(secondBellInterval) clearInterval(secondBellInterval);
    secondBellInterval = null;
    secondBellRunning = false;
  }

  /* ====== 타이머들 ====== */
  let mainTimer=null, mainLeft=5*60, timerFinished=false;
  function formatMMSS(s){
    const m=Math.floor(s/60);
    const ss=(s%60).toString().padStart(2,'0');
    return `${m.toString().padStart(2,'0')}:${ss}`;
  }
  function startMainTimer(){
    mainLeft=5*60;
    timerFinished=false;
    runTimer.textContent=formatMMSS(mainLeft);
    runTimer.style.display='block';
    if(mainTimer) clearInterval(mainTimer);
    mainTimer=setInterval(()=>{
      mainLeft=Math.max(0,mainLeft-1);
      runTimer.textContent=formatMMSS(mainLeft);
      if(mainLeft<=0){
        clearInterval(mainTimer);
        mainTimer=null;
        if(!timerFinished){
          timerFinished=true;
          onFirstSleepTimerEnd();
        }
      }
    },1000);
  }

  let secondTimer = null;
  let secondLeft  = 0;

  function startSecondTimer(){
    secondLeft = 5*60;
    runTimer.textContent = formatMMSS(secondLeft);
    runTimer.style.display = 'block';
    if(secondTimer) clearInterval(secondTimer);
    secondTimer = setInterval(()=>{
      secondLeft = Math.max(0, secondLeft-1);
      runTimer.textContent = formatMMSS(secondLeft);
      if(secondLeft<=0){
        clearInterval(secondTimer);
        secondTimer=null;
        stopSecondBell();
        runTimer.style.display='none';
        endSecondStageAndStartThird();
      }
    },1000);
  }

  let finalTimer = null;
  let finalLeft  = 0;

  let fourthTimer = null;
  let fourthLeft  = 0;

  let silenceTimer = null;
  let silenceLeft  = 0;

  let endTimer = null;
  let endLeft  = 0;

  async function typeSleepLine(el, text){
    el.textContent = '';
    for(let i=0;i<text.length;i++){
      el.textContent += text[i];
      typeTick();
      await sleep(50);
    }
    fitTitleLine(el);
  }

  async function startTheEndChapter(){
    stage = 'theEnd';
    endTheEnd.textContent = '';
    if(endReturn) endReturn.textContent = '';
    await typeSleepLine(endTheEnd, 'THE END');
    speakText('디 엔드');

    endLeft = 5*60;
    runTimer.textContent = formatMMSS(endLeft);
    runTimer.style.display = 'block';
    if(endTimer) clearInterval(endTimer);
    endTimer = setInterval(()=>{
      endLeft = Math.max(0, endLeft-1);
      runTimer.textContent = formatMMSS(endLeft);
      if(endLeft<=0){
        clearInterval(endTimer);
        endTimer=null;
        runTimer.style.display='none';
        if(endReturn){
          endReturn.textContent = '※ 프로그램이 종료되었습니다. 태블릿과 헤드폰을 반납해 주세요.';
        }
      }
    },1000);
  }

  async function showEndingSequence(){
    claimImmersive();
    await ensureResumed();

    if (Ambient && Ambient.isRunning && Ambient.isRunning()){
      Ambient.stop(3.0);
    }
    stopMicFXFadeOut(2.5);
    fadeOutCamera(2000);

    endSilence.textContent = '';
    endTheEnd.textContent  = '';
    if(endReturn) endReturn.textContent = '';

    fadeShow(endOverlay, 2000, 'flex');
    await sleep(2200);

    stage = 'silence';
    await typeSleepLine(endSilence, 'SILENCE');
    playDreamWoong();
    speakText('사일런스');

    silenceLeft = 5*60;
    runTimer.textContent = formatMMSS(silenceLeft);
    runTimer.style.display = 'block';
    if(silenceTimer) clearInterval(silenceTimer);
    silenceTimer = setInterval(()=>{
      silenceLeft = Math.max(0, silenceLeft-1);
      runTimer.textContent = formatMMSS(silenceLeft);
      if(silenceLeft<=0){
        clearInterval(silenceTimer);
        silenceTimer=null;
        runTimer.style.display='none';
        startTheEndChapter();
      }
    },1000);
  }

  function startFourthTimer(){
    stage = 'fourth';
    fourthLeft = 5*60;
    runTimer.textContent = formatMMSS(fourthLeft);
    runTimer.style.display = 'block';
    if(fourthTimer) clearInterval(fourthTimer);
    fourthTimer = setInterval(()=>{
      fourthLeft = Math.max(0, fourthLeft-1);
      runTimer.textContent = formatMMSS(fourthLeft);
      if(fourthLeft<=0){
        clearInterval(fourthTimer);
        fourthTimer=null;
        runTimer.style.display='none';
        showEndingSequence();
      }
    },1000);
  }

  async function startFourthSleepSequence(){
    claimImmersive();
    await ensureResumed();

    stage = 'fourthIntro';

    fourthSleepLine1.textContent='';
    fourthSleepLine2.textContent='';
    fourthSleepLine3.textContent='';
    fourthSleepLine4.textContent='';
    fourthTitle.textContent='';

    fourthTransition.style.display='flex';
    fourthTransition.style.opacity='0';
    fourthTransition.style.transition='opacity 2000ms ease';
    await nextFrame();
    fourthTransition.style.opacity='1';

    const word = 'SLEEEEEEEEP,';

    for(let i=0;i<word.length;i++){
      fourthSleepLine1.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(fourthSleepLine1);
    await sleep(350);

    for(let i=0;i<word.length;i++){
      fourthSleepLine2.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(fourthSleepLine2);
    await sleep(350);

    for(let i=0;i<word.length;i++){
      fourthSleepLine3.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(fourthSleepLine3);
    await sleep(350);

    for(let i=0;i<word.length;i++){
      fourthSleepLine4.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(fourthSleepLine4);

    await sleep(900);

    fourthTitle.style.opacity='0';
    fourthTitle.style.transition='opacity 1500ms ease';
    fourthTitle.textContent='THE FOURTH SLEEP';
    fitTitleLine(fourthTitle);
    playDreamWoong();
    speakText('더 포스 슬립');
    await nextFrame();
    fourthTitle.style.opacity='1';

    await sleep(2200);

    fourthTransition.style.transition='opacity 2000ms ease';
    fourthTransition.style.opacity='0';
    await sleep(2100);
    fourthTransition.style.display='none';
    fourthTransition.style.transition='';
    fourthTitle.style.transition='';
    fourthTitle.style.opacity='1';

    startFourthTimer();
  }

  function goToSleepCity(){
    try{
      stopSecondBell();
      if(secondTimer){
        clearInterval(secondTimer);
        secondTimer = null;
      }
    }catch(e){}

    stage = 'third';
    finalLeft = 5*60;
    runTimer.textContent = formatMMSS(finalLeft);
    runTimer.style.display = 'block';

    if(finalTimer) clearInterval(finalTimer);
    finalTimer = setInterval(()=>{
      finalLeft = Math.max(0, finalLeft - 1);
      runTimer.textContent = formatMMSS(finalLeft);
      if(finalLeft <= 0){
        clearInterval(finalTimer);
        finalTimer = null;
        runTimer.style.display = 'none';
        startFourthSleepSequence();
      }
    }, 1000);
  }

  let micStream=null, micSrc=null, panNode=null, lpf=null, lowshelf=null, highshelf=null, revConvolver=null, dryGain=null, wetGain=null, micPreGain=null;
  function makeImpulse(ctx, seconds=6.0, decay=8.0){
    const rate=ctx.sampleRate;
    const len=rate*seconds;
    const ir=ctx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const data=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len;
        data[i]=(Math.random()*2-1)*Math.pow(1-t,decay);
      }
    }
    return ir;
  }

  async function startMicFXFadeIn(fadeSec=2.5){
    try{
      await ensureResumed();
      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({
          audio:{echoCancellation:true, noiseSuppression:true, autoGainControl:false},
          video:false
        });
      }
      if(!micSrc){
        micSrc = audioCtx.createMediaStreamSource(micStream);
      }

      micPreGain = audioCtx.createGain();
      micPreGain.gain.value = 1.0;

      lowshelf = audioCtx.createBiquadFilter();
      highshelf = audioCtx.createBiquadFilter();
      lpf = audioCtx.createBiquadFilter();
      panNode = audioCtx.createStereoPanner();

      lpf.type='lowpass';
      lpf.frequency.value=2800;
      lpf.Q.value=0.3;

      lowshelf.type='lowshelf';
      lowshelf.frequency.value=350;
      lowshelf.gain.value=0;

      highshelf.type='highshelf';
      highshelf.frequency.value=3500;
      highshelf.gain.value=0;

      revConvolver = audioCtx.createConvolver();
      revConvolver.buffer = makeImpulse(audioCtx, 6.0, 8.0);

      dryGain = audioCtx.createGain();
      wetGain = audioCtx.createGain();
      dryGain.gain.value = 0.0;
      wetGain.gain.value = 0.0;

      const out = audioCtx.createGain();
      out.gain.value = 0.7;

      micSrc.connect(micPreGain);
      micPreGain.connect(lowshelf)
               .connect(highshelf)
               .connect(lpf)
               .connect(panNode);

      panNode.connect(dryGain);
      panNode.connect(revConvolver);
      revConvolver.connect(wetGain);

      dryGain.connect(out);
      wetGain.connect(out);
      out.connect(audioCtx.destination);

      window.addEventListener('deviceorientation', onTiltAudio, {passive:true});

      const t = audioCtx.currentTime;
      dryGain.gain.linearRampToValueAtTime(0.6, t+fadeSec);
      wetGain.gain.linearRampToValueAtTime(0.6, t+fadeSec);
    }catch(e){
      console.warn('startMicFX error', e);
    }
  }

  function stopMicFXFadeOut(sec=2.5){
    try{
      if(!audioCtx) return;
      const t = audioCtx.currentTime;
      if(dryGain) dryGain.gain.linearRampToValueAtTime(0.0001, t+sec);
      if(wetGain) wetGain.gain.linearRampToValueAtTime(0.0001, t+sec);
      if(micPreGain) micPreGain.gain.linearRampToValueAtTime(0.0001, t+sec);
      setTimeout(()=>{
        try{
          if(micStream){
            micStream.getTracks().forEach(tr=>tr.stop());
          }
        }catch(e){}
        micStream=null;
        micSrc=null;
        panNode=null;
        lpf=null;
        lowshelf=null;
        highshelf=null;
        revConvolver=null;
        dryGain=null;
        wetGain=null;
        micPreGain=null;
        window.removeEventListener('deviceorientation', onTiltAudio);
      }, sec*1000+200);
    }catch(e){}
  }

  function onTiltAudio(e){
    if(!audioCtx || !panNode) return;

    const gamma = clamp(e.gamma ?? 0, -90, 90);
    panNode.pan.value = gamma / 90;

    const beta = clamp(e.beta ?? 0, -90, 90);

    if(lowshelf) {
      lowshelf.gain.value = (beta < 0) ? (beta / 90) * 10 : 0;
    }

    if(highshelf) {
      highshelf.gain.value = (beta > 0) ? (beta / 90) * 10 : 0;
    }

    if(lpf) {
      let cutoff;
      if(beta >= 0) {
        cutoff = 2800 + (beta / 90) * (4500 - 2800);
      } else {
        cutoff = 2800 + (beta / 90) * (2800 - 900);
      }
      lpf.frequency.value = clamp(cutoff, 900, 4500);
      lpf.Q.value = 0.2 + (Math.abs(beta) / 90) * 0.3;
    }

    if(wetGain && dryGain) {
      const tilt = Math.abs(beta) / 90;
      const wetBase = 0.42;
      const wetAmount = wetBase + tilt * 0.25;
      wetGain.gain.value = clamp(wetAmount, 0.35, 0.67);
      dryGain.gain.value = clamp(1.0 - wetGain.gain.value * 0.5, 0.5, 0.85);
    }
  }

  let metaReady=false;
  async function startCameraFresh(warmupOnly=false){
    try{
      if(!camPermGranted){
        await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}, audio:true})
          .then(s=>{
            s.getTracks().forEach(t=>t.stop());
            camPermGranted=true;
          });
      }
      if(!camVideo){
        camVideo=document.createElement('video');
        camVideo.setAttribute('playsinline','');
        camVideo.autoplay=true;
        camVideo.playsInline=true;
        camVideo.muted=true;
      }
      if(!camStream){
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:{ideal:'environment'},
            width:{min:1280,ideal:1920},
            height:{min:720,ideal:1080},
            aspectRatio:{ideal:16/9}
          },
          audio:false
        });
        camVideo.srcObject=camStream;
      }
      await camVideo.play().catch(()=>{});
      if (camVideo.readyState < 1){
        await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
      }
      metaReady=true;
      resizeAll();
      warmupFrames=0;

      if(!vctx){
        vctx=view.getContext('2d',{alpha:false});
      }
      if(!fgctx){
        fgctx=fg.getContext('2d',{alpha:true});
      }
      resizeAll();
      if(!animStarted && !warmupOnly){
        animStarted=true;
        loop();
      }
      document.querySelectorAll('.uiBtn').forEach(b=>{
        b.addEventListener('click', ()=>{
          primeAudio();
        }, {passive:true});
      });
    }catch(e){
      console.warn('startCameraFresh error:', e);
    }
  }

  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    if(vctx) vctx.setTransform(dpr,0,0,dpr,0,0);
    fg.width=w*dpr;
    fg.height=h*dpr;
    if(fgctx) fgctx.setTransform(dpr,0,0,dpr,0,0);
    if(mapOverlay.style.display!=='none') drawMap();
  }
  addEventListener('resize', ()=>{
    setTimeout(resizeAll,30);
    warmupFrames=30;
  }, {passive:true});

  function drawBestCover(ctx, video, W, H, PW, PH){
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(!vw||!vh) return;
    function coverScore(rot){
      let rw=rot?vh:vw, rh=rot?vw:vh;
      const s=Math.max(PW/rw, PH/rh)*ZOOM;
      const dw=rw*s, dh=rh*s;
      const letter=Math.max(0,(PW-dw))+Math.max(0,(PH-dh));
      return {rot,s,dw,dh,letter};
    }
    const a=coverScore(false), b=coverScore(true);
    let best=(b.letter<a.letter)?b:a;
    ctx.save();
    if(best.rot){
      ctx.translate(PW/2,PH/2);
      ctx.rotate(Math.PI/2);
      ctx.drawImage(video,-best.dh/2,-best.dw/2,best.dh,best.dw);
    }else{
      const dx=(PW-best.dw)/2;
      const dy=(PH-best.dh)/2;
      ctx.drawImage(video,dx,dy,best.dw,best.dh);
    }
    ctx.restore();
  }

  function loop(){
    requestAnimationFrame(loop);
    if(capturing) return;
    if(!vctx || !fgctx) return;

    const W=view.width/(devicePixelRatio||1);
    const H=view.height/(devicePixelRatio||1);
    if(warmupFrames>0){
      resizeAll();
      warmupFrames--;
    }

    vctx.clearRect(0,0,W,H);
    vctx.imageSmoothingEnabled=true;

    if (showCamera && camVideo && camVideo.readyState>=2){
      vctx.save();
      vctx.filter='grayscale(1)';
      drawBestCover(vctx, camVideo, W, H, W, H);
      vctx.restore();
      vctx.filter='none';
    } else {
      vctx.fillStyle='#000000';
      vctx.fillRect(0,0,W,H);
    }

    const pr=getFrameRect();
    fgctx.clearRect(0,0,W,H);
    if(showIntroLayer && fgAlpha>0.001){
      fgctx.save();
      fgctx.globalAlpha=fgAlpha;
      fgctx.beginPath();
      fgctx.rect(pr.x,pr.y,pr.w,pr.h);
      fgctx.clip();

      if(introWalking && introWalkers.length){
        const now=performance.now();
        const tGlobal=(now-introStartTime)/INTRO_WALK_DURATION;
        introWalkers.forEach(w=>{
          const t = ((tGlobal + w.tOffset)%1+1)%1;
          const pos = prosceniumWalkPos(t);
          const hop = Math.max(0,10*Math.sin(t*Math.PI*20));

          let angle = 0;
          if(pos.edge === 'bottom') angle = 0;
          else if(pos.edge === 'right') angle = -Math.PI/2;
          else if(pos.edge === 'top') angle = Math.PI;
          else if(pos.edge === 'left') angle = Math.PI/2;

          drawPixelHuman(
            fgctx,
            Math.round(pos.x),
            Math.round(pos.baselineY),
            W,
            hop,
            1,
            angle
          );

          if(now-w.bubbleTimer>700+Math.random()*500){
            w.bubbleIndex=(w.bubbleIndex+1)%bubbleSeq.length;
            w.bubbleTimer=now;
          }
          drawBubble(fgctx, Math.round(pos.x), Math.round(pos.baselineY)-28, bubbleSeq[w.bubbleIndex]);
        });
      }

      fgctx.restore();
    }

    if (camFadeAlpha > 0){
      vctx.save();
      vctx.fillStyle = `rgba(0,0,0,${camFadeAlpha})`;
      vctx.fillRect(0,0,W,H);
      vctx.restore();
    }
  }

  function fadeInCamera(ms=2500){
    showCamera = true;
    camFadeAlpha = 1;
    const t0 = performance.now();
    function step(){
      const k = Math.min(1, (performance.now()-t0)/ms);
      camFadeAlpha = 1-k;
      if(k<1){
        requestAnimationFrame(step);
      }else{
        camFadeAlpha = 0;
      }
    }
    step();
  }

  function fadeOutCamera(ms=2500){
    showCamera = true;
    camFadeAlpha = 0;
    const t0 = performance.now();
    function step(){
      const k = Math.min(1, (performance.now()-t0)/ms);
      camFadeAlpha = k;
      if(k<1){
        requestAnimationFrame(step);
      }else{
        camFadeAlpha = 1;
        showCamera = false;
      }
    }
    step();
  }

  let captureAnimating=false;
  captureBtn.addEventListener('click', ()=>{
    claimImmersive();
    if(captureAnimating) return;
    primeAudio();
    playWoongClick();
    captureAnimating=true;
    capturing=true;
    const cssW=view.clientWidth;
    const cssH=view.clientHeight;
    freezeLayer.width=cssW;
    freezeLayer.height=cssH;
    const displayCtx=freezeLayer.getContext('2d');
    displayCtx.imageSmoothingEnabled=false;
    freezeLayer.style.transition='';
    freezeLayer.style.opacity='0';
    freezeLayer.style.display='block';

    const snapshot=document.createElement('canvas');
    snapshot.width=cssW;
    snapshot.height=cssH;
    const snapCtx=snapshot.getContext('2d');
    snapCtx.imageSmoothingEnabled=false;
    snapCtx.drawImage(view,0,0,view.width,view.height,0,0,cssW,cssH);
    snapCtx.drawImage(fg,0,0,fg.width,fg.height,0,0,cssW,cssH);

    const off=document.createElement('canvas');
    const oc=off.getContext('2d');
    let px=2.4;
    const step=1.015;
    let revealed=false;
    function anim(){
      if(px>420){
        freezeLayer.style.transition='opacity 2000ms ease';
        freezeLayer.style.opacity='0';
        setTimeout(()=>{
          freezeLayer.style.display='none';
          freezeLayer.style.transition='';
          capturing=false;
          captureAnimating=false;
        },2020);
        return;
      }
      const w=Math.max(1,Math.floor(cssW/px));
      const h=Math.max(1,Math.floor(cssH/px));
      off.width=w;
      off.height=h;
      oc.imageSmoothingEnabled=false;
      oc.clearRect(0,0,w,h);
      oc.drawImage(snapshot,0,0,cssW,cssH,0,0,w,h);
      displayCtx.clearRect(0,0,cssW,cssH);
      displayCtx.imageSmoothingEnabled=false;
      displayCtx.globalAlpha=1.0;
      displayCtx.drawImage(off,0,0,w,h,0,0,cssW,cssH);
      if(!revealed){
        freezeLayer.style.opacity='1';
        revealed=true;
      }
      px=px*step+0.35;
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  });

  let introIndex=0;
  function resolveIntroLine(i){
    let line = INTRO_LINES[i] || '';
    return line.replace(/_____/g, displayName);
  }

  async function typeIntroLine(idx){
    introTextEl.textContent='';
    const text = resolveIntroLine(idx);
    // TTS: 인트로 문장은 한 줄 단위로 읽기
    speakText(text);
    for(let i=0;i<text.length;i++){
      introTextEl.textContent += text[i];
      typeTick();
      await sleep(24);
    }
  }

  introNextBtn.addEventListener('click', ()=>{
    primeAudio();
    playWoongClick();
    introIndex++;
    if(introIndex >= INTRO_LINES.length){
      fadeHide(introDialogue, 300);
      setTimeout(async ()=>{
        await playTduung();
        startIntroToFirstSleepSequence();
      }, 320);
    }else{
      typeIntroLine(introIndex);
    }
  }, {passive:true});

  function fadeIntroLayerOut(ms=4500){
    const t0=performance.now();
    const startAlpha=fgAlpha;
    function step(){
      const k=Math.min(1,(performance.now()-t0)/ms);
      fgAlpha=startAlpha*(1-k);
      if(k<1){
        requestAnimationFrame(step);
      }else{
        fgAlpha=0;
        showIntroLayer=false;
        introWalking=false;
        if(fgctx){
          const W=view.width/(devicePixelRatio||1);
          const H=view.height/(devicePixelRatio||1);
          fgctx.clearRect(0,0,W,H);
        }
      }
    }
    step();
  }

  async function runFirstSleepTitleSequence(){
    firstTransWord.textContent='';
    firstTransTitle.textContent='';

    firstTransition.style.display='flex';
    firstTransition.style.opacity='0';
    firstTransition.style.transition='opacity 2000ms ease';
    await nextFrame();
    firstTransition.style.opacity='1';

    const word = 'SLEEEEEEEEP,';
    for(let i=0;i<word.length;i++){
      firstTransWord.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(firstTransWord);

    await sleep(900);

    firstTransTitle.style.opacity = '0';
    firstTransTitle.style.transition = 'opacity 1500ms ease';
    firstTransTitle.textContent = 'THE FIRST SLEEP';
    fitTitleLine(firstTransTitle);
    playDreamWoong();
    speakText('더 퍼스트 슬립');
    await nextFrame();
    firstTransTitle.style.opacity = '1';

    await sleep(2000);

    if (Ambient && Ambient.isRunning && Ambient.isRunning()){
      Ambient.stop(3.0);
    }

    firstTransition.style.transition='opacity 2000ms ease';
    firstTransition.style.opacity='0';
    await sleep(2100);
    firstTransition.style.display='none';
    firstTransition.style.transition='';
    firstTransTitle.style.transition='';
    firstTransTitle.style.opacity='1';
  }

  async function startIntroToFirstSleepSequence(){
    claimImmersive();
    await ensureResumed();

    introWalking=true;
    fadeIntroLayerOut(4500);

    await sleep(1000);
    await runFirstSleepTitleSequence();

    showNoticePopup();
  }

  function showNoticePopup(){
    function bgTrap(e){
      if(!e.target.closest('#noticeCard')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup.addEventListener(ev, bgTrap, {passive:false});
    });
    fadeShow(noticePopup, 280, 'flex');
    playBellChime();
    setTimeout(()=>{
      noticeOk && noticeOk.focus && noticeOk.focus();
    }, 50);
    noticeOk.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      playWoongClick();
      fadeHide(noticePopup, 250);
      await sleep(260);

      fadeInCamera(2500);
      startMicFXFadeIn(2.5);

      controls.classList.add('show');
      captureBtn.classList.add('show');

      stage = 'first';
      startMainTimer();
      startFirstSleepStory();
    };
  }

  async function typeFirstSleepLine(text){
    chapterBox.innerHTML='';
    const speak = text.replace(/\n/g,' ');
    speakText(speak);
    for(let i=0;i<text.length;i++){
      const ch = text[i];
      if(ch === '\n'){
        chapterBox.appendChild(document.createElement('br'));
        continue;
      }
      const span = document.createElement('span');
      span.className = 'charBox';
      span.textContent = ch;
      chapterBox.appendChild(span);
      typeTick();
      await sleep(26);
    }
  }

  async function startFirstSleepStory(){
    claimImmersive();
    await ensureResumed();
    fadeShow(chapterOverlay, 400, 'flex');
    await sleep(420);

    for(const line of FIRST_SLEEP_LINES){
      await typeFirstSleepLine(line);
      await sleep(4000);
    }

    fadeHide(chapterOverlay, 800);
  }

  async function runSecondSleepTitleSequence(){
    sleepLine1.textContent = '';
    sleepLine2.textContent = '';
    sleepSecondTitle.textContent = '';
    sleepTransition.style.display='flex';
    sleepTransition.style.opacity='0';
    sleepTransition.style.transition='opacity 2000ms ease';
    await nextFrame();
    sleepTransition.style.opacity='1';

    const line1 = 'SLEEEEEEEEP,';
    const line2 = 'SLEEEEEEEEP,';

    for(let i=0;i<line1.length;i++){
      sleepLine1.textContent += line1[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(sleepLine1);

    await sleep(350);
    for(let i=0;i<line2.length;i++){
      sleepLine2.textContent += line2[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(sleepLine2);

    await sleep(900);

    sleepSecondTitle.style.opacity = '0';
    sleepSecondTitle.style.transition = 'opacity 1500ms ease';
    sleepSecondTitle.textContent = 'THE SECOND SLEEP';
    fitTitleLine(sleepSecondTitle);
    playDreamWoong();
    speakText('더 세컨드 슬립');
    await nextFrame();
    sleepSecondTitle.style.opacity = '1';

    await sleep(2200);

    sleepTransition.style.transition='opacity 2000ms ease';
    sleepTransition.style.opacity='0';
    await sleep(2100);
    sleepTransition.style.display='none';
    sleepTransition.style.transition='';
    sleepSecondTitle.style.transition='';
    sleepSecondTitle.style.opacity='1';
  }

  async function onFirstSleepTimerEnd(){
    claimImmersive();
    await ensureResumed();

    controls.classList.remove('show');
    captureBtn.classList.remove('show');
    runTimer.style.display='none';

    fadeHide(chapterOverlay, 800);

    fadeOutCamera(2500);
    stopMicFXFadeOut(2.5);

    await sleep(400);
    await runSecondSleepTitleSequence();

    stage = 'secondIntro';
    showSecondNoticePopup();
  }

  function showSecondNoticePopup(){
    function bgTrap2(e){
      if(!e.target.closest('#noticeCard2')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup2.addEventListener(ev, bgTrap2, {passive:false});
    });
    fadeShow(noticePopup2, 280, 'flex');
    playBellChime();
    setTimeout(()=>{
      noticeOk2 && noticeOk2.focus && noticeOk2.focus();
    }, 50);

    noticeOk2.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      playWoongClick();
      fadeHide(noticePopup2, 260);
      await sleep(280);
      await playBellChime();
      showMapOverlay();
    };
  }

  async function startThirdSleepSequence(){
    claimImmersive();
    await ensureResumed();

    stage = 'thirdIntro';

    thirdSleepLine1.textContent='';
    thirdSleepLine2.textContent='';
    thirdSleepLine3.textContent='';
    thirdTitle.textContent='';

    thirdTransition.style.display='flex';
    thirdTransition.style.opacity='0';
    thirdTransition.style.transition='opacity 2000ms ease';
    await nextFrame();
    thirdTransition.style.opacity='1';

    const word = 'SLEEEEEEEEP,';

    for(let i=0;i<word.length;i++){
      thirdSleepLine1.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(thirdSleepLine1);
    await sleep(350);

    for(let i=0;i<word.length;i++){
      thirdSleepLine2.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(thirdSleepLine2);
    await sleep(350);

    for(let i=0;i<word.length;i++){
      thirdSleepLine3.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(thirdSleepLine3);

    await sleep(900);

    thirdTitle.style.opacity='0';
    thirdTitle.style.transition='opacity 1500ms ease';
    thirdTitle.textContent='THE THIRD SLEEP';
    fitTitleLine(thirdTitle);
    playDreamWoong();
    speakText('더 써드 슬립');
    await nextFrame();
    thirdTitle.style.opacity='1';

    await sleep(2200);

    thirdTransition.style.transition='opacity 1800ms ease';
    thirdTransition.style.opacity='0';
    await sleep(1900);
    thirdTransition.style.display='none';
    thirdTransition.style.transition='';
    thirdTitle.style.transition='';
    thirdTitle.style.opacity='1';

    showThirdNotice();
  }

  function showThirdNotice(){
    function bgTrap3(e){
      if(!e.target.closest('#noticeCard3')){
        e.stopPropagation();
        e.preventDefault();
      }
    }
    ['touchstart','touchmove','pointerdown','click','wheel','keydown'].forEach(ev=>{
      noticePopup3.addEventListener(ev, bgTrap3, {passive:false});
    });
    fadeShow(noticePopup3, 280, 'flex');
    playBellChime();
    setTimeout(()=>{ noticeOk3 && noticeOk3.focus && noticeOk3.focus(); }, 50);

    noticeOk3.onclick = async (e)=>{
      e.stopPropagation();
      claimImmersive();
      await ensureResumed();
      playWoongClick();
      fadeHide(noticePopup3, 260);
      await sleep(300);
      goToSleepCity();
    };
  }

  async function showIntroFlow(){
    claimImmersive();
    await ensureResumed();
    if(!Ambient.isRunning()) Ambient.start(0.8, 1.0);

    showCamera = false;
    camFadeAlpha = 0;

    introBig.style.display = 'flex';
    introBig.style.opacity = '1';
    introBig.style.transition = 'none';
    const word = 'INTRODUCTION';
    introBigText.textContent = '';
    speakText('인트로덕션');
    for(let i=0;i<word.length;i++){
      introBigText.textContent += word[i];
      typeTick();
      await sleep(45);
    }
    fitTitleLine(introBigText);

    await sleep(1400);
    introBig.style.transition = 'opacity 1600ms ease';
    introBig.style.opacity = '0';
    await sleep(1700);
    introBig.style.display = 'none';

    introWalking = true;
    introStartTime = performance.now();
    showIntroLayer = true;
    fgAlpha = 1.0;
    initIntroWalkers();

    introIndex = 0;
    fadeShow(introDialogue, 300, 'block');
    typeIntroLine(introIndex);
  }

  document.getElementById('goIntro').addEventListener('click', ()=>{
    primeAudio();
    ensureResumed().then(async ()=>{
      claimImmersive();
      if(!Ambient.isRunning()) Ambient.start(0.8,1.0);
      playWoongClick();
      fadeHide(welcome, FADE);
      stage = 'intro';
      showIntroFlow();
    });
  }, {passive:true});

  let mapMarkers = [];

  function drawMap(){
    if(!mapOverlay || mapOverlay.style.display==='none') return;
    const rect = mapOverlay.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const dpr = window.devicePixelRatio || 1;
    mapCanvas.width = w*dpr;
    mapCanvas.height = h*dpr;
    const ctx = mapCanvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,w,h);

    const cx = w*0.5;
    const cy = h*0.5;

    const mw = w*0.7;
    const mh = h*0.6;
    const left = cx - mw/2;
    const top  = cy - mh/2;

    ctx.fillStyle = '#000';
    ctx.fillRect(left, top, mw, mh);
    ctx.strokeStyle='rgba(208,208,208,0.85)';
    ctx.lineWidth=2;
    ctx.strokeRect(left, top, mw, mh);

    const r = Math.min(mw,mh)*0.16;
    ctx.fillStyle='#555555';
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const ang = Math.PI/2 + i*Math.PI/3;
      const x = cx + r*Math.cos(ang);
      const y = cy + r*Math.sin(ang);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    mapMarkers=[];
    const rectW = r*0.9;
    const rectH = r*0.5;
    const offsets = [
      {id:1, dx:0,       dy:-r*1.7},
      {id:2, dx:r*1.45,  dy:-r*1.05},
      {id:3, dx:r*1.9,   dy:0},
      {id:4, dx:r*1.45,  dy:r*1.05},
      {id:5, dx:0,       dy:r*1.7},
      {id:6, dx:-r*1.45, dy:r*1.05},
      {id:7, dx:-r*1.9,  dy:0},
      {id:8, dx:-r*1.45, dy:-r*1.05}
    ];

    ctx.font='14px "Press Start 2P","Courier New",monospace';
    ctx.textAlign='center';
    ctx.textBaseline='middle';

    offsets.forEach(o=>{
      const cxRect = cx + o.dx;
      const cyRect = cy + o.dy;
      const x = cxRect - rectW/2;
      const y = cyRect - rectH/2;

      mapMarkers.push({id:o.id, x, y, w:rectW, h:rectH});

      ctx.fillStyle='rgba(0,0,0,0.85)';
      ctx.fillRect(x,y,rectW,rectH);
      ctx.strokeStyle='rgba(208,208,208,0.9)';
      ctx.strokeRect(x,y,rectW,rectH);
      ctx.fillStyle='rgba(208,208,208,0.96)';
      ctx.fillText(String(o.id), x+rectW/2, y+rectH/2+1);
    });
  }

  function showMapOverlay(){
    fadeShow(mapOverlay, 600, 'flex');
    setTimeout(drawMap, 80);
    stage = 'second';
    startSecondTimer();
    startSecondBell();
    runTimer.style.display='block';
  }

  function openMarkerPopup(id){
    mapPopBody.textContent = `ZONE ${id}`;
    speakText(`존 ${id}`);
    mapPop.style.display='flex';
  }

  mapPopClose.addEventListener('click', (e)=>{
    e.stopPropagation();
    mapPop.style.display='none';
  }, {passive:true});

  mapCanvas.addEventListener('pointerdown', (e)=>{
    const rect = mapCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    for(const m of mapMarkers){
      if(x>=m.x && x<=m.x+m.w && y>=m.y && y<=m.y+m.h){
        openMarkerPopup(m.id);
        break;
      }
    }
  });

  function setAppH2(){ document.documentElement.style.setProperty('--appH', window.innerHeight + 'px'); }
  setAppH2();
  addEventListener('resize', setAppH2, {passive:true});
  if (window.visualViewport){
    visualViewport.addEventListener('resize', ()=>setTimeout(setAppH2,50));
  }

  async function endSecondStageAndStartThird(){
    fadeHide(mapOverlay, 600);
    mapPop.style.display = 'none';
    await sleep(650);
    await startThirdSleepSequence();
  }

  /* ====== SKIP 버튼 ====== */
  skipBtn.addEventListener('click', ()=>{
    primeAudio();
    playWoongClick();

    if(stage === 'intro'){
      fadeHide(introDialogue, 300);
      introWalking=false;
      showIntroLayer=false;
      setTimeout(async ()=>{
        await playTduung();
        startIntroToFirstSleepSequence();
      }, 350);
    }else if(stage === 'first'){
      if(mainTimer){
        clearInterval(mainTimer);
        mainTimer=null;
      }
      timerFinished = true;
      onFirstSleepTimerEnd();
    }else if(stage === 'second'){
      stopSecondBell();
      if(secondTimer){
        clearInterval(secondTimer);
        secondTimer=null;
      }
      runTimer.style.display='none';
      endSecondStageAndStartThird();
    }else if(stage === 'thirdIntro'){
      goToSleepCity();
    }else if(stage === 'third'){
      if(finalTimer){
        clearInterval(finalTimer);
        finalTimer = null;
      }
      runTimer.style.display='none';
      startFourthSleepSequence();
    }else if(stage === 'fourthIntro'){
      startFourthTimer();
    }else if(stage === 'fourth'){
      if(fourthTimer){
        clearInterval(fourthTimer);
        fourthTimer = null;
      }
      runTimer.style.display='none';
      showEndingSequence();
    }else if(stage === 'silence'){
      if(silenceTimer){
        clearInterval(silenceTimer);
        silenceTimer=null;
      }
      runTimer.style.display='none';
      startTheEndChapter();
    }else if(stage === 'theEnd'){
      if(endTimer){
        clearInterval(endTimer);
        endTimer=null;
      }
      runTimer.style.display='none';
      if(endReturn){
        endReturn.textContent = '※ 프로그램이 종료되었습니다. 태블릿과 헤드폰을 반납해 주세요.';
      }
    }else{
      if(mainTimer){
        clearInterval(mainTimer);
        mainTimer=null;
      }
      timerFinished = true;
      onFirstSleepTimerEnd();
    }
  }, {passive:true});

  startCameraFresh(true);
  if(!animStarted){
    animStarted=true;
    loop();
  }

  // stage 전역
  window.stage = 'gate';
})();
</script>